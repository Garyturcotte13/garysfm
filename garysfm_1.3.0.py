
import os
import sys
import wave
import struct
import logging
import hashlib
import tempfile
import time
import traceback
import functools
import psutil
import math
from pathlib import Path
from typing import Optional, Dict, List, Union, Any, Callable, TypeVar, Tuple, Set
from dataclasses import dataclass
from contextlib import contextmanager
from PyQt5.QtCore import QSettings
import builtins as _builtins
from PyQt5.QtCore import qInstallMessageHandler, QtMsgType

# Configure basic logging: only show ERROR and above to quiet debug/info messages
logging.basicConfig(level=logging.ERROR)

# ==================== CUSTOM EXCEPTIONS ====================
class FileManagerError(Exception):
    """Base exception for all file manager errors"""
    pass

class ThumbnailError(FileManagerError):
    """Errors related to thumbnail generation and caching"""
    pass

class NetworkError(FileManagerError):
    """Errors related to network operations (SMB, FTP, cloud sync)"""
    pass

class CacheError(FileManagerError):
    """Errors related to caching operations"""
    pass

class ArchiveError(FileManagerError):
    """Errors related to archive operations"""
    pass

class ConfigurationError(FileManagerError):
    """Errors related to configuration and settings"""
    pass

class BookmarkError(FileManagerError):
    """Errors related to bookmark operations"""
    pass

# ==================== PERFORMANCE PROFILING ====================
@dataclass
class PerformanceMetrics:
    """Container for performance metrics"""
    operation_name: str
    duration: float
    memory_before: float
    memory_after: float
    timestamp: float

class PerformanceProfiler:
    """Performance profiling system for monitoring operations"""
    
    def __init__(self) -> None:
        self.metrics: List[PerformanceMetrics] = []
        self.enabled: bool = True
    
    def enable(self) -> None:
        """Enable performance profiling"""
        self.enabled = True
    
    def disable(self) -> None:
        """Disable performance profiling"""
        self.enabled = False
    
    def record_metric(self, metric: PerformanceMetrics) -> None:
        """Record a performance metric"""
        if self.enabled:
            self.metrics.append(metric)
    
    def get_metrics(self) -> List[PerformanceMetrics]:
        """Get all recorded metrics"""
        return self.metrics.copy()
    
    def clear_metrics(self) -> None:
        """Clear all recorded metrics"""
        self.metrics.clear()
    
    def get_summary(self) -> Dict[str, Any]:
        """Get summary statistics of recorded metrics"""
        if not self.metrics:
            return {}
        
        operations = {}
        for metric in self.metrics:
            if metric.operation_name not in operations:
                operations[metric.operation_name] = {
                    'count': 0,
                    'total_duration': 0,
                    'max_duration': 0,
                    'min_duration': float('inf'),
                    'total_memory_delta': 0
                }
            
            op = operations[metric.operation_name]
            op['count'] += 1
            op['total_duration'] += metric.duration
            op['max_duration'] = max(op['max_duration'], metric.duration)
            op['min_duration'] = min(op['min_duration'], metric.duration)
            op['total_memory_delta'] += (metric.memory_after - metric.memory_before)
        
        # Calculate averages
        for op_name, stats in operations.items():
            stats['avg_duration'] = stats['total_duration'] / stats['count']
            stats['avg_memory_delta'] = stats['total_memory_delta'] / stats['count']
        
        return operations
    
    def profile_method(self, operation_name: Optional[str] = None) -> Callable:
        """Decorator method for profiling functions"""
        def decorator(func: Callable) -> Callable:
            name = operation_name or f"{func.__qualname__}"
            return profile_performance(name)(func)
        return decorator

# Global performance profiler instance
performance_profiler = PerformanceProfiler()

def profile_performance(operation_name: str) -> Callable:
    """Decorator to profile function performance"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            if not performance_profiler.enabled:
                return func(*args, **kwargs)
            
            # Get memory usage before
            process = psutil.Process()
            memory_before = process.memory_info().rss / 1024 / 1024  # MB
            start_time = time.perf_counter()
            
            try:
                result = func(*args, **kwargs)
                return result
            finally:
                # Record metrics
                end_time = time.perf_counter()
                memory_after = process.memory_info().rss / 1024 / 1024  # MB
                
                metric = PerformanceMetrics(
                    operation_name=operation_name,
                    duration=end_time - start_time,
                    memory_before=memory_before,
                    memory_after=memory_after,
                    timestamp=time.time()
                )
                performance_profiler.record_metric(metric)
        
        return wrapper
    return decorator

@contextmanager
def performance_context(operation_name: str):
    """Context manager for profiling code blocks"""
    if not performance_profiler.enabled:
        yield
        return
    
    process = psutil.Process()
    memory_before = process.memory_info().rss / 1024 / 1024  # MB
    start_time = time.perf_counter()
    
    try:
        yield
    finally:
        end_time = time.perf_counter()
        memory_after = process.memory_info().rss / 1024 / 1024  # MB
        
        metric = PerformanceMetrics(
            operation_name=operation_name,
            duration=end_time - start_time,
            memory_before=memory_before,
            memory_after=memory_after,
            timestamp=time.time()
        )
        performance_profiler.record_metric(metric)

# ==================== IMPROVED LOGGING ====================
def setup_logger(name: str, level: int = logging.INFO) -> logging.Logger:
    """Setup a logger with proper formatting"""
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '[%(asctime)s] %(name)s - %(levelname)s: %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    return logger
# Force DEBUG logging for thumbnail logger on macOS - DISABLED FOR VERBOSITY REDUCTION
if False and sys.platform == 'darwin':
    thumbnail_logger = logging.getLogger('thumbnail')
    thumbnail_logger.setLevel(logging.DEBUG)
    # Add a console handler if not present
    if not any(isinstance(h, logging.StreamHandler) for h in thumbnail_logger.handlers):
        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)
        formatter = logging.Formatter('[THUMBNAIL-LOG] %(levelname)s: %(message)s')
        ch.setFormatter(formatter)
        thumbnail_logger.addHandler(ch)

# ==================== ENHANCED LOGGING SYSTEM ====================
# Setup specialized loggers
thumbnail_logger = setup_logger('thumbnail', logging.INFO)
icon_container_logger = setup_logger('icon_container', logging.INFO)
event_filter_logger = setup_logger('event_filter', logging.INFO)
cache_logger = setup_logger('cache', logging.INFO)
network_logger = setup_logger('network', logging.INFO)

# Global toggle and helpers for thumbnail debug/info/error messages.
# Put these at module scope so any function can use them.
THUMBNAIL_VERBOSE: bool = False

# Toggle for noisy event-filter debug messages
EVENT_FILTER_VERBOSE: bool = False

# Toggle for noisy icon-container debug messages (mouse/space clicks in the icon grid)
ICON_CONTAINER_VERBOSE: bool = False

# Global debug flag to control ALL debug output - SET TO FALSE TO REDUCE VERBOSITY
GLOBAL_DEBUG_ENABLED: bool = False

# Thumbnail cache optimization settings
CACHE_GRACE_PERIOD_SECONDS: int = 300  # 5 minutes - consider cache valid even if file is slightly newer
EXTENDED_CACHE_VALIDITY_HOURS: int = 24  # 24 hours - for stable file types, extend cache validity
STABLE_FILE_EXTENSIONS: Set[str] = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.pdf', '.ico'}  # File types that rarely change

def icon_container_debug(msg: str, *args) -> None:
    """Debug logging for icon container events"""
    try:
        if ICON_CONTAINER_VERBOSE:
            icon_container_logger.debug(msg.format(*args))
    except Exception as e:
        icon_container_logger.error(f"Error in icon_container_debug: {e}")

def event_filter_debug(msg: str, *args) -> None:
    """Debug logging for event filter operations"""
    try:
        if EVENT_FILTER_VERBOSE:
            event_filter_logger.debug(msg.format(*args))
    except Exception as e:
        event_filter_logger.error(f"Error in event_filter_debug: {e}")

def thumbnail_debug(msg: str, *args) -> None:
    """Debug logging for thumbnail operations"""
    try:
        if THUMBNAIL_VERBOSE:
            thumbnail_logger.debug(msg.format(*args))
    except Exception as e:
        thumbnail_logger.error(f"Error in thumbnail_debug: {e}")

def thumbnail_info(msg: str, *args) -> None:
    """Info logging for thumbnail operations"""
    try:
        if THUMBNAIL_VERBOSE:
            thumbnail_logger.info(msg.format(*args))
    except Exception as e:
        thumbnail_logger.error(f"Error in thumbnail_info: {e}")

def thumbnail_error(msg: str, *args) -> None:
    """Error logging for thumbnail operations"""
    try:
        # Always show errors so failures are visible even when verbose is off
        thumbnail_logger.error(msg.format(*args))
    except Exception as e:
        # Fallback to basic logging if our logger fails
        logging.error(f"Thumbnail error (logger failed): {msg.format(*args) if args else msg}")

def is_thumb_file(path: Union[str, Path]) -> bool:
    """Return True if the path represents a thumbnail cache file (ends with .thumb)."""
    try:
        path_str = str(path) if isinstance(path, Path) else path
        return isinstance(path_str, str) and path_str.lower().endswith('.thumb')
    except Exception as e:
        thumbnail_logger.error(f"Error checking thumb file status for {path}: {e}")
        return False
@profile_performance('waveform_thumbnail_generation')
def get_waveform_thumbnail(
    wav_path: Union[str, Path], 
    width: int = 128, 
    height: int = 48, 
    color: Optional['QColor'] = None, 
    thumbnail_cache: Optional['ThumbnailCache'] = None
) -> Optional['QPixmap']:
    """Generate a waveform QPixmap thumbnail for WAV/MP3 using soundfile, wave, or pydub fallbacks.
    
    Args:
        wav_path: Path to the audio file
        width: Thumbnail width in pixels
        height: Thumbnail height in pixels
        color: Color for waveform rendering
        thumbnail_cache: Optional thumbnail cache instance
        
    Returns:
        QPixmap of the waveform or None on failure
        
    Raises:
        ThumbnailError: If thumbnail generation fails
    """
    logger = thumbnail_logger
    
    # Avoid evaluating QColor at import time (can be undefined in some import orders)
    if color is None:
        try:
            from PyQt5.QtGui import QColor
            color = QColor('deepskyblue')
        except ImportError as e:
            raise ThumbnailError(f"Failed to import QColor: {e}")
        except Exception as e:
            logger.error(f"Unexpected error importing QColor: {e}")
            color = None
    
    # Convert to Path object for consistent handling
    wav_path = Path(wav_path) if not isinstance(wav_path, Path) else wav_path
    
    logger.debug('get_waveform_thumbnail called for: %s', wav_path)
    logger.debug('File exists: %s | Path: %s', wav_path.exists(), wav_path)
    logger.debug('File extension: %s', wav_path.suffix.lower())
    
    # Guard: don't attempt to generate thumbnails for files that are themselves thumbnail cache files
    if is_thumb_file(wav_path):
        logger.debug('Skipping waveform thumbnail generation for .thumb file: %s', wav_path)
        return None
    
    # Validate input parameters
    if width <= 0 or height <= 0:
        raise ThumbnailError(f"Invalid dimensions: width={width}, height={height}")
    
    if not wav_path.exists():
        raise ThumbnailError(f"Audio file does not exist: {wav_path}")
    
    if not wav_path.is_file():
        raise ThumbnailError(f"Path is not a file: {wav_path}")
    
    try:
        with performance_context('waveform_cache_setup'):
            # Setup cache directory with proper error handling
            temp_dir = _setup_thumbnail_cache_directory()
        
        # Generate cache key and path
        file_hash = hashlib.md5(str(wav_path).encode('utf-8')).hexdigest()
        cache_key = f"{file_hash}_{width}"
        thumb_path = temp_dir / f"{cache_key}.thumb"
        logger.debug('Thumbnail cache file path: %s', thumb_path)

        # Check for cached thumbnail
        with performance_context('waveform_cache_check'):
            cached_pixmap = _check_cached_thumbnail(thumb_path, logger)
            if cached_pixmap is not None:
                return cached_pixmap

        # Generate waveform data
        with performance_context('waveform_data_extraction'):
            audio_data = _extract_audio_data(wav_path, logger)
            if not audio_data:
                logger.debug('No waveform data for %s', wav_path)
                return None

        # Process and render waveform
        with performance_context('waveform_rendering'):
            pixmap = _render_waveform(audio_data, width, height, color)
        
        # Save to cache
        with performance_context('waveform_cache_save'):
            _save_thumbnail_to_cache(pixmap, thumb_path, logger)
        
        return pixmap
        
    except ThumbnailError:
        raise  # Re-raise our custom exceptions
    except Exception as e:
        error_msg = f'Unexpected error generating waveform for {wav_path}: {e}'
        logger.error(error_msg)
        logger.debug('Full traceback: %s', traceback.format_exc())
        raise ThumbnailError(error_msg) from e


def _setup_thumbnail_cache_directory() -> Path:
    """Setup thumbnail cache directory with proper error handling"""
    try:
        if sys.platform == 'darwin':
            home = Path.home()
            thumbnail_logger.debug('macOS detected. Home dir resolved as: %s', home)
            temp_dir = home / '.garysfm_thumbnails'
            thumbnail_logger.debug('macOS: Forcing thumbnail cache dir: %s', temp_dir)
            
            try:
                temp_dir.mkdir(exist_ok=True)
                thumbnail_logger.debug('Thumbnail cache directory ensured: %s', temp_dir)
            except OSError as e:
                thumbnail_logger.error('Failed to create thumbnail cache directory in home: %s: %s', temp_dir, e)
                # Fallback to /tmp/garysfm_thumbnails
                temp_dir = Path('/tmp/garysfm_thumbnails')
                thumbnail_logger.debug('macOS: Fallback to /tmp/garysfm_thumbnails')
                try:
                    temp_dir.mkdir(exist_ok=True)
                    thumbnail_logger.debug('Fallback thumbnail cache directory ensured: %s', temp_dir)
                except OSError as e2:
                    error_msg = f'Failed to create fallback thumbnail cache directory: {temp_dir}: {e2}'
                    thumbnail_logger.error(error_msg)
                    raise CacheError(error_msg) from e2
        else:
            temp_base = Path(os.environ.get('TEMP', '/tmp'))
            temp_dir = temp_base / 'garysfm_thumbnails'
            thumbnail_logger.debug('Non-macOS. Using thumbnail cache dir: %s', temp_dir)
            try:
                temp_dir.mkdir(exist_ok=True)
                thumbnail_logger.debug('Thumbnail cache directory ensured: %s', temp_dir)
            except OSError as e:
                error_msg = f'Failed to create thumbnail cache directory {temp_dir}: {e}'
                thumbnail_logger.error(error_msg)
                raise CacheError(error_msg) from e
        
        return temp_dir
        
    except Exception as e:
        error_msg = f'Unexpected error setting up cache directory: {e}'
        thumbnail_logger.error(error_msg)
        raise CacheError(error_msg) from e


def _check_cached_thumbnail(thumb_path: Path, logger: logging.Logger) -> Optional['QPixmap']:
    """Check for existing cached thumbnail"""
    try:
        from PyQt5.QtGui import QPixmap
        
        # Check if cache file exists
        cache_file_found = False
        if sys.platform == 'darwin':
            try:
                dir_listing = list(thumb_path.parent.iterdir())
                cache_file_found = thumb_path in dir_listing
                thumbnail_logger.debug('Cache file check - expected: %s, found in listing: %s', 
                                     thumb_path.name, cache_file_found)
            except OSError as e:
                thumbnail_logger.warning('Error checking directory listing: %s', e)
                cache_file_found = False
        else:
            cache_file_found = thumb_path.exists()
        
        if cache_file_found:
            logger.debug('Cached thumbnail exists: %s', thumb_path)
            pixmap = QPixmap(str(thumb_path))
            if pixmap.isNull():
                logger.warning('Cached thumbnail file exists but failed to load as QPixmap: %s', thumb_path)
                # Remove corrupted cache file
                try:
                    thumb_path.unlink()
                    logger.debug('Removed corrupted cache file: %s', thumb_path)
                except OSError as e:
                    logger.warning('Failed to remove corrupted cache file: %s', e)
                return None
            else:
                logger.debug('Loaded cached QPixmap successfully: %s', thumb_path)
                return pixmap
        
        return None
        
    except ImportError as e:
        raise ThumbnailError(f"Failed to import QPixmap: {e}")
    except Exception as e:
        logger.warning('Error checking cached thumbnail: %s', e)
        return None


def _extract_audio_data(wav_path: Path, logger: logging.Logger) -> Optional[List[float]]:
    """Extract audio data from various audio formats with fallbacks"""
    data = None
    
    # Try soundfile first
    try:
        import soundfile as sf
        logger.debug('Using soundfile to read: %s', wav_path)
        data, samplerate = sf.read(str(wav_path))
        if hasattr(data, 'ndim') and data.ndim > 1:
            data = data[:, 0]  # Take first channel for stereo
        data = data.tolist() if hasattr(data, 'tolist') else list(data)
        logger.debug('Successfully read audio data using soundfile: %d samples', len(data))
        return data
    except ImportError:
        logger.debug('soundfile not available, trying alternatives')
    except Exception as e:
        logger.debug('soundfile failed for %s: %s', wav_path, e)
    
    # Fallback to stdlib wave for WAV files
    if wav_path.suffix.lower() == '.wav':
        try:
            with wave.open(str(wav_path), 'rb') as wf:
                n_channels = wf.getnchannels()
                sampwidth = wf.getsampwidth()
                n_frames = wf.getnframes()
                frames = wf.readframes(n_frames)
                
                if sampwidth == 1:
                    fmt = f"{n_frames * n_channels}B"
                    data = struct.unpack(fmt, frames)
                    data = [x - 128 for x in data]  # Convert to signed
                elif sampwidth == 2:
                    fmt = f"{n_frames * n_channels}h"
                    data = struct.unpack(fmt, frames)
                else:
                    raise ThumbnailError(f'Unsupported sample width: {sampwidth} for {wav_path}')
                
                # Extract single channel for stereo
                if n_channels > 1:
                    data = data[::n_channels]
                
                logger.debug('Successfully read WAV data using wave module: %d samples', len(data))
                return list(data)
                
        except wave.Error as e:
            raise ThumbnailError(f'WAV format error for {wav_path}: {e}')
        except struct.error as e:
            raise ThumbnailError(f'Audio data parsing error for {wav_path}: {e}')
        except Exception as e:
            logger.error('wave backend failed for %s: %s', wav_path, e)
    
    # Fallback to pydub for MP3 files
    elif wav_path.suffix.lower() == '.mp3':
        try:
            from pydub import AudioSegment
            audio = AudioSegment.from_mp3(str(wav_path))
            samples = audio.get_array_of_samples()
            data = samples[::audio.channels] if audio.channels > 1 else samples
            data = list(data)
            logger.debug('Successfully read MP3 data using pydub: %d samples', len(data))
            return data
        except ImportError:
            raise ThumbnailError(f'pydub not available for MP3 file: {wav_path}')
        except Exception as e:
            logger.error('pydub fallback failed for %s: %s', wav_path, e)
            raise ThumbnailError(f'MP3 processing failed for {wav_path}: {e}')
    
    # No suitable backend found
    raise ThumbnailError(f'No suitable audio backend for file: {wav_path}')


def _render_waveform(data: List[float], width: int, height: int, color: Optional['QColor']) -> 'QPixmap':
    """Render waveform data into a QPixmap"""
    try:
        from PyQt5.QtGui import QPixmap, QPainter, QColor
        
        if not data:
            raise ThumbnailError('No audio data to render')
        
        # Downsample to width
        step = max(1, len(data) // width)
        samples = []
        for i in range(0, len(data), step):
            chunk = data[i:i+step]
            if chunk:
                # Use RMS for better representation of audio energy
                rms = (sum(x*x for x in chunk) / len(chunk)) ** 0.5
                samples.append(rms)
        
        # Ensure we have enough samples
        while len(samples) < width:
            samples.append(0)
        samples = samples[:width]  # Trim to exact width
        
        # Normalize
        peak = max(abs(min(samples)), abs(max(samples)), 1e-10)  # Avoid division by zero
        norm = [int((s / peak) * (height // 2 - 2)) for s in samples]
        
        # Create and draw waveform
        pixmap = QPixmap(width, height)
        pixmap.fill(QColor('white'))
        
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setPen(color if color else QColor('deepskyblue'))
        
        mid = height // 2
        for x, y in enumerate(norm):
            if x < width:  # Safety check
                painter.drawLine(x, mid - abs(y), x, mid + abs(y))
        
        painter.end()
        return pixmap
        
    except ImportError as e:
        raise ThumbnailError(f"Failed to import Qt components: {e}")
    except Exception as e:
        raise ThumbnailError(f"Failed to render waveform: {e}")


def _save_thumbnail_to_cache(pixmap: 'QPixmap', thumb_path: Path, logger: logging.Logger) -> None:
    """Save thumbnail to disk cache with error handling"""
    try:
        saved = pixmap.save(str(thumb_path), 'PNG')
        if saved:
            logger.debug('Saved new thumbnail: %s', thumb_path)
        else:
            logger.warning('Failed to save thumbnail: %s', thumb_path)
    except Exception as e:
        logger.error('Exception while saving thumbnail to %s: %s', thumb_path, e)
    
    # Verify file was actually created
    if not thumb_path.exists():
        logger.error('Thumbnail file was not created after save: %s', thumb_path)
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QLabel, QListWidget, QPushButton, QHBoxLayout

# --- SMB Browser Tab for Samba GUI Access ---
class SmbBrowserTab(QWidget):
    """SMB/CIFS network browser widget for accessing shared network resources"""
    
    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.logger = setup_logger(f'{__name__}.SmbBrowserTab')
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Initialize the user interface"""
        try:
            layout = QVBoxLayout(self)
            
            # Status label
            self.status_label = QLabel("SMB Browser - Ready")
            layout.addWidget(self.status_label)
            
            # Server list
            self.server_list = QListWidget()
            layout.addWidget(self.server_list)
            
            # Button panel
            button_layout = QHBoxLayout()
            self.refresh_button = QPushButton("Refresh")
            self.connect_button = QPushButton("Connect")
            
            button_layout.addWidget(self.refresh_button)
            button_layout.addWidget(self.connect_button)
            layout.addLayout(button_layout)
            
        except Exception as e:
            self.logger.error(f"Failed to setup UI: {e}")
            raise NetworkError(f"SMB browser UI initialization failed: {e}")
    
    def apply_theme_dict(self, theme_dict: Dict[str, str]) -> None:
        """Apply a theme dictionary to the UI widgets using QSS stylesheets.
        
        Args:
            theme_dict: Dictionary containing theme color definitions
            
        Raises:
            ConfigurationError: If theme application fails
        """
        try:
            # Extract theme colors with safe defaults
            bg = theme_dict.get('background') or theme_dict.get('window_bg', '#ffffff')
            fg = theme_dict.get('foreground') or theme_dict.get('text', '#000000')
            accent = theme_dict.get('accent', '#0078d4')
            panel_bg = theme_dict.get('panel_bg', bg)
            selection_bg = theme_dict.get('selection_bg', accent)
            selection_text = theme_dict.get('selection_text', fg)
            border = theme_dict.get('border', accent)
            button_bg = theme_dict.get('button_bg', panel_bg)
            button_fg = theme_dict.get('button_fg', fg)
            label_fg = theme_dict.get('label_fg', fg)
            list_bg = theme_dict.get('list_bg', bg)
            list_fg = theme_dict.get('list_fg', fg)
            
            # Build comprehensive QSS stylesheet for SMB tab
            qss_style = f"""
            /* SMB Tab Container */
            QWidget {{
                background-color: {bg};
                color: {fg};
            }}
            
            /* Labels */
            QLabel {{
                color: {label_fg};
                background-color: transparent;
                padding: 2px;
            }}
            
            /* List Widget */
            QListWidget {{
                background-color: {list_bg};
                color: {list_fg};
                border: 1px solid {border};
                selection-background-color: {selection_bg};
                selection-color: {selection_text};
                border-radius: 3px;
                padding: 2px;
            }}
            
            /* Buttons */
            QPushButton {{
                background-color: {button_bg};
                color: {button_fg};
                border: 1px solid {border};
                padding: 6px 12px;
                border-radius: 3px;
                min-width: 60px;
            }}
            QPushButton:hover {{
                background-color: {accent};
                color: {selection_text};
            }}
            QPushButton:pressed {{
                background-color: {selection_bg};
            }}
            QPushButton:disabled {{
                background-color: #cccccc;
                color: #666666;
                border-color: #999999;
            }}
            """
            
            # Apply stylesheet with error handling
            self.setStyleSheet(qss_style)
            self.logger.debug("Successfully applied SMB browser theme")
            
        except KeyError as e:
            error_msg = f"Missing theme key: {e}"
            self.logger.error(error_msg)
            raise ConfigurationError(error_msg)
        except Exception as e:
            error_msg = f"Failed to apply theme to SMB browser: {e}"
            self.logger.error(error_msg)
            raise ConfigurationError(error_msg)
        
        # Show status message if method is available
        if hasattr(self, 'show_status_message'):
            self.show_status_message("QSS Theme applied to SMB tab.")

    def apply_windows98_qss_if_applicable(self, theme_name):
        """Automatically apply Windows 98 QSS stylesheet for Windows 98 themes."""
        import os
        
        # Check if this is a Windows 98 theme
        if not theme_name or 'windows 98' not in theme_name.lower():
            return
            
        # Map theme names to QSS files
        qss_mapping = {
            'windows 98': 'windows98_classic.qss',
            'windows 98 blue': 'windows98_blue.qss',
            'windows 98 green': 'windows98_green.qss',
            'windows 98 red': 'windows98_red.qss',
            'windows 98 purple': 'windows98_purple.qss',
            'windows 98 yellow': 'windows98_yellow.qss',
            'windows 98 orange': 'windows98_orange.qss',
            'windows 98 pink': 'windows98_pink.qss'
        }
        
        # Find matching QSS file
        qss_filename = qss_mapping.get(theme_name.lower())
        if not qss_filename:
            # Try partial matching for other Windows 98 variants
            for key, filename in qss_mapping.items():
                if key in theme_name.lower():
                    qss_filename = filename
                    break
        
        if qss_filename:
            qss_path = os.path.join(self.get_qss_directory(), qss_filename)
            if os.path.exists(qss_path):
                if GLOBAL_DEBUG_ENABLED:
                    print(f"[QSS] Loading {qss_filename}")
                self.load_qss_file(qss_path)
            else:
                if GLOBAL_DEBUG_ENABLED:
                    print(f"[QSS] File not found: {qss_filename}")

    """A tab for browsing an SMB (Samba) network share."""
    def __init__(self, server, share, username, password, domain='', start_path='/', parent=None):
        super().__init__(parent)
        self.smb = SMBNetworkUtils(server, share, username, password, domain)
        self.current_path = start_path
        self.layout = QVBoxLayout(self)
        self.path_label = QLabel()
        self.layout.addWidget(self.path_label)
        # Add download/upload buttons
        btn_layout = QHBoxLayout()
        from PyQt5.QtGui import QIcon
        self.download_btn = QPushButton(QIcon.fromTheme('download'), "⬇ Download")
        self.download_btn.setToolTip("Download the selected file from the share")
        self.download_btn.clicked.connect(self.download_selected_file)
        btn_layout.addWidget(self.download_btn)
        self.upload_btn = QPushButton(QIcon.fromTheme('upload'), "⬆ Upload")
        self.upload_btn.setToolTip("Upload a file to the current directory on the share")
        self.upload_btn.clicked.connect(self.upload_file)
        btn_layout.addWidget(self.upload_btn)
        btn_layout.addStretch()
        self.layout.addLayout(btn_layout)
        self.list_widget = QListWidget()
        self.list_widget.setToolTip("Double-click a folder to enter it, or a file to select it.")
        self.layout.addWidget(self.list_widget)
        self.list_widget.itemDoubleClicked.connect(self.on_item_double_clicked)
        self.refresh()

    def refresh(self):
        from PyQt5.QtCore import QThread, pyqtSignal, QObject
        from PyQt5.QtWidgets import QProgressDialog
        self.download_btn.setEnabled(False)
        self.upload_btn.setEnabled(False)
        progress = QProgressDialog("Loading directory...", None, 0, 0, self)
        progress.setWindowTitle("Please Wait")
        progress.setWindowModality(True)
        progress.setMinimumDuration(0)
        progress.show()
        class Worker(QObject):
            finished = pyqtSignal(list, str)
            def __init__(self, smb, path):
                super().__init__()
                self.smb = smb
                self.path = path
            def run(self):
                try:
                    entries = self.smb.listdir(self.path)
                    self.finished.emit(entries, None)
                except Exception as e:
                    self.finished.emit([], str(e))
        def on_finished(entries, error):
            from PyQt5.QtWidgets import QListWidgetItem
            from PyQt5.QtGui import QIcon
            import os
            progress.close()
            self.list_widget.clear()
            if error:
                from PyQt5.QtWidgets import QMessageBox
                QMessageBox.critical(self, "Directory Error", error)
                self.list_widget.addItem(f"[ERROR] {error}")
            else:
                # Supported audio extensions for waveform thumbnails
                audio_exts = ['.wav', '.flac', '.ogg', '.aiff', '.aif', '.aifc', '.au', '.snd', '.sf', '.caf', '.mp3', '.m4a']
                for entry in entries:
                    item = QListWidgetItem(entry)
                    # Set waveform icon for supported audio files and cache them
                    if any(entry.lower().endswith(ext) for ext in audio_exts):
                        try:
                            audio_path = os.path.join(self.current_path, entry)
                            if not hasattr(self, 'thumbnail_cache') or self.thumbnail_cache is None:
                                self.thumbnail_cache = dict()
                            def cache_get(key):
                                return self.thumbnail_cache.get(key)
                            def cache_put(key, value):
                                self.thumbnail_cache[key] = value
                            class SimpleCache:
                                def get(self, key):
                                    return cache_get(key)
                                def put(self, key, value):
                                    cache_put(key, value)
                            thumbnail_debug('Calling get_waveform_thumbnail for: {}', audio_path)
                            supported_audio_exts = ['.wav', '.flac', '.ogg', '.aiff', '.aif', '.aifc', '.au', '.snd', '.sf', '.caf', '.mp3', '.oga', '.aac', '.m4a', '.wma', '.opus', '.alac']
                            ext = os.path.splitext(audio_path)[1].lower()
                            if ext in supported_audio_exts:
                                pixmap = get_waveform_thumbnail(audio_path, width=48, height=48, thumbnail_cache=SimpleCache())
                            else:
                                thumbnail_debug('Skipping unsupported audio extension for thumbnail: {}', audio_path)
                            if pixmap is not None:
                                item.setIcon(QIcon(pixmap))
                            else:
                                # Show a warning icon or text if thumbnail failed
                                item.setToolTip("Could not generate waveform thumbnail. See log for details.")
                        except Exception as e:
                            item.setToolTip(f"Thumbnail error: {e}")
                    self.list_widget.addItem(item)
            self.path_label.setText(f"smb://{self.smb.server}/{self.smb.share}{self.current_path}")
            self.download_btn.setEnabled(True)
            self.upload_btn.setEnabled(True)
            thread.quit()
            thread.wait()
        thread = QThread()
        worker = Worker(self.smb, self.current_path)
        worker.moveToThread(thread)
        worker.finished.connect(on_finished)
        thread.started.connect(worker.run)
        thread.start()

    def on_item_double_clicked(self, item):
        import os, json
        name = item.text()
        if GLOBAL_DEBUG_ENABLED:
            print(f"[UI] Item clicked: {name}")
        if name.startswith("[ERROR]"):
            if GLOBAL_DEBUG_ENABLED:
                print("[UI] Skipping error item.")
            return
        # If it's a .gsfmt theme file, try to load it
        if name.endswith('.gsfmt'):
            if GLOBAL_DEBUG_ENABLED:
                print(f"[THEME] Loading: {name}")
            theme_path = os.path.join(self.current_path, name)
            # Try to call the main window's load_theme_file if available
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'load_theme_file'):
                main_window = main_window.parent() if hasattr(main_window, 'parent') else None
            if main_window and hasattr(main_window, 'load_theme_file'):
                if GLOBAL_DEBUG_ENABLED:
                    print(f"[THEME] Loading via main window")
                main_window.load_theme_file(theme_path)
            else:
                # Fallback: try to apply as before
                try:
                    if GLOBAL_DEBUG_ENABLED:
                        print(f"[THEME] Loading directly: {name}")
                    with open(theme_path, 'r', encoding='utf-8') as f:
                        theme_data = json.load(f)
                    if isinstance(theme_data, dict):
                        if 'theme_data' in theme_data:
                            theme_modes = theme_data['theme_data']
                        else:
                            theme_modes = theme_data
                        if isinstance(theme_modes, dict):
                            # Always force 'strong' mode if present
                            if 'strong' in theme_modes:
                                selected_mode = 'strong'
                            elif 'regular' in theme_modes:
                                selected_mode = 'regular'
                            else:
                                selected_mode = next(iter(theme_modes.keys()))
                            selected_theme = theme_modes[selected_mode]
                            # No message box; just apply the theme and refresh UI
                            if hasattr(self, 'apply_theme_dict'):
                                if GLOBAL_DEBUG_ENABLED:
                                    print(f"[THEME] Applied: {selected_mode}")
                                self.apply_theme_dict(selected_theme)
                                # Force UI refresh if available
                                if hasattr(self, 'refresh_all_themes'):
                                    self.refresh_all_themes()
                                if hasattr(self, 'refresh'):
                                    self.refresh()
                            return
                except Exception as e:
                    pass  # Reduced verbosity - no debug output for theme errors
            return
        # If it's a .qss stylesheet file, try to load it
        if name.endswith('.qss'):
            if GLOBAL_DEBUG_ENABLED:
                print(f"[QSS] Loading: {name}")
            qss_path = os.path.join(self.current_path, name)
            # Try to call the main window's load_qss_file if available
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'load_qss_file'):
                main_window = main_window.parent() if hasattr(main_window, 'parent') else None
            if main_window and hasattr(main_window, 'load_qss_file'):
                main_window.load_qss_file(qss_path)
            return
        # Try to enter directory
        new_path = self.current_path.rstrip("/") + "/" + name
        try:
            entries = self.smb.listdir(new_path)
            self.current_path = new_path
            self.refresh()
        except Exception:
            pass  # Not a directory or error

    def download_selected_file(self):
        from PyQt5.QtWidgets import QFileDialog, QMessageBox, QProgressDialog
        from PyQt5.QtCore import QThread, pyqtSignal, QObject
        items = self.list_widget.selectedItems()
        if not items:
            QMessageBox.warning(self, "No Selection", "Select a file to download.")
            return
        name = items[0].text()
        remote_path = self.current_path.rstrip("/") + "/" + name
        save_path, _ = QFileDialog.getSaveFileName(self, "Save File As", name)
        if not save_path:
            return
        import os
        if os.path.exists(save_path):
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("File Exists")
            msg_box.setText(f"{save_path} exists. What do you want to do?")
            overwrite_btn = msg_box.addButton("Overwrite", QMessageBox.YesRole)
            rename_btn = msg_box.addButton("Rename", QMessageBox.ActionRole)
            skip_btn = msg_box.addButton("Skip", QMessageBox.RejectRole)
            msg_box.setIcon(QMessageBox.Question)
            msg_box.exec_()
            clicked = msg_box.clickedButton()
            if clicked == skip_btn:
                return
            elif clicked == rename_btn:
                from PyQt5.QtWidgets import QInputDialog
                base, ext = os.path.splitext(save_path)
                new_name, ok = QInputDialog.getText(self, "Rename File", "Enter new file name:", text=os.path.basename(save_path))
                if not ok or not new_name:
                    return
                save_path = os.path.join(os.path.dirname(save_path), new_name)
                if os.path.exists(save_path):
                    QMessageBox.warning(self, "File Exists", f"{save_path} already exists. Please choose a different name.")
                    return
        self.download_btn.setEnabled(False)
        self.upload_btn.setEnabled(False)
        progress = QProgressDialog("Downloading file...", None, 0, 0, self)
        progress.setWindowTitle("Please Wait")
        progress.setWindowModality(True)
        progress.setMinimumDuration(0)
        progress.show()
        class Worker(QObject):
            finished = pyqtSignal(bytes, str)
            def __init__(self, smb, remote_path):
                super().__init__()
                self.smb = smb
                self.remote_path = remote_path
            def run(self):
                try:
                    data = self.smb.read_file(self.remote_path)
                    self.finished.emit(data, None)
                except Exception as e:
                    self.finished.emit(None, str(e))
        def on_finished(data, error):
            progress.close()
            self.download_btn.setEnabled(True)
            self.upload_btn.setEnabled(True)
            if error:
                QMessageBox.critical(self, "Download Failed", str(error))
            else:
                try:
                    with open(save_path, "wb") as f:
                        f.write(data)
                    QMessageBox.information(self, "Download Complete", f"Downloaded to {save_path}")
                except Exception as e:
                    QMessageBox.critical(self, "Download Failed", str(e))
            thread.quit()
            thread.wait()
        thread = QThread()
        worker = Worker(self.smb, remote_path)
        worker.moveToThread(thread)
        worker.finished.connect(on_finished)
        thread.started.connect(worker.run)
        thread.start()

    def upload_file(self):
        from PyQt5.QtWidgets import QFileDialog, QMessageBox, QProgressDialog
        from PyQt5.QtCore import QThread, pyqtSignal, QObject
        import os
        file_path, _ = QFileDialog.getOpenFileName(self, "Select File to Upload")
        if not file_path:
            return
        name = os.path.basename(file_path)
        remote_path = self.current_path.rstrip("/") + "/" + name
        # Confirm overwrite if file exists on SMB share (best effort: check listdir)
        try:
            existing = self.smb.listdir(self.current_path)
            if name in existing:
                msg_box = QMessageBox(self)
                msg_box.setWindowTitle("File Exists")
                msg_box.setText(f"{name} exists on the share. What do you want to do?")
                overwrite_btn = msg_box.addButton("Overwrite", QMessageBox.YesRole)
                rename_btn = msg_box.addButton("Rename", QMessageBox.ActionRole)
                skip_btn = msg_box.addButton("Skip", QMessageBox.RejectRole)
                msg_box.setIcon(QMessageBox.Question)
                msg_box.exec_()
                clicked = msg_box.clickedButton()
                if clicked == skip_btn:
                    return
                elif clicked == rename_btn:
                    from PyQt5.QtWidgets import QInputDialog
                    base, ext = os.path.splitext(name)
                    new_name, ok = QInputDialog.getText(self, "Rename File", "Enter new file name:", text=name)
                    if not ok or not new_name:
                        return
                    name = new_name
                    remote_path = self.current_path.rstrip("/") + "/" + name
                    if name in existing:
                        QMessageBox.warning(self, "File Exists", f"{name} already exists on the share. Please choose a different name.")
                        return
        except Exception:
            pass
        self.download_btn.setEnabled(False)
        self.upload_btn.setEnabled(False)
        progress = QProgressDialog("Uploading file...", None, 0, 0, self)
        progress.setWindowTitle("Please Wait")
        progress.setWindowModality(True)
        progress.setMinimumDuration(0)
        progress.show()
        class Worker(QObject):
            finished = pyqtSignal(str)
            def __init__(self, smb, remote_path, file_path):
                super().__init__()
                self.smb = smb
                self.remote_path = remote_path
                self.file_path = file_path
            def run(self):
                try:
                    with open(self.file_path, "rb") as f:
                        data = f.read()
                    self.smb.write_file(self.remote_path, data)
                    self.finished.emit(None)
                except Exception as e:
                    self.finished.emit(str(e))
        def on_finished(error):
            progress.close()
            self.download_btn.setEnabled(True)
            self.upload_btn.setEnabled(True)
            if error:
                QMessageBox.critical(self, "Upload Failed", str(error))
            else:
                QMessageBox.information(self, "Upload Complete", f"Uploaded {name}")
                self.refresh()
            thread.quit()
            thread.wait()
        thread = QThread()
        worker = Worker(self.smb, remote_path, file_path)
        worker.moveToThread(thread)
        worker.finished.connect(on_finished)
        thread.started.connect(worker.run)
        thread.start()

import os
import uuid
import sys
if sys.platform.startswith('linux'):
    try:
        from smb.SMBConnection import SMBConnection
        HAVE_PYSMB = True
    except ImportError:
        HAVE_PYSMB = False
        import subprocess
else:
    import smbprotocol
    from smbprotocol.connection import Connection
    from smbprotocol.session import Session
    from smbprotocol.tree import TreeConnect
    from smbprotocol.open import Open, CreateDisposition, FileAttributes, CreateOptions, FilePipePrinterAccessMask
    from smbprotocol.file_info import FileAttributes as SMBFileAttributes

class SMBNetworkUtils:
    """
    Utility class for SMB (Samba) network folder operations using smbprotocol.
    Supports listing, reading, writing, and copying files/folders on SMB shares.
    """
    def __init__(self, server, share, username, password, domain='', port=445):
        self.server = server
        self.share = share
        self.username = username
        self.password = password
        self.domain = domain
        self.port = port
        self.conn = None
        self.session = None
        self.tree = None
        self.smbc = None
        if sys.platform.startswith('linux'):
            if HAVE_PYSMB:
                self._connect_linux_pysmb()
            else:
                self._connect_linux_smbclient()
        else:
            self._connect_win()

    def _connect_linux_pysmb(self):
        # Use pysmb's SMBConnection
        self.smbc = SMBConnection(self.username, self.password, 'garysfm', self.server, domain=self.domain, use_ntlm_v2=True)
        assert self.smbc.connect(self.server, self.port), "Failed to connect to SMB server via pysmb"

    def _connect_linux_smbclient(self):
        # No persistent connection needed for smbclient subprocess
        self.smbc = None

    def _connect_win(self):
        smbprotocol.ClientConfig(username=self.username, password=self.password, domain=self.domain)
        self.conn = Connection(uuid.uuid4(), self.server, port=self.port)
        self.conn.connect()
        self.session = Session(self.conn, self.username, self.password, self.domain)
        self.session.connect()
        self.tree = TreeConnect(self.session, f"//{self.server}/{self.share}")
        self.tree.connect()

    def listdir(self, path):
        """List files and folders in a directory on the SMB share."""
        if sys.platform.startswith('linux'):
            path = path.lstrip('/')
            if HAVE_PYSMB:
                files = self.smbc.listPath(self.share, path)
                return [f.filename for f in files if f.filename not in ('.', '..')]
            else:
                # Use smbclient subprocess
                # Use a temporary credentials file to avoid exposing the password
                # on the process command line. smbclient supports -A <credsfile>.
                import tempfile, stat
                creds_path = None
                try:
                    with tempfile.NamedTemporaryFile(delete=False, mode='w', encoding='utf-8') as cf:
                        creds_path = cf.name
                        cf.write(f"username = {self.username}\npassword = {self.password}\n")
                    # Restrict permissions to owner only where possible
                    try:
                        os.chmod(creds_path, stat.S_IRUSR | stat.S_IWUSR)
                    except Exception:
                        pass
                    cmd = [
                        'smbclient',
                        f'//{self.server}/{self.share}',
                        '-A', creds_path,
                        '-c', f'ls {path or "."}'
                    ]
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    if result.returncode != 0:
                        raise RuntimeError(f'smbclient failed: {result.stderr}')
                    lines = result.stdout.splitlines()
                    # Parse output: skip lines that are not file/dir entries
                    entries = []
                    for line in lines:
                        parts = line.split()
                        if parts and not line.startswith('Domain=') and not line.startswith('smb:'):
                            entries.append(parts[0])
                    return [e for e in entries if e not in ('.', '..')]
                finally:
                    try:
                        if creds_path and os.path.exists(creds_path):
                            os.remove(creds_path)
                    except Exception:
                        pass
        else:
            dir_handle = Open(tree=self.tree, file_name=path, desired_access=FilePipePrinterAccessMask.FILE_LIST_DIRECTORY,
                             share_access=1, create_disposition=CreateDisposition.FILE_OPEN, create_options=CreateOptions.FILE_DIRECTORY_FILE)
            dir_handle.create()
            entries = dir_handle.query_directory()
            dir_handle.close()
            return [entry['file_name'] for entry in entries if entry['file_name'] not in ('.', '..')]

    def read_file(self, path):
        """Read the contents of a file from the SMB share."""
        if sys.platform.startswith('linux'):
            path = path.lstrip('/')
            if HAVE_PYSMB:
                from io import BytesIO
                file_obj = BytesIO()
                self.smbc.retrieveFile(self.share, path, file_obj)
                return file_obj.getvalue()
            else:
                # Use smbclient subprocess to get file
                import tempfile
                tmp_path = None
                try:
                    with tempfile.NamedTemporaryFile(delete=False) as tmp:
                        tmp_path = tmp.name
                    # Use temporary creds file to avoid showing password in process list
                    import tempfile, stat
                    creds_path = None
                    try:
                        with tempfile.NamedTemporaryFile(delete=False, mode='w', encoding='utf-8') as cf:
                            creds_path = cf.name
                            cf.write(f"username = {self.username}\npassword = {self.password}\n")
                        try:
                            os.chmod(creds_path, stat.S_IRUSR | stat.S_IWUSR)
                        except Exception:
                            pass
                        cmd = [
                            'smbclient',
                            f'//{self.server}/{self.share}',
                            '-A', creds_path,
                            '-c', f'get {path} {tmp_path}'
                        ]
                        result = subprocess.run(cmd, capture_output=True, text=True)
                    finally:
                        try:
                            if 'creds_path' in locals() and creds_path and os.path.exists(creds_path):
                                os.remove(creds_path)
                        except Exception:
                            pass
                    if result.returncode != 0:
                        raise RuntimeError(f'smbclient get failed: {result.stderr}')
                    with open(tmp_path, 'rb') as f:
                        data = f.read()
                    return data
                finally:
                    try:
                        if tmp_path and os.path.exists(tmp_path):
                            os.remove(tmp_path)
                    except Exception:
                        pass
        else:
            file_handle = Open(tree=self.tree, file_name=path, desired_access=FilePipePrinterAccessMask.FILE_READ_DATA,
                              share_access=1, create_disposition=CreateDisposition.FILE_OPEN)
            file_handle.create()
            data = file_handle.read(0, file_handle.query_info()['end_of_file'])
            file_handle.close()
            return data

    def write_file(self, path, data):
        """Write data to a file on the SMB share (overwrites if exists)."""
        if sys.platform.startswith('linux'):
            path = path.lstrip('/')
            if HAVE_PYSMB:
                from io import BytesIO
                file_obj = BytesIO(data)
                self.smbc.storeFile(self.share, path, file_obj)
            else:
                # Use smbclient subprocess to put file
                import tempfile
                tmp_path = None
                try:
                    with tempfile.NamedTemporaryFile(delete=False) as tmp:
                        tmp.write(data)
                        tmp_path = tmp.name
                    # Use temporary creds file to avoid exposing password
                    import tempfile, stat
                    creds_path = None
                    try:
                        with tempfile.NamedTemporaryFile(delete=False, mode='w', encoding='utf-8') as cf:
                            creds_path = cf.name
                            cf.write(f"username = {self.username}\npassword = {self.password}\n")
                        try:
                            os.chmod(creds_path, stat.S_IRUSR | stat.S_IWUSR)
                        except Exception:
                            pass
                        cmd = [
                            'smbclient',
                            f'//{self.server}/{self.share}',
                            '-A', creds_path,
                            '-c', f'put {tmp_path} {path}'
                        ]
                        result = subprocess.run(cmd, capture_output=True, text=True)
                    finally:
                        try:
                            if 'creds_path' in locals() and creds_path and os.path.exists(creds_path):
                                os.remove(creds_path)
                        except Exception:
                            pass
                    if result.returncode != 0:
                        raise RuntimeError(f'smbclient put failed: {result.stderr}')
                finally:
                    try:
                        if tmp_path and os.path.exists(tmp_path):
                            os.remove(tmp_path)
                    except Exception:
                        pass
        else:
            file_handle = Open(tree=self.tree, file_name=path, desired_access=FilePipePrinterAccessMask.FILE_WRITE_DATA,
                              share_access=1, create_disposition=CreateDisposition.FILE_OVERWRITE_IF)
            file_handle.create()
            file_handle.write(0, data)
            file_handle.close()

    def copy_file_to_share(self, local_path, remote_path):
        """Copy a local file to the SMB share."""
        with open(local_path, 'rb') as f:
            data = f.read()
        self.write_file(remote_path, data)

    def copy_file_from_share(self, remote_path, local_path):
        """Copy a file from the SMB share to local disk."""
        data = self.read_file(remote_path)
        with open(local_path, 'wb') as f:
            f.write(data)

    def close(self):
        if sys.platform.startswith('linux'):
            if HAVE_PYSMB and self.smbc:
                self.smbc.close()
        else:
            if self.tree:
                self.tree.disconnect()
            if self.session:
                self.session.disconnect()
            if self.conn:
                self.conn.disconnect()

# Example usage (replace with your actual credentials and share):
# smb = SMBNetworkUtils(server='192.168.1.100', share='shared', username='user', password='pass')
# print(smb.listdir("/"))
# smb.copy_file_to_share('local.txt', '/remote.txt')
# smb.copy_file_from_share('/remote.txt', 'downloaded.txt')
# smb.close()
from PyQt5.QtWidgets import QDialog, QLineEdit, QFormLayout, QDialogButtonBox, QFileDialog, QMessageBox, QPushButton
import re
import ftplib
import paramiko
import shutil
import sys

# --- Robust FFmpeg presence check for macOS ---
def find_ffmpeg():
    """
    Try to find ffmpeg in PATH, common Homebrew locations, or via FFMPEG_PATH env var.
    Returns the path to ffmpeg or None if not found.
    """
    ffmpeg_env = os.environ.get('FFMPEG_PATH')
    if ffmpeg_env and os.path.isfile(ffmpeg_env) and os.access(ffmpeg_env, os.X_OK):
        return ffmpeg_env
    ffmpeg_path = shutil.which('ffmpeg')
    if ffmpeg_path:
        return ffmpeg_path
    # Check common Homebrew locations
    brew_paths = [
        '/opt/homebrew/bin/ffmpeg',        # Apple Silicon
        '/usr/local/bin/ffmpeg',           # Intel
        '/Applications/ffmpeg/ffmpeg',     # gary's
    ]
    for path in brew_paths:
        if os.path.isfile(path) and os.access(path, os.X_OK):
            return path
    return None

# Global lazy thumbnail cache accessor
_GLOBAL_THUMBNAIL_CACHE = None
def get_global_thumbnail_cache():
    global _GLOBAL_THUMBNAIL_CACHE
    if _GLOBAL_THUMBNAIL_CACHE is None:
        try:
            _GLOBAL_THUMBNAIL_CACHE = ThumbnailCache()
        except Exception:
            _GLOBAL_THUMBNAIL_CACHE = None
    return _GLOBAL_THUMBNAIL_CACHE

if sys.platform == 'darwin':
    ffmpeg_path = find_ffmpeg()
    if not ffmpeg_path:
        print("[ERROR] FFmpeg not found in PATH or common locations. Please install FFmpeg (e.g., via Homebrew: 'brew install ffmpeg') and try again.")
        print("[ERROR] You can also set the FFMPEG_PATH environment variable to the full path of ffmpeg.")
        sys.exit(1)
from PyQt5.QtGui import QPixmap, QIcon, QPainter, QPen, QKeySequence, QFont, QTextDocument, QSyntaxHighlighter, QTextCharFormat, QStandardItemModel, QStandardItem, QColor, QDesktopServices, QMovie, QTextOption, QBrush, QTextCursor, QTransform

# --- EXE Icon Extraction for PyQt ---
def get_exe_icon_qicon(exe_path, size=32):
    """
    Extracts the icon from an EXE file and returns a QIcon.
    Requires pywin32 and PyQt5.
    """
    import sys
    from PyQt5.QtGui import QPixmap, QIcon
    if sys.platform.startswith('win'):
        try:
            import win32api
            import win32con
            import win32ui
            import win32gui
            from PyQt5.QtGui import QImage
            large, small = win32gui.ExtractIconEx(exe_path, 0)
            if not large and not small:
                return QIcon()
            hicon = large[0] if large else small[0]
            hdc = win32ui.CreateDCFromHandle(win32gui.GetDC(0))
            hbmp = win32ui.CreateBitmap()
            hbmp.CreateCompatibleBitmap(hdc, size, size)
            hdc_mem = hdc.CreateCompatibleDC()
            hdc_mem.SelectObject(hbmp)
            win32gui.DrawIconEx(hdc_mem.GetSafeHdc(), 0, 0, hicon, size, size, 0, None, win32con.DI_NORMAL)
            bmpinfo = hbmp.GetInfo()
            bmpstr = hbmp.GetBitmapBits(True)
            image = QImage(bmpstr, bmpinfo['bmWidth'], bmpinfo['bmHeight'], QImage.Format_ARGB32)
            pixmap = QPixmap.fromImage(image)
            win32gui.DestroyIcon(hicon)
            return QIcon(pixmap)
        except Exception as e:
            print(f"[EXE-ICON] Failed to extract icon from {exe_path}: {e}")
            return QIcon()
    else:
        # On macOS/Linux, show a generic EXE icon or fallback to a PNG if available
        import os
        fallback_icon_path = os.path.join(os.path.dirname(__file__), 'icon.png')
        if os.path.isfile(fallback_icon_path):
            return QIcon(QPixmap(fallback_icon_path).scaled(size, size))
    # Draw a simple generic icon (no blue squares/rect for drives)
    pixmap = QPixmap(size, size)
    pixmap.fill()
    from PyQt5.QtGui import QPainter, QColor
    painter = QPainter(pixmap)
    painter.setPen(QColor('black'))
    # Only draw the rectangle and text for non-drive files
    # (Drives should not show the blue squares/rect)
    # Optionally, you can check for 'exe_path' being a drive letter here and skip drawing
    painter.drawText(8, size//2, 'EXE')
    painter.end()
    return QIcon(pixmap)
def precache_text_pdf_thumbnails_in_directory(directory, thumbnail_cache, size=128, max_workers=4, on_complete=None, parent=None, show_progress=False):
    """
    Pre-cache thumbnails for text and PDF files in a directory in the background.
    Args:
        directory (str): Path to the directory to scan for files.
        thumbnail_cache (ThumbnailCache): The thumbnail cache instance to use.
        size (int): Thumbnail size in pixels (default 128).
        max_workers (int): Number of threads for parallel extraction.
    """
    import glob
    import concurrent.futures
    text_exts = ('.txt', '.md', '.log', '.ini', '.csv', '.json', '.xml', '.py', '.c', '.cpp', '.h', '.java', '.js', '.html', '.css', '.qss', '.gsfmt', 'LICENSE')
    pdf_exts = ('.pdf',)
    docx_exts = ('.docx', '.doc')
    audio_exts = ('.wav', '.mp3', '.flac', '.ogg', '.oga', '.aac', '.m4a', '.wma', '.opus', '.aiff', '.alac')
    image_exts = ('.jpg', '.jpeg', '.png', '.bmp', '.gif', '.tiff', '.webp', '.ico')
    thumbnail_info("Called for directory={} size={}", directory, size)
    files = [f for f in glob.glob(os.path.join(directory, '*')) if (os.path.splitext(f)[1].lower() in text_exts + pdf_exts + docx_exts + audio_exts + image_exts) or (os.path.basename(f).upper() in ['LICENSE', 'LICENCE', 'COPYRIGHT', 'COPYING'])]
    thumbnail_info("Found {} files to process", len(files))
    # Optional progress dialog and cooperative cancellation
    stop_event = None
    progress_dialog = None
    # Precompute which files actually need caching so we only show the dialog when there's work to do
    files_to_cache = []
    try:
        for f in files:
            try:
                if not thumbnail_cache.is_cached(f, size):
                    files_to_cache.append(f)
            except Exception:
                files_to_cache.append(f)
    except Exception:
        # Fallback: assume all files may need caching
        files_to_cache = list(files)
    thumbnail_info("Files needing caching: {}", len(files_to_cache))
    # Consult user preference for caching dialog: 'always_show', 'ask', 'always_hide'
    try:
        settings = QSettings("garysfm", "garysfm")
        cache_dialog_pref = settings.value('cache_dialog_pref', 'ask')
    except Exception:
        cache_dialog_pref = 'ask'

    should_show_dialog = False
    if cache_dialog_pref == 'always_show':
        should_show_dialog = True
    elif cache_dialog_pref == 'ask':
        should_show_dialog = bool(show_progress) and bool(files_to_cache)
    elif cache_dialog_pref == 'always_hide':
        should_show_dialog = False
    else:
        should_show_dialog = bool(show_progress) and bool(files_to_cache)

    if should_show_dialog and files_to_cache:
        try:
            from PyQt5.QtWidgets import QProgressDialog, QApplication
            import threading
            stop_event = threading.Event()
            parent_win = parent
            if parent_win is None:
                parent_win = QApplication.instance().activeWindow() if QApplication.instance() else None
            progress_dialog = QProgressDialog('Caching thumbnails...', 'Cancel', 0, len(files_to_cache), parent_win)
            progress_dialog.setWindowTitle('Thumbnail caching')
            progress_dialog.setWindowModality(0)  # Non-modal by default; parent controls modality
            progress_dialog.setMinimumDuration(200)
            # When cancelled, set the stop event
            try:
                progress_dialog.canceled.connect(lambda: stop_event.set())
            except Exception:
                pass
            progress_dialog.show()
        except Exception:
            progress_dialog = None
            stop_event = None
    def cache_one_file(file_path):
        ext = os.path.splitext(file_path)[1].lower()
        # Skip thumbnail cache files themselves
        try:
            if is_thumb_file(file_path):
                thumbnail_debug("Skipping .thumb cache file: {}", file_path)
                return
        except Exception:
            pass
        # Check cooperative cancellation
        try:
            if stop_event is not None and stop_event.is_set():
                return
        except Exception:
            pass
        thumbnail_debug("Processing {} (ext={})", file_path, ext)
        if thumbnail_cache.get(file_path, size) is not None:
            thumbnail_debug("Already cached: {}", file_path)
            return
        try:
            from PIL import Image, ImageDraw, ImageFont
            import io
            filename = os.path.basename(file_path).upper()
            if ext in text_exts or filename in ['LICENSE', 'LICENCE', 'COPYRIGHT', 'COPYING']:
                thumbnail_debug("Generating text thumbnail for {}", file_path)
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    lines = []
                    for _ in range(8):
                        try:
                            lines.append(next(f).rstrip())
                        except StopIteration:
                            break
                text = '\n'.join(lines)
                img = Image.new('RGBA', (size, size), (255, 255, 255, 255))
                draw = ImageDraw.Draw(img)
                try:
                    font = ImageFont.truetype('arial.ttf', 12)
                except Exception:
                    font = ImageFont.load_default()
                try:
                    text_bbox = draw.multiline_textbbox((0, 0), text, font=font)
                    text_width = text_bbox[2] - text_bbox[0]
                    text_height = text_bbox[3] - text_bbox[1]
                except AttributeError:
                    text_width, text_height = draw.textsize(text, font=font)
                x = (size - text_width) // 2 if text_width < size else 4
                y = (size - text_height) // 2 if text_height < size else 4
                draw.multiline_text((x, y), text, fill=(0, 0, 0), font=font)
                img = img.resize((size, size), Image.LANCZOS)
                buf = io.BytesIO()
                img.save(buf, format='PNG')
                png_bytes = buf.getvalue()
                thumbnail_debug("About to cache text thumbnail for {}, {} bytes", file_path, len(png_bytes))
                thumbnail_cache.put(file_path, size, png_bytes)
                thumbnail_debug("Cached text thumbnail for {}", file_path)
            elif ext in pdf_exts:
                thumbnail_debug("Generating PDF thumbnail for {}", file_path)
                import fitz  # PyMuPDF
                doc = fitz.open(file_path)
                if doc.page_count > 0:
                    page = doc.load_page(0)
                    zoom = max(size / 72, 2)
                    mat = fitz.Matrix(zoom, zoom)
                    pix = page.get_pixmap(matrix=mat)
                    img = Image.frombytes('RGB', [pix.width, pix.height], pix.samples)
                    img = img.resize((size, size), Image.LANCZOS)
                    buf = io.BytesIO()
                    img.save(buf, format='PNG')
                    png_bytes = buf.getvalue()
                    thumbnail_debug("About to cache PDF thumbnail for {}, {} bytes", file_path, len(png_bytes))
                    thumbnail_cache.put(file_path, size, png_bytes)
                    thumbnail_debug("Cached PDF thumbnail for {}", file_path)
            elif ext in ['.wav', '.flac', '.ogg', '.aiff', '.aif', '.aifc', '.au', '.snd', '.sf', '.caf', '.mp3', '.oga', '.aac', '.m4a', '.wma', '.opus', '.alac']:
                thumbnail_debug("Generating waveform thumbnail for {}", file_path)
                try:
                    thumbnail_debug("Calling get_waveform_thumbnail for: {}", file_path)
                    # Use the thumbnail_cache passed into this function (module-level), not a `self` reference
                    pixmap = get_waveform_thumbnail(file_path, width=size, height=size, thumbnail_cache=thumbnail_cache)
                    # Save QPixmap to PNG bytes
                    from PyQt5.QtCore import QBuffer, QByteArray
                    buffer = QBuffer()
                    buffer.open(QBuffer.ReadWrite)
                    pixmap.save(buffer, 'PNG')
                    png_bytes = buffer.data().data()
                    thumbnail_debug("About to cache waveform thumbnail for {}, {} bytes", file_path, len(png_bytes))
                    thumbnail_cache.put(file_path, size, png_bytes)
                    thumbnail_debug("Cached waveform thumbnail for {}", file_path)
                except Exception as e:
                    thumbnail_error("Failed to generate waveform for {}: {}", file_path, e)
            elif ext in image_exts:
                thumbnail_debug("Generating image thumbnail for {}", file_path)
                img = Image.open(file_path)
                img = img.convert('RGBA')
                img = img.resize((size, size), Image.LANCZOS)
                buf = io.BytesIO()
                img.save(buf, format='PNG')
                png_bytes = buf.getvalue()
                thumbnail_debug("About to cache image thumbnail for {}, {} bytes", file_path, len(png_bytes))
                thumbnail_cache.put(file_path, size, png_bytes)
                thumbnail_debug("Cached image thumbnail for {}", file_path)
        except Exception as e:
            thumbnail_error("Failed for {}: {}", file_path, e)
    thumbnail_info("Starting cache thread pool for {} files (will process {})", len(files), len(files_to_cache))
    import concurrent.futures
    from concurrent.futures import as_completed
    executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)
    futures = [executor.submit(cache_one_file, file_path) for file_path in files_to_cache]
    completed = 0
    try:
        for future in as_completed(futures):
            # If user requested cancellation, break early
            try:
                if stop_event is not None and stop_event.is_set():
                    break
            except Exception:
                pass
            try:
                future.result()
            except Exception:
                # ignore per-file exceptions; they are logged inside cache_one_file
                pass
            completed += 1
            if progress_dialog is not None:
                try:
                    progress_dialog.setValue(completed)
                    # process UI events so dialog updates promptly
                    from PyQt5.QtWidgets import QApplication
                    QApplication.processEvents()
                except Exception:
                    pass
    finally:
        try:
            executor.shutdown(wait=False)
        except Exception:
            pass
        if progress_dialog is not None:
            try:
                progress_dialog.close()
            except Exception:
                pass
        if on_complete:
            try:
                on_complete()
            except Exception:
                pass
def clear_text_pdf_docx_thumbnails(directory, thumbnail_cache, size=128):
    """Delete cached thumbnails for text/pdf/docx files at the given size in the directory."""
    import glob
    text_exts = ('.txt', '.md', '.log', '.ini', '.csv', '.json', '.xml', '.py', '.c', '.cpp', '.h', '.java', '.js', '.html', '.css', '.qss', '.gsfmt', 'LICENSE')
    pdf_exts = ('.pdf',)
    docx_exts = ('.docx', '.doc')
    audio_exts = ('.wav', '.mp3', '.flac', '.ogg', '.oga', '.aac', '.m4a', '.wma', '.opus', '.aiff', '.alac')
    image_exts = ('.jpg', '.jpeg', '.png', '.bmp', '.gif', '.tiff', '.webp', '.ico')
    files = [f for f in glob.glob(os.path.join(directory, '*')) if (os.path.splitext(f)[1].lower() in text_exts + pdf_exts + docx_exts + audio_exts + image_exts) or (os.path.basename(f).upper() in ['LICENSE', 'LICENCE', 'COPYRIGHT', 'COPYING'])]
    for file_path in files:
        cache_key = thumbnail_cache.get_cache_key(file_path, size)
        cache_file = os.path.join(thumbnail_cache.cache_dir, f"{cache_key}.thumb")
        if os.path.exists(cache_file):
            try:
                os.remove(cache_file)
                thumbnail_info("Removed {}", cache_file)
            except Exception as e:
                thumbnail_error("Failed to remove {}: {}", cache_file, e)
        if thumbnail_cache.get(file_path, size) is not None:
            return  # Already cached
        ext = os.path.splitext(file_path)[1].lower()
        try:
            from PIL import Image, ImageDraw, ImageFont
            import io
            filename = os.path.basename(file_path).upper()
            if ext in text_exts or filename in ['LICENSE', 'LICENCE', 'COPYRIGHT', 'COPYING']:
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        lines = []
                        for _ in range(8):
                            try:
                                lines.append(next(f).rstrip())
                            except StopIteration:
                                break
                    text = '\n'.join(lines)
                    img = Image.new('RGBA', (size, size), (255, 255, 255, 255))
                    draw = ImageDraw.Draw(img)
                    try:
                        font = ImageFont.truetype('arial.ttf', 12)
                    except Exception:
                        font = ImageFont.load_default()
                    try:
                        text_bbox = draw.multiline_textbbox((0, 0), text, font=font)
                        text_width = text_bbox[2] - text_bbox[0]
                        text_height = text_bbox[3] - text_bbox[1]
                    except AttributeError:
                        text_width, text_height = draw.textsize(text, font=font)
                    x = (size - text_width) // 2 if text_width < size else 4
                    y = (size - text_height) // 2 if text_height < size else 4
                    draw.multiline_text((x, y), text, fill=(0, 0, 0), font=font)
                    img = img.resize((size, size), Image.LANCZOS)
                    buf = io.BytesIO()
                    img.save(buf, format='PNG')
                    png_bytes = buf.getvalue()
                    thumbnail_cache.put(file_path, size, png_bytes)
                except Exception as e:
                    thumbnail_error("Text thumbnail failed for {}: {}", file_path, e)
            elif ext in pdf_exts:
                try:
                    import fitz  # PyMuPDF
                    doc = fitz.open(file_path)
                    if doc.page_count > 0:
                        page = doc.load_page(0)
                        zoom = max(size / 72, 2)
                        mat = fitz.Matrix(zoom, zoom)
                        pix = page.get_pixmap(matrix=mat)
                        img = Image.frombytes('RGB', [pix.width, pix.height], pix.samples)
                        img = img.resize((size, size), Image.LANCZOS)
                        buf = io.BytesIO()
                        img.save(buf, format='PNG')
                        png_bytes = buf.getvalue()
                        thumbnail_cache.put(file_path, size, png_bytes)
                except Exception as e:
                    thumbnail_error("PDF thumbnail failed for {}: {}", file_path, e)
            elif ext in docx_exts:
                try:
                    from PIL import ImageFont
                    img = Image.new('RGBA', (size, size), (255, 255, 255, 255))
                    draw = ImageDraw.Draw(img)
                    # Draw a simple DOCX icon: blue rectangle + file extension
                    rect_color = (40, 100, 200)
                    draw.rectangle([8, 8, size-8, size-8], fill=rect_color, outline=(0,0,0))
                    try:
                        font = ImageFont.truetype('arial.ttf', 28)
                    except Exception:
                        font = ImageFont.load_default()
                    text = 'DOCX' if ext == '.docx' else 'DOC'
                    try:
                        bbox = draw.textbbox((0, 0), text, font=font)
                        w = bbox[2] - bbox[0]
                        h = bbox[3] - bbox[1]
                    except AttributeError:
                        w, h = draw.textsize(text, font=font)
                    draw.text(((size-w)//2, (size-h)//2), text, fill=(255,255,255), font=font)
                    buf = io.BytesIO()
                    img.save(buf, format='PNG')
                    png_bytes = buf.getvalue()
                    thumbnail_cache.put(file_path, size, png_bytes)
                except Exception as e:
                    thumbnail_error("DOCX thumbnail failed for {}: {}", file_path, e)
            elif ext in audio_exts:
                # Use a generic audio icon (no waveform, no matplotlib)
                try:
                    from PIL import Image, ImageDraw, ImageFont
                    img = Image.new('RGB', (size, size), color='white')
                    draw = ImageDraw.Draw(img)
                    font = ImageFont.load_default()
                    draw.rectangle([16, 16, size-16, size-16], outline='green', width=4)
                    draw.text((size//4, size//2-10), "AUDIO", fill='green', font=font)
                    buf = io.BytesIO()
                    img.save(buf, format='PNG')
                    png_bytes = buf.getvalue()
                    thumbnail_cache.put(file_path, size, png_bytes)
                except Exception as e:
                    thumbnail_error("Audio thumbnail failed for {}: {}", file_path, e)
        except Exception:
            pass  # Ignore errors for individual files
    # Shutdown helper runs in background to wait briefly and then shutdown the executor created above.

import os
import shutil
import errno
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QPushButton, QLabel

# Utility: Generate a unique name with (copy) if file/folder exists
def get_nonconflicting_name(path):
    """
    If path exists, insert ' (copy)' before the extension (for files) or at the end (for folders).
    Returns a new path that does not exist.
    """
    if not os.path.exists(path):
        return path
    dir_name, base = os.path.split(path)
    # Check if path is a file or folder by checking if it has an extension and if it's a file on disk
    is_file = os.path.splitext(base)[1] != '' and (os.path.isfile(path) or not os.path.exists(path))
    if is_file:
        name, ext = os.path.splitext(base)
        new_base = f"{name} (copy){ext}"
        new_path = os.path.join(dir_name, new_base)
        count = 2
        while os.path.exists(new_path):
            new_base = f"{name} (copy {count}){ext}"
            new_path = os.path.join(dir_name, new_base)
            count += 1
    else:
        # Always append ' (copy)' to the very end of the folder name, regardless of dots
        new_base = f"{base} (copy)"
        new_path = os.path.join(dir_name, new_base)
        count = 2
        while os.path.exists(new_path):
            new_base = f"{base} (copy {count})"
            new_path = os.path.join(dir_name, new_base)
            count += 1
    return new_path


# Utility: fast move that prefers os.replace (atomic rename) and falls back to shutil.move
def fast_move(src, dest):
    """Move src to dest. Try os.replace first for same-filesystem atomic move.
    Returns the final destination path used.
    """
    import shutil, os, errno
    # Ensure destination directory exists
    dest_dir = os.path.dirname(dest)
    if dest_dir:
        os.makedirs(dest_dir, exist_ok=True)

    # Resolve name conflicts before attempting move
    final_dest = get_nonconflicting_name(dest)

    try:
        # If src is a directory, use shutil.move (os.replace does not support directories)
        if os.path.isdir(src):
            shutil.move(src, final_dest)
            print(f"[MOVE-DEBUG] shutil.move (dir): {src} -> {final_dest}")
            return final_dest
        else:
            os.replace(src, final_dest)
            print(f"[MOVE-DEBUG] fast os.replace: {src} -> {final_dest}")
            return final_dest
    except OSError as e:
        # EXDEV: can't move across filesystems; fall back to shutil.move which will copy+remove
        if getattr(e, 'errno', None) == errno.EXDEV:
            try:
                shutil.move(src, final_dest)
                print(f"[MOVE-DEBUG] fallback shutil.move (EXDEV): {src} -> {final_dest}")
                return final_dest
            except Exception as e2:
                print(f"[MOVE-ERROR] move failed: {e} / fallback failed: {e2}")
                raise
        else:
            print(f"[MOVE-ERROR] move failed: {e}")
            raise

# Top-level OpenWithDialog class
class OpenWithDialog(QDialog):
    def __init__(self, parent=None):
        import sys
        super().__init__(parent)
        self.setWindowTitle("Open with...")
        self.setMinimumWidth(400)
        layout = QVBoxLayout(self)
        self.label = QLabel("Select an application to open the file with:")
        layout.addWidget(self.label)
        self.app_list = QListWidget()
        # Platform-specific common apps
        if sys.platform.startswith('win'):
            self.common_apps = [
                ("Notepad", r"C:\\Windows\\System32\\notepad.exe"),
                ("WordPad", r"C:\\Program Files\\Windows NT\\Accessories\\wordpad.exe"),
                ("Paint", r"C:\\Windows\\System32\\mspaint.exe"),
                ("Photos", r"C:\\Program Files\\Windows Photo Viewer\\PhotoViewer.dll"),
                ("Choose another application...", None)
            ]
        elif sys.platform == 'darwin':
            self.common_apps = [
                ("TextEdit", "/Applications/TextEdit.app"),
                ("Preview", "/Applications/Preview.app"),
                ("Safari", "/Applications/Safari.app"),
                ("Choose another application...", None)
            ]
        else:
            self.common_apps = [
                ("gedit", "/usr/bin/gedit"),
                ("kate", "/usr/bin/kate"),
                ("xdg-open", "/usr/bin/xdg-open"),
                ("Choose another application...", None)
            ]
        for name, path in self.common_apps:
            if path and path.lower().endswith('.exe'):
                icon = get_exe_icon_qicon(path, size=24)
                from PyQt5.QtWidgets import QListWidgetItem
                item = QListWidgetItem(QIcon(icon), name)
                self.app_list.addItem(item)
            else:
                self.app_list.addItem(name)
        layout.addWidget(self.app_list)
        btn_layout = QHBoxLayout()
        self.ok_btn = QPushButton("OK")
        self.cancel_btn = QPushButton("Cancel")
        btn_layout.addWidget(self.ok_btn)
        btn_layout.addWidget(self.cancel_btn)
        layout.addLayout(btn_layout)
        self.ok_btn.clicked.connect(self.accept)
        self.cancel_btn.clicked.connect(self.reject)
        self.selected_app = None
        self.app_list.itemDoubleClicked.connect(lambda _: self.accept())
    def get_app_path(self):
        import sys
        idx = self.app_list.currentRow()
        if idx < 0:
            return None
        name, path = self.common_apps[idx]
        if path is not None:
            return path
        # If 'Choose another application...' is selected, show a non-native PyQt file dialog
        try:
            from PyQt5.QtWidgets import QFileDialog
            file_dialog = QFileDialog(self, "Select Application")
            file_dialog.setFileMode(QFileDialog.ExistingFile)
            # Platform-specific filter
            if sys.platform.startswith('win'):
                file_dialog.setNameFilter("Applications (*.exe);;All Files (*)")
            elif sys.platform == 'darwin':
                file_dialog.setNameFilter("Applications (*.app);;All Files (*)")
            else:
                file_dialog.setNameFilter("All Files (*)")
            file_dialog.setOption(QFileDialog.DontUseNativeDialog, True)
            if file_dialog.exec_() == QFileDialog.Accepted:
                selected_files = file_dialog.selectedFiles()
                if selected_files:
                    return selected_files[0]
        except Exception as e:
            import traceback
            print(f"[OPENWITH-DIALOG-ERROR] {e}\n{traceback.format_exc()}")
        return None
def precache_video_thumbnails_in_directory(directory, thumbnail_cache, size=128, max_workers=4, parent=None, show_progress=False):
    import sys
    import platform
    import shutil
    # Use robust ffmpeg finder for macOS
    if sys.platform == 'darwin':
        ffmpeg_path = find_ffmpeg()
        if not ffmpeg_path:
            print('[ERROR] ffmpeg not found in PATH or common locations. Please install ffmpeg and ensure it is available in your PATH.')
            print('[ERROR] On macOS, you may need to launch your app from a terminal to inherit PATH, or set PATH in your environment.')
            print('[ERROR] You can also set the FFMPEG_PATH environment variable to the full path of ffmpeg.')
            return
    else:
        ffmpeg_path = shutil.which('ffmpeg')
        if not ffmpeg_path:
            print('[ERROR] ffmpeg not found in PATH. Please install ffmpeg and ensure it is available in your PATH.')
            return
    """
    Pre-cache video thumbnails for all video files in a directory in the background.
    Args:
        directory (str): Path to the directory to scan for videos.
        thumbnail_cache (ThumbnailCache): The thumbnail cache instance to use.
        size (int): Thumbnail size in pixels (default 128).
        max_workers (int): Number of threads for parallel extraction.
    """
    import glob
    import concurrent.futures
    video_exts = ('.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v')
    video_files = [f for f in glob.glob(os.path.join(directory, '*')) if os.path.splitext(f)[1].lower() in video_exts]
    # Optional progress dialog and cooperative cancellation
    stop_event = None
    progress_dialog = None
    # Precompute which video files actually need caching so we only show the dialog when work is required
    files_to_cache = []
    try:
        for vf in video_files:
            try:
                if not thumbnail_cache.is_cached(vf, size):
                    files_to_cache.append(vf)
            except Exception:
                files_to_cache.append(vf)
    except Exception:
        files_to_cache = list(video_files)
    thumbnail_info("Found {} video files, to cache: {}", len(video_files), len(files_to_cache))
    # Consult user preference for caching dialog: 'always_show', 'ask', 'always_hide'
    try:
        settings = QSettings("garysfm", "garysfm")
        cache_dialog_pref = settings.value('cache_dialog_pref', 'ask')
    except Exception:
        cache_dialog_pref = 'ask'

    should_show_dialog = False
    if cache_dialog_pref == 'always_show':
        should_show_dialog = True
    elif cache_dialog_pref == 'ask':
        should_show_dialog = bool(show_progress) and bool(files_to_cache)
    elif cache_dialog_pref == 'always_hide':
        should_show_dialog = False
    else:
        should_show_dialog = bool(show_progress) and bool(files_to_cache)

    if should_show_dialog and files_to_cache:
        try:
            from PyQt5.QtWidgets import QProgressDialog, QApplication
            import threading
            stop_event = threading.Event()
            parent_win = parent
            if parent_win is None:
                parent_win = QApplication.instance().activeWindow() if QApplication.instance() else None
            progress_dialog = QProgressDialog('Caching video thumbnails...', 'Cancel', 0, len(files_to_cache), parent_win)
            progress_dialog.setWindowTitle('Video thumbnail caching')
            progress_dialog.setWindowModality(0)
            progress_dialog.setMinimumDuration(200)
            try:
                progress_dialog.canceled.connect(lambda: stop_event.set())
            except Exception:
                pass
            progress_dialog.show()
        except Exception:
            progress_dialog = None
            stop_event = None
    # shutil already imported above; ensure ffmpeg is available
    ffmpeg_path = shutil.which('ffmpeg')
    if not ffmpeg_path:
        print('[ERROR] ffmpeg not found in PATH. Please install ffmpeg and ensure it is available in your PATH.')
        if platform.system() == 'Darwin':
            print('[ERROR] On macOS, you may need to launch your app from a terminal to inherit PATH, or set PATH in your environment.')
        return
    def cache_one_video(video_path):
        # Skip thumbnail cache files themselves
        try:
            if is_thumb_file(video_path):
                logging.getLogger('thumbnail').debug('Skipping video thumbnail for .thumb file: %s', video_path)
                return
        except Exception:
            pass
        if thumbnail_cache.get(video_path, size) is not None:
            logging.getLogger('thumbnail').debug('Already cached: %s', video_path)
            return
        try:
            import ffmpeg
            from PIL import Image
            import tempfile
            logging.getLogger('thumbnail').debug('Probing video: %s', video_path)
            # Use ffmpeg-python with custom ffmpeg path if needed
            probe = ffmpeg.probe(video_path, cmd=ffmpeg_path)
            duration = float(probe['format'].get('duration', 0))
            if duration == 0:
                logging.getLogger('thumbnail').error('Could not determine duration for %s', video_path)
                return
            seek_time = max(duration * 0.1, 1.0)
            tmp_path = None
            try:
                with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
                    tmp_path = tmp.name
                logging.getLogger('thumbnail').debug('Extracting frame at %.2fs to %s', seek_time, tmp_path)
                (
                    ffmpeg
                    .input(video_path, ss=seek_time)
                    .output(tmp_path, vframes=1, format='image2', vcodec='mjpeg')
                    .overwrite_output()
                    .run(cmd=ffmpeg_path, quiet=False, capture_stdout=True, capture_stderr=True)
                )
                if not os.path.exists(tmp_path) or os.path.getsize(tmp_path) == 0:
                    logging.getLogger('thumbnail').error('ffmpeg did not produce a valid thumbnail for %s', video_path)
                    return
                try:
                    img = Image.open(tmp_path)
                    img = img.convert('RGBA').resize((size, size), Image.LANCZOS)
                    img.save(tmp_path)
                except Exception as e:
                    logging.getLogger('thumbnail').exception('PIL failed to process thumbnail for %s: %s', video_path, e)
                    return
                qimg = QPixmap(tmp_path)
                if qimg.isNull():
                    logging.getLogger('thumbnail').error('QPixmap failed to load thumbnail for %s (trying QImage fallback)', video_path)
                    from PyQt5.QtGui import QImage
                    try:
                        img_fallback = QImage(tmp_path)
                        if not img_fallback.isNull():
                            qimg = QPixmap.fromImage(img_fallback)
                            logging.getLogger('thumbnail').debug('QImage fallback succeeded for %s', video_path)
                        else:
                            logging.getLogger('thumbnail').error('QImage fallback also failed for %s', video_path)
                            return
                    except Exception as e:
                        logging.getLogger('thumbnail').exception('Exception in QImage fallback for %s: %s', video_path, e)
                        return
                thumbnail_cache.put(video_path, size, qimg)
                logging.getLogger('thumbnail').info('Cached video thumbnail for %s', video_path)
            finally:
                try:
                    if tmp_path and os.path.exists(tmp_path):
                        os.remove(tmp_path)
                except Exception:
                    pass
        except Exception as e:
            import traceback
            logging.getLogger('thumbnail').exception('Exception for %s: %s', video_path, e)
            traceback.print_exc()
    executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)
    from concurrent.futures import as_completed
    futures = [executor.submit(cache_one_video, video_path) for video_path in files_to_cache]
    completed = 0
    try:
        for future in as_completed(futures):
            try:
                if stop_event is not None and stop_event.is_set():
                    break
            except Exception:
                pass
            try:
                future.result()
            except Exception:
                pass
            completed += 1
            if progress_dialog is not None:
                try:
                    progress_dialog.setValue(completed)
                    from PyQt5.QtWidgets import QApplication
                    QApplication.processEvents()
                except Exception:
                    pass
    finally:
        try:
            executor.shutdown(wait=False)
        except Exception:
            pass
        if progress_dialog is not None:
            try:
                progress_dialog.close()
            except Exception:
                pass

#!/usr/bin/env python3
"""

Gary's File Manager (garysfm) - Cross-platform Edition



Version: 1.3.0 - Dynamic dialog theming, improved color extraction, transfer manager control

A cross-platform file manager built with PyQt5, supporting Windows, macOS, and Linux.



WHAT'S NEW IN 1.2.9 (September 2025):
- Enhanced: My Computer button functionality for better tab navigation
- Improved: Right panel (Preview, Cloud Sync, Tags, Collections) can now be toggled via View menu
- Streamlined: Removed redundant preview pane toggle - now controlled by right panel toggle
- Enhanced: Right panel visibility state persists between application launches
- Improved: Cleaner bookmark toolbar layout with better My Computer integration
- Fixed: My Computer button error handling and navigation reliability

WHAT'S NEW IN 1.2.7 (September 2025):
- Fixed: macOS thumbnail caching to disk now works properly with directory-based file detection
- Fixed: Video thumbnail caching on macOS - generated thumbnails now persist correctly
- Fixed: macOS path normalization issues with cache key generation using realpath/abspath/normcase
- Enhanced: ThumbnailCache class with macOS-specific optimizations for file system compatibility
- Improved: Cache staleness detection for video files on macOS to prevent unnecessary regeneration
- Fixed: Audio waveform thumbnail caching on macOS using directory listing instead of os.path.exists()

WHAT'S NEW IN 1.2.6 (September 2025):
- New: KDE Breeze theme collection with 4 professional variants (Classic, Dark, Light, Twilight)
- New: Breeze themes feature signature blue accents (#3daee9) and authentic KDE design language
- Improved: My Computer button repositioned next to tabs for better navigation flow
- Improved: Optimized UI layout spacing - reduced gaps between navigation buttons and tabs
- Improved: Removed duplicate My Computer buttons from various locations for cleaner interface
- Fixed: Layout spacing issues that caused excessive whitespace in tab areas
- Enhanced: More compact and efficient interface design throughout the application

WHAT'S NEW IN 1.2.5 (September 2025):
- New: KDE Breeze theme collection with 4 professional variants (Classic, Dark, Light, Twilight)
- New: Breeze themes feature signature blue accents (#3daee9) and authentic KDE design language
- Improved: My Computer button repositioned next to tabs for better navigation flow
- Improved: Optimized UI layout spacing - reduced gaps between navigation buttons and tabs
- Improved: Removed duplicate My Computer buttons from various locations for cleaner interface
- Fixed: Layout spacing issues that caused excessive whitespace in tab areas
- Enhanced: More compact and efficient interface design throughout the application

WHAT'S NEW IN 1.2.4 (September 2025):
- New: Comprehensive QSS stylesheet system with external file loading support
- New: Professional OS theme collection: Windows 11 (Light/Dark), macOS Sequoia (Light/Dark), Ubuntu (Light/Dark), Linux Mint variants, Kali Linux
- New: QSS files now load from external 'qss' folder like gsfmt themes (works in compiled executables)
- New: Enhanced tab width calculation with padding to prevent letter cut-off
- New: Disabled tab text eliding to show full directory names
- New: Tab scroll buttons for overflow navigation
- New: QSS persistence system saves stylesheet choices between launches
- New: Breadcrumb button styling optimized for QSS themes
- Fixed: QSS loading issues in compiled executables
- Improved: Tab navigation with full directory name visibility

FEATURES (including previous versions):
- Drag-and-drop files directly from Gary's File Manager into web browser upload boxes (e.g., GitHub, Google Drive, etc.)
- Now supports native file drag-out for browser-based uploads
- When dragging to a directory within the app, you can choose Move or Copy
- Video thumbnailing for major formats (mp4, mkv, avi, mov, etc.)
- ffmpeg-based thumbnail extraction (cross-platform)
- Persistent thumbnail cache for images and videos
- Improved error handling and stability (no more hangs)
- "Open with..." option in right-click menu for files
- Custom PyQt dialog for choosing applications (cross-platform, non-native)
- Platform-specific handling for launching files with chosen apps
- Improved cross-platform experience for "Open with..."

Performance & Memory Optimizations:
- Virtual file loading with lazy loading for large directories
- Persistent thumbnail cache to disk for faster loading
- Background file system monitoring and updates
- Memory usage optimization with automatic garbage collection
- Advanced caching system for file metadata and icons

CROSS-PLATFORM SETUP:
=====================

Required dependencies:
- Python 3.6+
- PyQt5 (pip install PyQt5)

Optional dependencies for enhanced functionality:
- send2trash (pip install send2trash) - Cross-platform trash/recycle bin support
- winshell (Windows only: pip install winshell) - Enhanced Windows Recycle Bin support

Platform-specific notes:

Windows:
- Terminal support: Windows Terminal, Command Prompt, PowerShell
- File operations: Full Windows Explorer integration
- Trash support: Recycle Bin via PowerShell or winshell

macOS:
- Terminal support: Terminal.app and iTerm2 via enhanced AppleScript
- File operations: Improved Finder integration with better error handling
- Trash support: Multiple fallback methods (AppleScript, trash command, ~/.Trash)
- System requirements: macOS 10.12+ (Sierra or later)
- Native UI: Automatic dark mode detection, native menu bar, proper window behavior
- File filtering: Comprehensive .DS_Store and system file filtering
- Localization: Support for localized folder names (Documents, Downloads, etc.)
- Drag & Drop: Enhanced file dropping with proper path normalization

Linux:
- Terminal support: Auto-detection of gnome-terminal, konsole, xfce4-terminal, etc.
- File operations: XDG-compliant file managers (nautilus, dolphin, thunar, etc.)
- Trash support: gio trash command (usually pre-installed)
- Desktop environment integration via XDG utilities


Usage:
python garysfm_1.1.2.py

Author: turkokards
License: MIT
"""

import sys
import os
import shutil
import shlex
import subprocess
import json
import webbrowser
import mimetypes
import datetime

# Enhanced metadata extraction imports (optional)
try:
    # For EXIF data from images
    from PIL import Image
    from PIL.ExifTags import TAGS, GPSTAGS
    PILLOW_AVAILABLE = True
except ImportError:
    PILLOW_AVAILABLE = False

try:
    # For audio metadata
    import mutagen
    from mutagen.id3 import ID3NoHeaderError
    MUTAGEN_AVAILABLE = True
except ImportError:
    MUTAGEN_AVAILABLE = False

try:
    # For document metadata  
    import magic
    MAGIC_AVAILABLE = True
except ImportError:
    MAGIC_AVAILABLE = False
import time
import threading
import gc
import hashlib
import pickle
import tempfile
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import defaultdict, OrderedDict
from pathlib import Path
import platform
import re
import fnmatch
import zipfile
import tarfile
import gzip
import tempfile
from pathlib import Path
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QTreeView, QFileSystemModel, QListView, QTableView,
    QVBoxLayout, QWidget, QHBoxLayout, QMessageBox, QGridLayout, QSplitter,
    QSizePolicy, QLabel, QAction, QPushButton, QScrollArea, QMenu, QInputDialog, QFileIconProvider,
    QDialog, QLineEdit, QRadioButton, QButtonGroup, QTextEdit, QCheckBox, QStatusBar, QShortcut,
    QComboBox, QToolBar, QFrame, QSlider, QSpinBox, QTabWidget, QPlainTextEdit, QHeaderView, QProgressBar,
    QGroupBox, QTableWidget, QTableWidgetItem, QListWidget, QListWidgetItem, QProgressDialog, QStyle,
    QTabBar, QStackedWidget, QMdiArea, QMdiSubWindow, QFileDialog, QLayout, QDateEdit, QSpacerItem,
    QStyledItemDelegate, QFormLayout
)
from PyQt5.QtCore import QDir, Qt, pyqtSignal, QFileInfo, QPoint, QRect, QTimer, QThread, QStringListModel, QSortFilterProxyModel, QModelIndex, QSize, QMimeData, QUrl, QEvent, QObject, QMutex, QWaitCondition, QDate
from PyQt5.QtCore import pyqtSlot


class GuiInvoker(QObject):
    """Singleton QObject used to invoke callables on the GUI thread via signal."""
    invoke = pyqtSignal(object)

    _instance = None

    def __init__(self):
        super().__init__()
        self.invoke.connect(self._on_invoke)

    @pyqtSlot(object)
    def _on_invoke(self, fn):
        try:
            if callable(fn):
                fn()
        except Exception:
            pass

    @classmethod
    def instance(cls):
        if cls._instance is None:
            cls._instance = GuiInvoker()
        return cls._instance

# Ensure GuiInvoker is created on the main thread during module import so
# background threads can safely emit to it without creating QObjects in other threads.
try:
    _ = GuiInvoker.instance()
except Exception:
    pass


def format_filename_with_underscore_wrap(filename, max_length_before_wrap=20):
    """
    Format filename to enable word wrapping at underscores for long names.
    Replaces underscores with a zero-width space followed by underscore
    to allow natural line breaks at underscore positions.
    
    Args:
        filename (str): The original filename
        max_length_before_wrap (int): Minimum length before considering wrapping
        
    Returns:
        str: Formatted filename with wrap-friendly underscores
    """
    # Only apply wrapping for longer filenames to avoid unnecessary breaks
    if len(filename) > max_length_before_wrap and '_' in filename:
        # Replace underscores with zero-width space + underscore
        # This allows Qt's word wrap to break at these positions
        return filename.replace('_', '\u200B_')
    return filename

def truncate_filename_for_display(filename, max_chars=13, selected=False):
    """
    Truncate filename for display, keeping only the beginning.
    Shows full name when selected, truncated otherwise.
    
    Args:
        filename (str): The original filename
        max_chars (int): Maximum characters to show when not selected
        selected (bool): Whether the item is currently selected
        
    Returns:
        str: Truncated or full filename based on selection state
    """
    if selected or len(filename) <= max_chars:
        return filename
    
    # Truncate to max_chars, no ellipsis - just cut off at character limit
    return filename[:max_chars]

class ArchiveManager:
    """
    Archive management class for handling ZIP, TAR, 7z, RAR and other archive formats.
    Provides functionality to create, extract, and browse archive contents.
    
    Supported formats:
    - ZIP (built-in support)
    - TAR/TAR.GZ/TAR.BZ2 (built-in support)
    - 7z (requires py7zr package or 7z command-line tool)
    - RAR (requires rarfile package or unrar/rar command-line tool)
    - ISO (requires pycdlib package or 7z command-line tool)
    - GZIP (built-in support)
    
    Optional dependencies:
    - pip install py7zr (for 7z support)
    - pip install rarfile (for RAR support)
    - pip install pycdlib (for ISO support)
    
    Command-line fallbacks:
    - 7z, 7za, 7zr, 7zz (for 7z/ISO support)
    - unrar, rar, winrar (for RAR support)
    """
    
    # Supported archive extensions
    ARCHIVE_EXTENSIONS = {
        '.zip': 'ZIP Archive',
        '.tar': 'TAR Archive', 
        '.tar.gz': 'Gzipped TAR Archive',
        '.tgz': 'Gzipped TAR Archive',
        '.tar.bz2': 'Bzipped TAR Archive',
        '.tbz2': 'Bzipped TAR Archive',
        '.tar.xz': 'XZ Compressed TAR Archive',
        '.txz': 'XZ Compressed TAR Archive',
        '.gz': 'Gzipped File',
        '.rar': 'RAR Archive',
        '.7z': '7-Zip Archive',
        '.cab': 'Cabinet Archive',
        '.iso': 'ISO Image',
        '.jar': 'Java Archive (ZIP)',
        '.war': 'Web Archive (ZIP)',
        '.ear': 'Enterprise Archive (ZIP)'
    }
    
    @staticmethod
    def is_archive(file_path):
        """Check if a file is a supported archive format"""
        file_path_lower = str(file_path).lower()
        for ext in ArchiveManager.ARCHIVE_EXTENSIONS.keys():
            if file_path_lower.endswith(ext):
                return True
        return False
    
    @staticmethod
    def get_archive_type(file_path):
        """Get the archive type from file extension"""
        file_path_lower = str(file_path).lower()
        for ext in ArchiveManager.ARCHIVE_EXTENSIONS.keys():
            if file_path_lower.endswith(ext):
                return ext
        return None
    @staticmethod
    def extract_exe_icon_from_iso(iso_path, size=128):
        """
        Extract the icon from the first .exe found in the ISO (prefer setup.exe), return as QPixmap.
        Returns None if not possible.
        """
        try:
            import pycdlib
            import tempfile
            import os
            from PyQt5.QtGui import QPixmap

            # Use the global thumbnail cache if available to avoid repeated extraction
            cache = get_global_thumbnail_cache()
            if cache and cache.is_cached(iso_path, size):
                try:
                    pix = cache.get(iso_path, size)
                    if pix and not pix.isNull():
                        return pix
                except Exception:
                    pass

            # First, get a list of file entries from the ISO using the existing listing helper.
            success, entries_or_err = ArchiveManager.list_archive_contents(iso_path)
            if not success:
                # Fall back to simple root scan if listing helper failed for some reason
                try:
                    iso = pycdlib.PyCdlib()
                    iso.open(iso_path)
                    children = iso.list_children(iso_path='/')
                    entries = []
                    for c in children:
                        try:
                            name = c.file_identifier().decode(errors='ignore').rstrip(';1')
                        except Exception:
                            name = ''
                        if not name:
                            continue
                        full = '/' + name
                        if c.is_dir() and not full.endswith('/'):
                            full = full + '/'
                        entries.append({'name': full, 'is_dir': c.is_dir()})
                    try:
                        iso.close()
                    except Exception:
                        pass
                except Exception:
                    return None
            else:
                entries = entries_or_err

            # Find EXE candidates (prefer setup.exe)
            exe_candidates = [e['name'] for e in entries if (not e.get('is_dir')) and e['name'].lower().endswith('.exe')]
            if not exe_candidates:
                # Also try case-insensitive search for filenames that include '.exe' somewhere
                exe_candidates = [e['name'] for e in entries if (not e.get('is_dir')) and '.exe' in e['name'].lower()]
            if not exe_candidates:
                return None

            preferred = None
            for n in exe_candidates:
                if 'setup.exe' in n.lower():
                    preferred = n
                    break
            if not preferred:
                preferred = exe_candidates[0]

            # Try extracting the preferred EXE using pycdlib with multiple path strategies
            iso = pycdlib.PyCdlib()
            iso.open(iso_path)
            tmp_path = None
            tried = []
            for variant in (preferred, preferred + ';1', os.path.basename(preferred), os.path.basename(preferred) + ';1'):
                if not variant:
                    continue
                # normalize leading slash for variants passed to pycdlib
                if not variant.startswith('/'):
                    variant_path = '/' + variant
                else:
                    variant_path = variant
                # attempt iso_path, joliet_path, and rr_path options
                for kw in ('iso_path', 'joliet_path', 'rr_path'):
                    try:
                        with tempfile.NamedTemporaryFile(delete=False, suffix='.exe') as tmp:
                            # Use keyword arg by building kwargs dict to pass to get_file_from_iso_fp
                            kwargs = {kw: variant_path}
                            try:
                                iso.get_file_from_iso_fp(tmp, **kwargs)
                            except Exception as ex_get:
                                msg = str(ex_get)
                                if 'unopack_from requires a buffer' in msg or 'unpack_from requires a buffer' in msg:
                                    # Specific pycdlib parsing error - log and try next variant
                                    tried.append((variant_path, kw, f"pycdlib buffer error: {msg}"))
                                    try:
                                        tmp.close()
                                    except Exception:
                                        pass
                                    # ensure any partial temp file is removed
                                    try:
                                        if os.path.exists(tmp.name):
                                            os.remove(tmp.name)
                                    except Exception:
                                        pass
                                    continue
                                else:
                                    raise
                            tmp_path = tmp.name

                        if tmp_path and os.path.exists(tmp_path):
                            # success
                            break
                    except Exception as e:
                        tried.append((variant_path, kw, str(e)))
                        # try next variant/kw
                        try:
                            # ensure temp file cleaned up if partially written
                            if 'tmp' in locals() and not tmp.closed:
                                tmp.close()
                        except Exception:
                            pass
                if tmp_path:
                    break

            try:
                iso.close()
            except Exception:
                pass

            if not tmp_path:
                # If pycdlib variants failed, try a 7-Zip (7z) fallback to extract the single
                # candidate file, and if that fails, fall back to extracting the full ISO to
                # a temp directory and searching for EXE files there.
                try:
                    import shutil, subprocess
                    seven = None
                    for cmd in ('7z', '7z.exe', '7zz', '7za', '7zr'):
                        seven_path = shutil.which(cmd)
                        if seven_path:
                            seven = seven_path
                            break
                    if seven:
                        for exe_entry in exe_candidates:
                            try:
                                tmpfh = tempfile.NamedTemporaryFile(delete=False, suffix='.exe')
                                tmpfh.close()
                                candidate_name = exe_entry.lstrip('/')
                                # Use 7z to extract the single file to stdout and write to the temp file
                                with open(tmpfh.name, 'wb') as outp:
                                    subprocess.run([seven, 'e', '-so', iso_path, candidate_name], stdout=outp, stderr=subprocess.DEVNULL, check=True)
                                if os.path.exists(tmpfh.name) and os.path.getsize(tmpfh.name) > 0:
                                    tmp_path = tmpfh.name
                                    break
                                else:
                                    try:
                                        os.remove(tmpfh.name)
                                    except Exception:
                                        pass
                            except Exception:
                                try:
                                    if 'tmpfh' in locals() and os.path.exists(tmpfh.name):
                                        os.remove(tmpfh.name)
                                except Exception:
                                    pass
                                continue

                    # If still not found, attempt full extraction to a temp dir and look for EXEs
                    if not tmp_path:
                        tmpdir = None
                        try:
                            tmpdir = tempfile.mkdtemp(prefix='garysfm_iso_')
                            extracted_any = False
                            # Try using pycdlib to extract all files if available
                            try:
                                import pycdlib
                                iso2 = pycdlib.PyCdlib()
                                iso2.open(iso_path)
                                # Use the previously built entries list if present; otherwise list
                                success_list, entries_list = ArchiveManager.list_archive_contents(iso_path)
                                if success_list and entries_list:
                                    for ent in entries_list:
                                        if ent.get('is_dir'):
                                            continue
                                        rel = ent['name'].lstrip('/')
                                        outpath = os.path.join(tmpdir, *rel.split('/'))
                                        outdir = os.path.dirname(outpath)
                                        os.makedirs(outdir, exist_ok=True)
                                        extracted = False
                                        for kw in ('iso_path', 'joliet_path', 'rr_path'):
                                            try:
                                                with open(outpath, 'wb') as out_f:
                                                    iso2.get_file_from_iso_fp(out_f, **{kw: '/' + rel})
                                                extracted = True
                                                break
                                            except Exception:
                                                try:
                                                    if os.path.exists(outpath):
                                                        os.remove(outpath)
                                                except Exception:
                                                    pass
                                                continue
                                        if extracted:
                                            extracted_any = True
                                try:
                                    iso2.close()
                                except Exception:
                                    pass
                            except Exception:
                                # pycdlib full-extract failed or not present; try 7z full extract
                                try:
                                    if seven:
                                        # x = extract with full paths; -o sets output dir
                                        subprocess.run([seven, 'x', f'-o{tmpdir}', iso_path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
                                        extracted_any = True
                                except Exception:
                                    extracted_any = False

                            # If extraction produced files, scan for EXE candidates
                            if extracted_any:
                                found = []
                                for root, dirs, files in os.walk(tmpdir):
                                    for fn in files:
                                        if fn.lower().endswith('.exe'):
                                            found.append(os.path.join(root, fn))
                                # Prefer setup.exe and nearest-to-root matches
                                preferred_exe = None
                                for path in found:
                                    if os.path.basename(path).lower() == 'setup.exe':
                                        preferred_exe = path
                                        break
                                if not preferred_exe and found:
                                    # pick the shortest relative path (closest to root)
                                    preferred_exe = min(found, key=lambda p: p.count(os.sep))
                                if preferred_exe:
                                    tmp_path = preferred_exe
                        except Exception:
                            pass
                        finally:
                            # if we didn't assign tmp_path from tmpdir extraction, we still want to
                            # keep tmpdir around until after icon extraction uses tmp_path; cleanup
                            # will be attempted later in finally blocks below. Store tmpdir in locals
                            if 'tmpdir' in locals():
                                # we will attempt to remove it after icon extraction
                                pass
                except Exception:
                    # Don't escalate failures from the fallback; we'll log below and return None
                    pass

            if not tmp_path:
                # log attempted variants for debugging (use print to avoid depending on logging setup)
                print(f"[ISO-THUMBNAIL] Could not extract EXE from {iso_path}; tried: {tried}")
                # If we created a tmpdir but couldn't find an EXE, remove it to avoid leaks
                try:
                    if 'tmpdir' in locals() and tmpdir and os.path.exists(tmpdir):
                        import shutil as _sh
                        _sh.rmtree(tmpdir, ignore_errors=True)
                except Exception:
                    pass
                return None

            # Use existing icon extraction
            try:
                icon = get_exe_icon_qicon(tmp_path, size=size)
            except Exception as e:
                print(f"[ISO-THUMBNAIL] get_exe_icon_qicon failed for {tmp_path}: {e}")
                icon = None
            finally:
                try:
                    os.remove(tmp_path)
                except Exception:
                    pass

            if icon and (not icon.isNull()):
                try:
                    pix = icon.pixmap(size, size)
                    # Store in cache for future use
                    if cache:
                        try:
                            cache.put(iso_path, size, pix)
                        except Exception:
                            pass
                    return pix
                except Exception:
                    return None
            return None
        except Exception as e:
            print(f"[ISO-THUMBNAIL] Failed to extract EXE icon from {iso_path}: {e}")
            return None
    
    @staticmethod
    def create_zip_archive(source_paths, output_path, progress_callback=None):
        """
        Create a ZIP archive from multiple source paths
        
        Args:
            source_paths (list): List of file/folder paths to archive
            output_path (str): Output ZIP file path
            progress_callback (callable): Optional callback for progress updates
        """
        try:
            with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                total_files = 0
                processed_files = 0
                # Count total files for progress tracking
                for source_path in source_paths:
                    if os.path.isfile(source_path):
                        total_files += 1
                    elif os.path.isdir(source_path):
                        pass
                # Add files to archive
                for source_path in source_paths:
                    if os.path.isfile(source_path):
                        arcname = os.path.basename(source_path)
                        zipf.write(source_path, arcname)
                        processed_files += 1
                        if progress_callback:
                            progress_callback(processed_files, total_files)
                    elif os.path.isdir(source_path):
                        base_dir = os.path.basename(source_path)
                        for root, dirs, files in os.walk(source_path):
                            for file in files:
                                file_path = os.path.join(root, file)
                                arcname = os.path.join(base_dir, os.path.relpath(file_path, source_path))
                                zipf.write(file_path, arcname)
                                processed_files += 1
                                if progress_callback:
                                    progress_callback(processed_files, total_files)
            
            return True, f"Archive created successfully: {output_path}"
            
        except Exception as e:
            return False, f"Failed to create archive: {str(e)}"
    
    @staticmethod
    def extract_archive(archive_path, extract_to, progress_callback=None):
        """
        Extract an archive to the specified directory
        
        Args:
            archive_path (str): Path to the archive file
            extract_to (str): Directory to extract files to
            progress_callback (callable): Optional callback for progress updates
        """
        try:
            import os
            archive_type = ArchiveManager.get_archive_type(archive_path)
            # Derive a readable extension if detection failed
            try:
                from os.path import splitext
                readable_ext = archive_type if archive_type else splitext(str(archive_path))[1].lower()
            except Exception:
                readable_ext = archive_type

            if archive_type == '.zip' or archive_type in ['.jar', '.war', '.ear']:
                return ArchiveManager._extract_zip(archive_path, extract_to, progress_callback)
            elif archive_type in ['.tar', '.tar.gz', '.tgz', '.tar.bz2', '.tbz2', '.tar.xz', '.txz']:
                return ArchiveManager._extract_tar(archive_path, extract_to, progress_callback)
            elif archive_type == '.gz':
                return ArchiveManager._extract_gzip(archive_path, extract_to, progress_callback)
            elif archive_type == '.rar':
                return ArchiveManager._extract_rar(archive_path, extract_to, progress_callback)
            elif archive_type in ['.7z', '.cab']:
                return ArchiveManager._extract_7z(archive_path, extract_to, progress_callback)
            elif archive_type == '.iso':
                # Implement ISO extraction using pycdlib
                try:
                    import pycdlib
                    import os
                    from datetime import datetime

                    if not os.path.exists(archive_path) or not os.path.isfile(archive_path):
                        return False, f"ISO file not found or not a file: {archive_path}"

                    success, entries_or_err = ArchiveManager.list_archive_contents(archive_path)
                    if not success:
                        return False, f"Failed to list ISO contents before extraction: {entries_or_err}"

                    entries = entries_or_err
                    # Filter to files only
                    files = [e for e in entries if not e.get('is_dir')]
                    total = len(files)
                    processed = 0

                    iso = pycdlib.PyCdlib()
                    iso.open(archive_path)

                    errors = []
                    for e in files:
                        try:
                            # e['name'] is like '/DIR/FILE.EXE' or '/FILE.TXT'
                            rel_path = e['name'].lstrip('/')
                            # Normalize separators
                            rel_path = rel_path.replace('\\', '/').lstrip('/')
                            out_path = os.path.join(extract_to, *rel_path.split('/'))
                            out_dir = os.path.dirname(out_path)
                            if out_dir and not os.path.exists(out_dir):
                                os.makedirs(out_dir, exist_ok=True)

                            # Try multiple pycdlib extraction kwargs for robustness
                            extracted = False
                            for kw in ('iso_path', 'joliet_path', 'rr_path'):
                                try:
                                    with open(out_path, 'wb') as out_f:
                                        kwargs = {kw: '/' + rel_path}
                                        try:
                                            iso.get_file_from_iso_fp(out_f, **kwargs)
                                        except Exception as ex_get:
                                            msg = str(ex_get)
                                            if 'unopack_from requires a buffer' in msg or 'unpack_from requires a buffer' in msg:
                                                # Skip this file on buffer unpack error
                                                raise Exception(f"pycdlib buffer unpack error for {e['name']}: {msg}")
                                            else:
                                                raise
                                    extracted = True
                                    break
                                except Exception:
                                    # Try next kw
                                    try:
                                        if os.path.exists(out_path):
                                            os.remove(out_path)
                                    except Exception:
                                        pass

                            if not extracted:
                                errors.append(f"Could not extract {e['name']}")

                        except Exception as ee:
                            errors.append(f"Error extracting {e.get('name')}: {ee}")

                        processed += 1
                        if progress_callback:
                            try:
                                if not progress_callback(processed, total):
                                    # Caller requested cancellation
                                    break
                            except Exception:
                                pass

                    try:
                        iso.close()
                    except Exception:
                        pass

                    if errors:
                        return False, f"Extraction completed with errors: {errors[:5]}"
                    return True, f"ISO extracted to: {extract_to}"

                except Exception as ex:
                    return False, f"ISO extraction failed: {ex}"
            else:
                return False, f"Unsupported archive format: {readable_ext} for file {archive_path}"
        except Exception as e:
            return False, f"Failed to extract archive: {str(e)}"
    
    @staticmethod
    def _extract_zip(archive_path, extract_to, progress_callback=None):
        """Extract ZIP archive"""
        with zipfile.ZipFile(archive_path, 'r') as zipf:
            members = zipf.infolist()
            total_files = len(members)
            
            for i, member in enumerate(members):
                zipf.extract(member, extract_to)
                if progress_callback:
                    progress_callback(i + 1, total_files)
        
        return True, f"ZIP archive extracted to: {extract_to}"
    
    @staticmethod
    def _extract_tar(archive_path, extract_to, progress_callback=None):
        """Extract TAR archive (including compressed variants)"""
        mode = 'r'
        if archive_path.endswith('.gz') or archive_path.endswith('.tgz'):
            mode = 'r:gz'
        elif archive_path.endswith('.bz2') or archive_path.endswith('.tbz2'):
            mode = 'r:bz2'
        elif archive_path.endswith('.xz') or archive_path.endswith('.txz'):
            mode = 'r:xz'
        
        with tarfile.open(archive_path, mode) as tarf:
            members = tarf.getmembers()
            total_files = len(members)
            
            for i, member in enumerate(members):
                tarf.extract(member, extract_to)
                if progress_callback:
                    progress_callback(i + 1, total_files)
        
        return True, f"TAR archive extracted to: {extract_to}"
    
    @staticmethod
    def _extract_gzip(archive_path, extract_to, progress_callback=None):
        """Extract GZIP file"""
        output_name = os.path.splitext(os.path.basename(archive_path))[0]
        output_path = os.path.join(extract_to, output_name)
        
        with gzip.open(archive_path, 'rb') as gz_file:
            with open(output_path, 'wb') as out_file:
                out_file.write(gz_file.read())
        
        if progress_callback:
            progress_callback(1, 1)
        
        return True, f"GZIP file extracted to: {output_path}"
    
    @staticmethod
    def _extract_rar(archive_path, extract_to, progress_callback=None):
        """Extract RAR archive using rarfile library or command-line tool"""
        try:
            # Try using rarfile library first
            import rarfile
            with rarfile.RarFile(archive_path) as rf:
                members = rf.infolist()
                total_files = len([m for m in members if not m.is_dir()])
                extracted = 0
                
                for member in members:
                    if not member.is_dir():
                        rf.extract(member, extract_to)
                        extracted += 1
                        if progress_callback:
                            progress_callback(extracted, total_files)
                
            return True, f"RAR archive extracted to: {extract_to}"
            
        except ImportError:
            # Fallback to command-line tools
            return ArchiveManager._extract_with_command_line(archive_path, extract_to, 'rar', progress_callback)
        except Exception as e:
            # Try command-line fallback
            try:
                return ArchiveManager._extract_with_command_line(archive_path, extract_to, 'rar', progress_callback)
            except Exception:
                return False, f"Failed to extract RAR archive: {str(e)}"
    
    @staticmethod
    def _extract_7z(archive_path, extract_to, progress_callback=None):
        """Extract 7z archive using py7zr library or command-line tool"""
        try:
            # Try using py7zr library first
            import py7zr
            with py7zr.SevenZipFile(archive_path, mode='r') as archive:
                members = archive.getnames()
                total_files = len(members)
                
                archive.extractall(path=extract_to)
                
                if progress_callback:
                    progress_callback(total_files, total_files)
                
            return True, f"7z archive extracted to: {extract_to}"
            
        except ImportError:
            # Fallback to command-line tools
            return ArchiveManager._extract_with_command_line(archive_path, extract_to, '7z', progress_callback)
        except Exception as e:
            # Try command-line fallback
            try:
                return ArchiveManager._extract_with_command_line(archive_path, extract_to, '7z', progress_callback)
            except Exception:
                return False, f"Failed to extract 7z archive: {str(e)}"
    
    @staticmethod
    def _extract_with_command_line(archive_path, extract_to, archive_type, progress_callback=None):
        """Extract archive using command-line tools as fallback"""
        import subprocess
        import os
        
        # Ensure extract directory exists
        os.makedirs(extract_to, exist_ok=True)
        
        if archive_type == 'rar':
            # Try various RAR command-line tools
            commands = [
                ['unrar', 'x', '-y', archive_path, extract_to + os.sep],
                ['rar', 'x', '-y', archive_path, extract_to + os.sep],
                ['winrar', 'x', '-y', archive_path, extract_to + os.sep]
            ]
        elif archive_type == '7z':
            # Try various 7z command-line tools
            commands = [
                ['7z', 'x', archive_path, f'-o{extract_to}', '-y'],
                ['7za', 'x', archive_path, f'-o{extract_to}', '-y'],
                ['7zr', 'x', archive_path, f'-o{extract_to}', '-y'],
                ['7zz', 'x', archive_path, f'-o{extract_to}', '-y']
            ]
        else:
            return False, f"Unsupported command-line archive type: {archive_type}"
        
        last_error = None
        for cmd in commands:
            try:
                result = subprocess.run(cmd, 
                                      capture_output=True, 
                                      text=True, 
                                      timeout=300,  # 5 minute timeout
                                      check=True)
                
                if progress_callback:
                    progress_callback(1, 1)  # Simple progress for command-line
                
                return True, f"{archive_type.upper()} archive extracted to: {extract_to}"
                
            except subprocess.CalledProcessError as e:
                last_error = f"Command failed: {' '.join(cmd)} - {e.stderr}"
                continue
            except subprocess.TimeoutExpired:
                last_error = f"Command timed out: {' '.join(cmd)}"
                continue
            except FileNotFoundError:
                last_error = f"Command not found: {cmd[0]}"
                continue
            except Exception as e:
                last_error = f"Command error: {' '.join(cmd)} - {str(e)}"
                continue
        
        return True, f"All {archive_type} extraction commands failed. Last error: {last_error}"
    
    @staticmethod
    def create_archive_preview_thumbnail(archive_path, size=128):
        """Create a thumbnail showing archive contents preview"""
        try:
            # Get archive contents
            success, contents = ArchiveManager.list_archive_contents(archive_path)
            if not success:
                return None
            
            # Create thumbnail with file listing
            thumbnail = QPixmap(size, size)
            thumbnail.fill(QColor(240, 240, 240))  # Light gray background
            
            painter = QPainter(thumbnail)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Draw archive type indicator at the top
            archive_type = ArchiveManager.get_archive_type(archive_path)
            type_text = archive_type.upper().lstrip('.') if archive_type else "ARCHIVE"
            
            # Header with archive type
            header_rect = QRect(0, 0, size, 20)
            painter.fillRect(header_rect, QColor(100, 100, 100))
            painter.setPen(Qt.white)
            painter.setFont(QFont("Arial", 8, QFont.Bold))
            painter.drawText(header_rect, Qt.AlignCenter, type_text)
            
            # File listing area
            list_start_y = 22
            available_height = size - list_start_y - 2
            line_height = 12
            max_lines = available_height // line_height
            
            # Prepare file list (limit to visible files)
            files = [item for item in contents if not item.get('is_dir', False)][:max_lines-1]
            folders = [item for item in contents if item.get('is_dir', False)][:max_lines-len(files)-1]
            
            painter.setPen(Qt.black)
            painter.setFont(QFont("Arial", 7))
            
            y_pos = list_start_y
            item_count = 0
            
            # Draw folders first (with folder icons)
            for folder in folders:
                if item_count >= max_lines - 1:
                    break
                    
                # Draw folder icon (small square)
                painter.fillRect(2, y_pos + 2, 8, 6, QColor(255, 255, 150))
                painter.drawRect(2, y_pos + 2, 8, 6)
                
                # Draw folder name (truncated)
                name = folder['name'].split('/')[-1]  # Get just the folder name
                if len(name) > 15:
                    name = name[:12] + "..."
                painter.drawText(12, y_pos + 9, name)
                
                y_pos += line_height
                item_count += 1
            
            # Draw files (with file icons)
            for file in files:
                if item_count >= max_lines - 1:
                    break
                    
                # Draw file icon (small rectangle)
                painter.fillRect(2, y_pos + 2, 8, 8, QColor(200, 200, 255))
                painter.drawRect(2, y_pos + 2, 8, 8)
                
                # Draw file name (truncated)
                name = file['name'].split('/')[-1]  # Get just the filename
                if len(name) > 15:
                    name = name[:12] + "..."
                painter.drawText(12, y_pos + 10, name)
                
                y_pos += line_height
                item_count += 1
            
            # Show "..." if there are more items
            if len(contents) > max_lines - 1:
                painter.drawText(12, y_pos + 10, "...")
            
            # Add file count at bottom
            total_files = len([item for item in contents if not item.get('is_dir', False)])
            total_folders = len([item for item in contents if item.get('is_dir', False)])
            
            if total_folders > 0:
                count_text = f"{total_files} files, {total_folders} folders"
            else:
                count_text = f"{total_files} files"
                
            painter.setFont(QFont("Arial", 6))
            painter.setPen(QColor(100, 100, 100))
            painter.drawText(2, size - 4, count_text)
            
            painter.end()
            return thumbnail
            
        except Exception as e:
            print(f"Failed to create archive preview: {e}")
            return None
    
    @staticmethod
    def list_archive_contents(archive_path):
        """
        List the contents of an archive without extracting
        Args:
            archive_path (str): Path to the archive file
        Returns:
            tuple: (success, contents_list or error_message)
        """
        try:
            archive_type = ArchiveManager.get_archive_type(archive_path)
            if archive_type == '.zip' or archive_type in ['.jar', '.war', '.ear']:
                return ArchiveManager._list_zip_contents(archive_path)
            elif archive_type in ['.tar', '.tar.gz', '.tgz', '.tar.bz2', '.tbz2', '.tar.xz', '.txz']:
                return ArchiveManager._list_tar_contents(archive_path)
            elif archive_type == '.rar':
                return ArchiveManager._list_rar_contents(archive_path)
            elif archive_type in ['.7z', '.cab']:
                return ArchiveManager._list_7z_contents(archive_path)
            elif archive_type == '.iso':
                # Use pycdlib to list ISO contents with iterative traversal to avoid recursion issues
                try:
                    import pycdlib
                    from datetime import datetime
                    import os
                    from collections import deque
                    iso = pycdlib.PyCdlib()
                    iso.open(archive_path)
                    contents = []
                    q = deque(['/'])
                    visited = set()
                    while q:
                        cur = q.popleft()
                        if cur in visited:
                            continue
                        visited.add(cur)
                        # Attempt listing using multiple pycdlib namespace variants to
                        # handle inconsistent Rock Ridge / Joliet / ISO9660 images.
                        children = None
                        for list_kw in ('iso_path', 'joliet_path', 'rr_path'):
                            try:
                                kwargs = {list_kw: cur}
                                tmp_children = iso.list_children(**kwargs)
                                # If this yields results, use them
                                if tmp_children:
                                    children = tmp_children
                                    break
                                # If empty but no exception, keep trying other namespaces
                            except Exception:
                                # Try next namespace
                                continue
                        # Final fallback: try the generic call if available
                        if children is None:
                            try:
                                children = iso.list_children(iso_path=cur)
                            except Exception:
                                # Could not list this directory in any namespace
                                continue
                        if not children:
                            # Nothing to iterate (empty dir)
                            continue
                        for child in children:
                            try:
                                # Some ISO images or pycdlib records can be malformed or incomplete
                                # (which may raise struct/pack/unpack errors). Protect each
                                # child record parse and skip entries that raise unexpected
                                # exceptions rather than aborting the whole listing.
                                try:
                                    raw_name = child.file_identifier().decode(errors='ignore')
                                except Exception:
                                    # If we cannot obtain a name, skip this record
                                    continue
                                # Skip special entries
                                name = raw_name.rstrip(';1')
                                if not name or name in ('.', '..'):
                                    continue
                                try:
                                    is_dir = child.is_dir()
                                except Exception:
                                    # Skip entries we cannot classify
                                    continue
                                try:
                                    size = child.data_length() if not is_dir else 0
                                except Exception:
                                    # If size cannot be read, set to 0 and continue
                                    size = 0
                                dt = None
                                try:
                                    dt = child.datetime()
                                    if isinstance(dt, tuple):
                                        dt = datetime(*dt[:6])
                                except Exception:
                                    dt = datetime.now()

                                # Build a normalized full path (leading slash)
                                if cur == '/':
                                    full = '/' + name
                                else:
                                    full = os.path.join(cur, name).replace('\\', '/')
                                if is_dir and not full.endswith('/'):
                                    full = full + '/'
                                contents.append({
                                    'name': full,
                                    'size': size,
                                    'compressed_size': size,
                                    'is_dir': is_dir,
                                    'date_time': dt,
                                    'type': 'folder' if is_dir else 'file'
                                })
                                if is_dir:
                                    # Enqueue directory for traversal
                                    if full not in visited:
                                        q.append(full)
                            except Exception as child_err:
                                # Defensive: skip problematic records but log for debugging
                                print(f"[ISO-LIST] Skipping malformed ISO directory record in {archive_path} at {cur}: {child_err}")
                                continue
                    try:
                        iso.close()
                    except Exception:
                        pass
                    return True, contents
                except Exception as e:
                    # Write a detailed traceback to a log file to aid debugging of
                    # inconsistent Rock Ridge / Joliet issues. Place log in thumbnail cache dir.
                    try:
                        import traceback
                        cache = get_global_thumbnail_cache()
                        cache_dir = cache.cache_dir if cache else os.path.join(tempfile.gettempdir(), 'garysfm_thumbnails')
                        os.makedirs(cache_dir, exist_ok=True)
                        safe_name = os.path.basename(archive_path).replace(os.path.sep, '_')
                        log_path = os.path.join(cache_dir, f"iso_list_error_{safe_name}.log")
                        with open(log_path, 'w', encoding='utf-8') as lf:
                            lf.write(f"Failed to list ISO contents for: {archive_path}\n\n")
                            lf.write(traceback.format_exc())
                    except Exception:
                        log_path = None
                    msg = str(e)
                    if log_path:
                        return False, f"Failed to list ISO contents: {msg} (details logged to: {log_path})"
                    else:
                        return False, f"Failed to list ISO contents: {msg}"
            else:
                return False, f"Cannot browse contents of {archive_type} files"
        except Exception as e:
            return False, f"Failed to list archive contents: {str(e)}"
    
    @staticmethod
    def _list_zip_contents(archive_path):
        """List ZIP archive contents"""
        contents = []
        with zipfile.ZipFile(archive_path, 'r') as zipf:
            for info in zipf.infolist():
                contents.append({
                    'name': info.filename,
                    'size': info.file_size,
                    'compressed_size': info.compress_size,
                    'is_dir': info.is_dir(),
                    'date_time': datetime(*info.date_time),
                    'type': 'folder' if info.is_dir() else 'file'
                })
        return True, contents
    
    @staticmethod
    def _list_tar_contents(archive_path):
        """List TAR archive contents"""
        mode = 'r'
        if archive_path.endswith('.gz') or archive_path.endswith('.tgz'):
            mode = 'r:gz'
        elif archive_path.endswith('.bz2') or archive_path.endswith('.tbz2'):
            mode = 'r:bz2'
        elif archive_path.endswith('.xz') or archive_path.endswith('.txz'):
            mode = 'r:xz'
        
        contents = []
        with tarfile.open(archive_path, mode) as tarf:
            for member in tarf.getmembers():
                contents.append({
                    'name': member.name,
                    'size': member.size,
                    'compressed_size': member.size,  # TAR doesn't compress per-file
                    'is_dir': member.isdir(),
                    'date_time': datetime.fromtimestamp(member.mtime),
                    'type': 'folder' if member.isdir() else 'file'
                })
        return True, contents

    @staticmethod
    def _list_rar_contents(archive_path):
        """List RAR archive contents"""
        try:
            # Try using rarfile library first
            import rarfile
            contents = []
            with rarfile.RarFile(archive_path) as rf:
                for info in rf.infolist():
                    contents.append({
                        'name': info.filename,
                        'size': info.file_size,
                        'compressed_size': info.compress_size,
                        'is_dir': info.is_dir(),
                        'date_time': datetime(*info.date_time),
                        'type': 'folder' if info.is_dir() else 'file'
                    })
            return True, contents
            
        except ImportError:
            # Fallback to command-line listing
            return ArchiveManager._list_with_command_line(archive_path, 'rar')
        except Exception as e:
            try:
                return ArchiveManager._list_with_command_line(archive_path, 'rar')
            except Exception:
                return False, f"Failed to list RAR contents: {str(e)}"
    
    @staticmethod
    def _list_7z_contents(archive_path):
        """List 7z archive contents"""
        try:
            # Try using py7zr library first
            import py7zr
            contents = []
            with py7zr.SevenZipFile(archive_path, mode='r') as archive:
                for info in archive.list():
                    contents.append({
                        'name': info.filename,
                        'size': info.uncompressed if hasattr(info, 'uncompressed') else 0,
                        'compressed_size': info.compressed if hasattr(info, 'compressed') else 0,
                        'is_dir': info.is_directory,
                        'date_time': info.creationtime if hasattr(info, 'creationtime') else datetime.now(),
                        'type': 'folder' if info.is_directory else 'file'
                    })
            return True, contents
            
        except ImportError:
            # Fallback to command-line listing
            return ArchiveManager._list_with_command_line(archive_path, '7z')
        except Exception as e:
            try:
                return ArchiveManager._list_with_command_line(archive_path, '7z')
            except Exception:
                return False, f"Failed to list 7z contents: {str(e)}"
    
    @staticmethod
    def _list_with_command_line(archive_path, archive_type):
        """List archive contents using command-line tools as fallback"""
        import subprocess
        import re
        from datetime import datetime
        
        if archive_type == 'rar':
            # Try various RAR command-line tools for listing
            commands = [
                ['unrar', 'l', archive_path],
                ['rar', 'l', archive_path],
                ['winrar', 'l', archive_path]
            ]
        elif archive_type == '7z':
            # Try various 7z command-line tools for listing
            commands = [
                ['7z', 'l', archive_path],
                ['7za', 'l', archive_path],
                ['7zr', 'l', archive_path],
                ['7zz', 'l', archive_path]
            ]
        else:
            return False, f"Unsupported command-line archive type: {archive_type}"
        
        for cmd in commands:
            try:
                result = subprocess.run(cmd, 
                                      capture_output=True, 
                                      text=True, 
                                      timeout=30,
                                      check=True)
                
                # Parse the output to extract file information
                contents = []
                lines = result.stdout.split('\n')
                
                if archive_type == 'rar':
                    # Parse RAR listing output
                    in_files_section = False
                    for line in lines:
                        if '-----' in line:
                            in_files_section = True
                            continue
                        if in_files_section and line.strip():
                            # Try to parse RAR line format
                            parts = line.split()
                            if len(parts) >= 3:
                                try:
                                    size = int(parts[0]) if parts[0].isdigit() else 0
                                    name = ' '.join(parts[4:]) if len(parts) > 4 else parts[-1]
                                    is_dir = '<DIR>' in line or 'D' in parts[1] if len(parts) > 1 else False
                                    
                                    contents.append({
                                        'name': name,
                                        'size': size,
                                        'compressed_size': size,
                                        'is_dir': is_dir,
                                        'date_time': datetime.now(),
                                        'type': 'folder' if is_dir else 'file'
                                    })
                                except (ValueError, IndexError):
                                    continue
                
                elif archive_type == '7z':
                    # Parse 7z listing output
                    in_files_section = False
                    for line in lines:
                        if '-----' in line:
                            in_files_section = not in_files_section
                            continue
                        if in_files_section and line.strip():
                            # Try to parse 7z line format
                            parts = line.split()
                            if len(parts) >= 5:
                                try:
                                    size = int(parts[3]) if parts[3].isdigit() else 0
                                    compressed = int(parts[4]) if parts[4].isdigit() else size
                                    name = ' '.join(parts[5:]) if len(parts) > 5 else parts[-1]
                                    is_dir = 'D' in parts[2] if len(parts) > 2 else False
                                    
                                    contents.append({
                                        'name': name,
                                        'size': size,
                                        'compressed_size': compressed,
                                        'is_dir': is_dir,
                                        'date_time': datetime.now(),
                                        'type': 'folder' if is_dir else 'file'
                                    })
                                except (ValueError, IndexError):
                                    continue
                
                return True, contents
                
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
                continue
        
        return False, f"No working {archive_type} command-line tools found for listing"

class BookmarkDialog(QDialog):
    """
    Dialog for managing bookmarks - add, remove, rename, and organize
    """
    
    bookmark_selected = pyqtSignal(str)  # Emitted when a bookmark is selected for navigation
    
    def __init__(self, bookmark_manager, parent=None):
        super().__init__(parent)
        self.bookmark_manager = bookmark_manager
        self.parent = parent
        self.init_ui()
        self.apply_theme()
        self.load_bookmarks()
    
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("Manage Bookmarks")
        self.setModal(True)
        self.resize(500, 400)
        
        layout = QVBoxLayout()
        
        # Header
        header_label = QLabel("Bookmarks / Favorites")
        header_label.setStyleSheet("font-weight: bold; font-size: 14px; margin: 5px;")
        layout.addWidget(header_label)
        
        # Bookmarks list
        self.bookmarks_list = QListWidget()
        self.bookmarks_list.setSelectionMode(QListWidget.SingleSelection)
        self.bookmarks_list.itemDoubleClicked.connect(self.navigate_to_bookmark)
        layout.addWidget(self.bookmarks_list)
        
        # Button layout
        button_layout = QHBoxLayout()
        
        self.navigate_btn = QPushButton("📁 Go To")
        self.navigate_btn.clicked.connect(self.navigate_to_bookmark)
        self.navigate_btn.setEnabled(False)
        button_layout.addWidget(self.navigate_btn)
        
        self.rename_btn = QPushButton("✏️ Rename")
        self.rename_btn.clicked.connect(self.rename_bookmark)
        self.rename_btn.setEnabled(False)
        button_layout.addWidget(self.rename_btn)
        
        self.remove_btn = QPushButton("🗑️ Remove")
        self.remove_btn.clicked.connect(self.remove_bookmark)
        self.remove_btn.setEnabled(False)
        button_layout.addWidget(self.remove_btn)
        
        button_layout.addStretch()
        
        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.accept)
        self.close_btn.setDefault(True)
        button_layout.addWidget(self.close_btn)
        
        layout.addLayout(button_layout)
        
        # Move up/down buttons
        move_layout = QHBoxLayout()
        self.move_up_btn = QPushButton("⬆️ Move Up")
        self.move_up_btn.clicked.connect(self.move_up)
        self.move_up_btn.setEnabled(False)
        move_layout.addWidget(self.move_up_btn)
        
        self.move_down_btn = QPushButton("⬇️ Move Down")
        self.move_down_btn.clicked.connect(self.move_down)
        self.move_down_btn.setEnabled(False)
        move_layout.addWidget(self.move_down_btn)
        
        move_layout.addStretch()
        layout.addLayout(move_layout)
        
        # Connect selection change
        self.bookmarks_list.currentRowChanged.connect(self.on_selection_changed)
        
        self.setLayout(layout)
    
    def load_bookmarks(self):
        """Load bookmarks into the list widget"""
        self.bookmarks_list.clear()
        bookmarks = self.bookmark_manager.get_bookmarks()
        
        for bookmark in bookmarks:
            item = QListWidgetItem()
            item.setText(bookmark["name"])
            item.setData(Qt.UserRole, bookmark["path"])
            
            # Add icon if path exists
            if os.path.exists(bookmark["path"]):
                if os.path.isdir(bookmark["path"]):
                    item.setIcon(self.style().standardIcon(QStyle.SP_DirIcon))
                else:
                    item.setIcon(self.style().standardIcon(QStyle.SP_FileIcon))
            else:
                # Gray out non-existent paths
                item.setIcon(self.style().standardIcon(QStyle.SP_MessageBoxWarning))
                item.setForeground(Qt.gray)
                item.setToolTip(f"Path not found: {bookmark['path']}")
            
            self.bookmarks_list.addItem(item)
    
    def on_selection_changed(self, current_row):
        """Handle selection change"""
        has_selection = current_row >= 0
        self.navigate_btn.setEnabled(has_selection)
        self.rename_btn.setEnabled(has_selection)
        self.remove_btn.setEnabled(has_selection)
        self.move_up_btn.setEnabled(has_selection and current_row > 0)
        self.move_down_btn.setEnabled(has_selection and current_row < self.bookmarks_list.count() - 1)
    
    def navigate_to_bookmark(self):
        """Navigate to the selected bookmark"""
        current_item = self.bookmarks_list.currentItem()
        if current_item:
            path = current_item.data(Qt.UserRole)
            if os.path.exists(path):
                self.bookmark_selected.emit(path)
                self.accept()
            else:
                QMessageBox.warning(self, "Path Not Found", 
                                  f"The bookmarked path no longer exists:\n{path}")
    
    def rename_bookmark(self):
        """Rename the selected bookmark"""
        current_item = self.bookmarks_list.currentItem()
        if current_item:
            path = current_item.data(Qt.UserRole)
            current_name = current_item.text()
            
            new_name, ok = QInputDialog.getText(self, "Rename Bookmark", 
                                              "Enter new name:", text=current_name)
            if ok and new_name.strip():
                if self.bookmark_manager.rename_bookmark(path, new_name.strip()):
                    self.load_bookmarks()
                    # Restore selection
                    for i in range(self.bookmarks_list.count()):
                        if self.bookmarks_list.item(i).data(Qt.UserRole) == path:
                            self.bookmarks_list.setCurrentRow(i)
                            break
    
    def remove_bookmark(self):
        """Remove the selected bookmark"""
        current_item = self.bookmarks_list.currentItem()
        if current_item:
            path = current_item.data(Qt.UserRole)
            name = current_item.text()
            
            reply = QMessageBox.question(self, "Remove Bookmark", 
                                       f"Remove bookmark '{name}'?",
                                       QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                if self.bookmark_manager.remove_bookmark(path):
                    self.load_bookmarks()
    
    def move_up(self):
        """Move selected bookmark up"""
        current_row = self.bookmarks_list.currentRow()
        if current_row > 0:
            if self.bookmark_manager.move_bookmark(current_row, current_row - 1):
                self.load_bookmarks()
                self.bookmarks_list.setCurrentRow(current_row - 1)
    
    def move_down(self):
        """Move selected bookmark down"""
        current_row = self.bookmarks_list.currentRow()
        if current_row < self.bookmarks_list.count() - 1:
            if self.bookmark_manager.move_bookmark(current_row, current_row + 1):
                self.load_bookmarks()
                self.bookmarks_list.setCurrentRow(current_row + 1)
    
    def apply_theme(self):
        """Apply dark or light theme based on current setting"""
        # Determine effective dark mode from self or parent
        dark_mode = False
        try:
            if getattr(self, 'dark_mode', False):
                dark_mode = True
            elif hasattr(self, 'parent') and getattr(self.parent, 'dark_mode', False):
                dark_mode = True
        except Exception:
            dark_mode = getattr(self, 'dark_mode', False)

        try:
            if dark_mode:
                # Dark mode styling
                dark_style = (
                    "QWidget { background-color: #2b2b2b; color: #ffffff; }"
                    "QListWidget { background-color: #3c3c3c; color: #ffffff; border: 1px solid #555; }"
                    "QPushButton { background-color: #404040; color: #ffffff; border: 1px solid #555; padding: 5px 12px; }"
                    "QPushButton:hover { background-color: #505050; }"
                    "QPushButton:pressed { background-color: #2a2a2a; }"
                )
                self.setStyleSheet(dark_style)
            else:
                # Light mode: apply named theme if available
                theme_name = getattr(self, 'color_theme', 'Default Light')
                theme = getattr(self, 'COLOR_THEMES', {}).get(theme_name)
                if theme:
                    win = theme.get('window_bg', '#ffffff')
                    panel = theme.get('panel_bg', '#f5f5f5')
                    text = theme.get('text', '#000000')
                    accent = theme.get('accent', '#0078d7')

                    light_style = f"""
QWidget, QDialog {{
    background-color: {win};
    color: {text};
}}
QListWidget {{
    background-color: {panel};
    color: {text};
    border: 1px solid rgba(0,0,0,0.08);
}}
QPushButton {{
    background-color: {panel};
    color: {text};
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 3px;
    padding: 5px 12px;
}}
QPushButton:hover {{ background-color: {win}; }}
QPushButton:pressed {{ background-color: {accent}; color: #ffffff; }}
QListWidget::item:selected {{ background-color: {accent}; color: #ffffff; }}
"""
                    self.setStyleSheet(light_style)
                else:
                    self.setStyleSheet("")
        except Exception:
            self.setStyleSheet("")

class BookmarkToolbar(QWidget):
    """
    Bookmark toolbar widget with add bookmark, bookmark dropdown, and manage bookmarks buttons
    """
    
    bookmark_selected = pyqtSignal(str)  # Emitted when a bookmark is selected for navigation
    
    def __init__(self, bookmark_manager, parent=None):
        super().__init__(parent)
        self.bookmark_manager = bookmark_manager
        self.parent = parent
        self.init_ui()
    
    def init_ui(self):
        """Initialize the bookmark toolbar UI"""
        layout = QHBoxLayout()
        layout.setContentsMargins(2, 8, 2, 8)  # Increased vertical margins for double height
        layout.setSpacing(4)
        
        # Add bookmark button
        self.add_bookmark_btn = QPushButton("⭐ Add")
        self.add_bookmark_btn.setToolTip("Add current directory to bookmarks (Ctrl+D)")
        self.add_bookmark_btn.setMaximumHeight(48)  # Double the button height
        self.add_bookmark_btn.clicked.connect(self.add_current_bookmark)
        layout.addWidget(self.add_bookmark_btn)
        
        # Bookmarks dropdown
        self.bookmarks_combo = QComboBox()
        self.bookmarks_combo.setToolTip("Select a bookmark to navigate\nClick: Open in new tab\nCtrl+Click: Open in current tab")
        self.bookmarks_combo.setMinimumWidth(200)
        self.bookmarks_combo.setMaximumHeight(48)  # Double the combo height
        self.bookmarks_combo.activated.connect(self.navigate_to_bookmark)
        layout.addWidget(self.bookmarks_combo)
        
        # Manage bookmarks button
        self.manage_btn = QPushButton("📝 Manage")
        self.manage_btn.setToolTip("Manage bookmarks (Ctrl+B)\nDoubleclick bookmark: New tab\nCtrl+Doubleclick: Current tab")
        self.manage_btn.setMaximumHeight(48)  # Double the button height
        self.manage_btn.clicked.connect(self.show_manage_dialog)
        layout.addWidget(self.manage_btn)
        
        # My Computer button
        self.my_computer_btn = QPushButton("🖥️ My Computer")
        self.my_computer_btn.setToolTip("Show drives and computer overview")
        self.my_computer_btn.setMaximumHeight(48)  # Double the button height
        self.my_computer_btn.clicked.connect(self.show_my_computer)
        layout.addWidget(self.my_computer_btn)
        
        layout.addStretch()
        self.setLayout(layout)
        
        # Set double height for the entire widget
        self.setMaximumHeight(62)  # Double the overall height limit (31 * 2)
        
        # Initial load
        self.refresh_bookmarks()
    
    def refresh_bookmarks(self):
        """Refresh the bookmarks dropdown"""
        self.bookmarks_combo.clear()
        self.bookmarks_combo.addItem("📁 Select Bookmark...", "")
        
        bookmarks = self.bookmark_manager.get_bookmarks()
        for bookmark in bookmarks:
            # Check if path exists and show appropriate icon
            if os.path.exists(bookmark["path"]):
                self.bookmarks_combo.addItem(bookmark["name"], bookmark["path"])
            else:
                # Gray out non-existent bookmarks
                self.bookmarks_combo.addItem(f"❌ {bookmark['name']} (missing)", bookmark["path"])
    
    def add_current_bookmark(self, path=None):
        """Add current directory as a bookmark"""
        # Get current path from parameter or parent window
        current_path = path or self.get_current_path()
        
        if not current_path:
            QMessageBox.warning(self, "No Path", "Cannot determine current directory.")
            return
        
        # Check if already bookmarked
        if self.bookmark_manager.is_bookmarked(current_path):
            QMessageBox.information(self, "Already Bookmarked", 
                                  f"This directory is already bookmarked.")
            return
        
        # Get bookmark name from user
        default_name = os.path.basename(current_path) or current_path
        name, ok = QInputDialog.getText(self, "Add Bookmark", 
                                      "Enter bookmark name:", text=default_name)
        if ok and name.strip():
            if self.bookmark_manager.add_bookmark(name.strip(), current_path):
                self.refresh_bookmarks()
                QMessageBox.information(self, "Bookmark Added", 
                                      f"Added bookmark: {name.strip()}")
                # Update parent window status bar if available
                if hasattr(self.parent, 'statusBar'):
                    self.parent.statusBar().showMessage(f"Bookmarked: {current_path}", 3000)
    
    def navigate_to_bookmark(self, index):
        """Navigate to selected bookmark"""
        if index > 0:  # Skip the "Select Bookmark..." item
            path = self.bookmarks_combo.itemData(index)
            if path and os.path.exists(path):
                self.bookmark_selected.emit(path)
                # Reset combo to default
                self.bookmarks_combo.setCurrentIndex(0)
            else:
                QMessageBox.warning(self, "Path Not Found", 
                                  f"The bookmarked path no longer exists:\n{path}")
    
    def show_manage_dialog(self):
        """Show the bookmark management dialog"""
        dialog = BookmarkDialog(self.bookmark_manager, self)
        dialog.bookmark_selected.connect(self.bookmark_selected.emit)
        if dialog.exec_() == QDialog.Accepted:
            self.refresh_bookmarks()
        dialog.deleteLater()
    
    def get_current_path(self):
        """Get current path from parent window"""
        try:
            # Method 1: Direct get_current_path method
            if hasattr(self.parent, 'get_current_path'):
                path = self.parent.get_current_path()
                if path:
                    return path
            
            # Method 2: Direct current_folder attribute
            if hasattr(self.parent, 'current_folder') and self.parent.current_folder:
                return self.parent.current_folder
            
            # Method 3: Tab manager approach
            if hasattr(self.parent, 'tab_manager'):
                current_tab = self.parent.tab_manager.get_current_tab()
                if current_tab:
                    if hasattr(current_tab, 'current_folder') and current_tab.current_folder:
                        return current_tab.current_folder
                    elif hasattr(current_tab, 'get_current_path'):
                        path = current_tab.get_current_path()
                        if path:
                            return path
            
            # Method 4: Current widget approach
            if hasattr(self.parent, 'currentWidget'):
                current_tab = self.parent.currentWidget()
                if current_tab:
                    if hasattr(current_tab, 'get_current_path'):
                        path = current_tab.get_current_path()
                        if path:
                            return path
                    elif hasattr(current_tab, 'current_path') and current_tab.current_path:
                        return current_tab.current_path
                    elif hasattr(current_tab, 'current_folder') and current_tab.current_folder:
                        return current_tab.current_folder
            
            # Method 5: Fallback to home directory as last resort
            import os
            return os.path.expanduser("~")
            
        except Exception:
            # Ultimate fallback
            import os
            return os.path.expanduser("~")
    
    def show_my_computer(self):
        """Show My Computer view - drives and computer overview"""
        try:
            # Find the main window by traversing up the parent hierarchy
            main_window = self.parent
            while main_window and not hasattr(main_window, 'get_current_tab_manager'):
                main_window = main_window.parent() if hasattr(main_window, 'parent') else None
            
            if main_window and hasattr(main_window, 'get_current_tab_manager'):
                # Get the current tab manager (handles both single and dual pane modes)
                current_tab_manager = main_window.get_current_tab_manager()
                if current_tab_manager:
                    # Check if the tab manager has the open_my_computer_tab method
                    if hasattr(current_tab_manager, 'open_my_computer_tab'):
                        current_tab_manager.open_my_computer_tab()
                        return
                    elif hasattr(current_tab_manager, 'new_tab'):
                        # Fallback: use new_tab with the special My Computer sentinel
                        current_tab_manager.new_tab("__MY_COMPUTER__")
                        return
            
            # Fallback: try to call parent's show_my_computer methods directly  
            if hasattr(self.parent, 'show_my_computer'):
                self.parent.show_my_computer()
                return
            elif hasattr(self.parent, 'show_my_computer_main'):
                self.parent.show_my_computer_main()
                return
            elif hasattr(self.parent, 'navigate_to_drives'):
                self.parent.navigate_to_drives()
                return
            elif hasattr(self.parent, 'show_drives'):
                self.parent.show_drives()
                return
            
            # If direct parent doesn't have the method, try to find main window
            main_window = self.parent
            while main_window and not hasattr(main_window, 'show_my_computer'):
                main_window = main_window.parent() if hasattr(main_window, 'parent') else None
                
            if main_window and hasattr(main_window, 'show_my_computer'):
                main_window.show_my_computer()
                return
            
            # Final fallback: navigate to filesystem root 
            main_window = self.parent
            while main_window and not hasattr(main_window, 'navigate_to_folder'):
                main_window = main_window.parent() if hasattr(main_window, 'parent') else None
                
            if main_window and hasattr(main_window, 'navigate_to_folder'):
                # Navigate to filesystem root which should show drives
                import os
                try:
                    # On Windows, this will show drives; on Unix, shows root
                    main_window.navigate_to_folder(os.path.sep)
                except Exception:
                    # Fallback to home directory
                    main_window.navigate_to_folder(os.path.expanduser("~"))
                    
        except Exception as e:
            print(f"Error showing My Computer: {e}")
            # Final fallback: try to navigate to home directory
            try:
                main_window = self.parent
                while main_window and not hasattr(main_window, 'navigate_to_folder'):
                    main_window = main_window.parent() if hasattr(main_window, 'parent') else None
                    
                if main_window and hasattr(main_window, 'navigate_to_folder'):
                    import os
                    main_window.navigate_to_folder(os.path.expanduser("~"))
            except Exception:
                pass  # Give up gracefully
    
    def apply_theme(self, dark_mode=False, theme=None):
        """Apply theme to bookmark toolbar"""
        try:
            if dark_mode:
                style = """
                QWidget { background-color: #2b2b2b; color: #ffffff; }
                QPushButton { 
                    background-color: #404040; 
                    color: #ffffff; 
                    border: 1px solid #555; 
                    padding: 8px 12px; 
                    border-radius: 3px;
                }
                QPushButton:hover { background-color: #505050; }
                QPushButton:pressed { background-color: #2a2a2a; }
                QComboBox {
                    background-color: #404040;
                    color: #ffffff;
                    border: 1px solid #555;
                    padding: 8px 12px;
                    border-radius: 3px;
                }
                QComboBox::drop-down { border: none; }
                QComboBox::down-arrow { color: #ffffff; }
                """
            else:
                # Light theme
                if theme:
                    win = theme.get('window_bg', '#ffffff')
                    panel = theme.get('panel_bg', '#f5f5f5')
                    text = theme.get('text', '#000000')
                    accent = theme.get('accent', '#0078d7')
                    
                    style = f"""
                    QWidget {{ background-color: {win}; color: {text}; }}
                    QPushButton {{ 
                        background-color: {panel}; 
                        color: {text}; 
                        border: 1px solid rgba(0,0,0,0.08); 
                        padding: 8px 12px; 
                        border-radius: 3px;
                    }}
                    QPushButton:hover {{ background-color: {win}; }}
                    QPushButton:pressed {{ background-color: {accent}; color: #ffffff; }}
                    QComboBox {{
                        background-color: {panel};
                        color: {text};
                        border: 1px solid rgba(0,0,0,0.08);
                        padding: 8px 12px;
                        border-radius: 3px;
                    }}
                    """
                else:
                    style = ""
            
            self.setStyleSheet(style)
        except Exception:
            self.setStyleSheet("")

class ArchiveBrowserDialog(QDialog):
    """
    Dialog for browsing archive contents before extraction
    """
    
    def __init__(self, archive_path, parent=None):
        super().__init__(parent)
        self.archive_path = archive_path
        self.selected_items = []
        self.parent = parent
        self.init_ui()
        self.apply_theme()  # Apply theme after UI is initialized
        self.load_archive_contents()
    
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle(f"Archive Browser - {os.path.basename(self.archive_path)}")
        self.setModal(True)
        self.resize(600, 400)
        
        layout = QVBoxLayout()
        
        # Archive info label
        info_label = QLabel(f"Archive: {self.archive_path}")
        info_label.setStyleSheet("font-weight: bold; margin: 5px;")
        layout.addWidget(info_label)
        
        # Contents table
        self.contents_table = QTableWidget()
        self.contents_table.setColumnCount(4)
        self.contents_table.setHorizontalHeaderLabels(['Name', 'Type', 'Size', 'Modified'])
        self.contents_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.contents_table.setAlternatingRowColors(False)  # Don't use alternating colors - respect theme
        self.contents_table.setSortingEnabled(True)
        
        # Make table columns resizable
        header = self.contents_table.horizontalHeader()
        header.setStretchLastSection(True)
        header.setSectionResizeMode(0, QHeaderView.Interactive)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
        
        layout.addWidget(self.contents_table)
        
        # Button layout
        button_layout = QHBoxLayout()
        
        self.select_all_btn = QPushButton("Select All")
        self.select_all_btn.clicked.connect(self.select_all_items)
        button_layout.addWidget(self.select_all_btn)
        
        self.select_none_btn = QPushButton("Select None")
        self.select_none_btn.clicked.connect(self.select_no_items)
        button_layout.addWidget(self.select_none_btn)
        
        button_layout.addStretch()
        
        self.extract_btn = QPushButton("Extract Selected")
        self.extract_btn.clicked.connect(self.accept)
        self.extract_btn.setDefault(True)
        button_layout.addWidget(self.extract_btn)
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(self.cancel_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
    
    def load_archive_contents(self):
        """Load and display archive contents"""
        try:
            success, contents = ArchiveManager.list_archive_contents(self.archive_path)
            
            if not success:
                QMessageBox.warning(self, "Error", contents)
                return
            
            self.contents_table.setRowCount(len(contents))
            
            for i, item in enumerate(contents):
                # Name column
                name_item = QTableWidgetItem(item['name'])
                if item['is_dir']:
                    name_item.setIcon(self.style().standardIcon(QStyle.SP_DirIcon))
                else:
                    name_item.setIcon(self.style().standardIcon(QStyle.SP_FileIcon))
                self.contents_table.setItem(i, 0, name_item)
                
                # Type column
                type_item = QTableWidgetItem(item['type'].title())
                self.contents_table.setItem(i, 1, type_item)
                
                # Size column
                if item['is_dir']:
                    size_text = "-"
                else:
                    size_text = self.format_file_size(item['size'])
                size_item = QTableWidgetItem(size_text)
                size_item.setData(Qt.UserRole, item['size'])  # Store actual size for sorting
                self.contents_table.setItem(i, 2, size_item)
                
                # Modified column
                date_text = item['date_time'].strftime('%Y-%m-%d %H:%M:%S')
                date_item = QTableWidgetItem(date_text)
                date_item.setData(Qt.UserRole, item['date_time'])  # Store actual date for sorting
                self.contents_table.setItem(i, 3, date_item)
        
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load archive contents: {str(e)}")
    
    def format_file_size(self, size_bytes):
        """Format file size in human readable format"""
        if size_bytes == 0:
            return "0 B"
        
        size_names = ["B", "KB", "MB", "GB", "TB"]
        i = 0
        while size_bytes >= 1024 and i < len(size_names) - 1:
            size_bytes /= 1024.0
            i += 1
        
        return f"{size_bytes:.1f} {size_names[i]}"
    
    def select_all_items(self):
        """Select all items in the table"""
        self.contents_table.selectAll()
    
    def select_no_items(self):
        """Deselect all items in the table"""
        self.contents_table.clearSelection()
    
    def get_selected_items(self):
        """Get list of selected item names"""
        selected_items = []
        for row in range(self.contents_table.rowCount()):
            if self.contents_table.item(row, 0).isSelected():
                selected_items.append(self.contents_table.item(row, 0).text())
        return selected_items
    
    def apply_theme(self):
        """Apply dark or light theme based on current setting (uses named light color themes)."""
        # Determine effective dark mode from self or parent
        dark_mode = False
        try:
            if getattr(self, 'dark_mode', False):
                dark_mode = True
            elif hasattr(self, 'parent') and getattr(self.parent, 'dark_mode', False):
                dark_mode = True
        except Exception:
            dark_mode = getattr(self, 'dark_mode', False)

        try:
            if dark_mode:
                # Dark mode styling (kept concise)
                dark_style = (
                    "QWidget { background-color: #2b2b2b; color: #ffffff; }"
                    "QMenu { background-color: #3c3c3c; color: #ffffff; border: 1px solid #555; }"
                    "QToolBar { background-color: #404040; color: #ffffff; border: none; }"
                    "QTabWidget::pane { background-color: #3c3c3c; color: #ffffff; }"
                    "QTabBar::tab { background-color: #404040; color: #ffffff; padding: 8px 16px; }"
                )
                self.setStyleSheet(dark_style)
            else:
                # Light mode: apply named theme if available
                theme_name = getattr(self, 'color_theme', 'Default Light')
                theme = getattr(self, 'COLOR_THEMES', {}).get(theme_name)
                if theme:
                    win = theme.get('window_bg', '#ffffff')
                    panel = theme.get('panel_bg', '#f5f5f5')
                    text = theme.get('text', '#000000')
                    accent = theme.get('accent', '#0078d7')

                    light_style = f"""
QWidget, QDialog {{
    background-color: {win};
    color: {text};
}}
QFrame, QGroupBox {{
    background-color: {panel};
    color: {text};
}}
QLabel {{ color: {text}; background-color: transparent; }}
QPushButton {{
    background-color: {panel};
    color: {text};
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 3px;
    padding: 5px 12px;
}}
QPushButton:hover {{ background-color: {win}; }}
QTableWidget {{
    background-color: {panel};
    color: {text};
    gridline-color: rgba(0,0,0,0.06);
}}
QHeaderView::section {{ background-color: {panel}; color: {text}; padding: 4px; }}
QMenuBar {{ background-color: {win}; color: {text}; }}
QMenu {{ background-color: {panel}; color: {text}; }}
QToolBar {{ background-color: {win}; border: none; }}
QLineEdit, QTextEdit, QPlainTextEdit {{ background-color: #ffffff; color: {text}; border: 1px solid rgba(0,0,0,0.08); }}
QProgressBar {{ background-color: {panel}; color: {text}; }}
QScrollBar:vertical {{ background: {panel}; }}
/* Accent color for selections */
QWidget:selected, QTableWidget::item:selected {{ background-color: {accent}; color: #ffffff; }}
"""
                    self.setStyleSheet(light_style)
                else:
                    self.setStyleSheet("")
        except Exception:
            # On error, reset to no stylesheet
            self.setStyleSheet("")

class FormattedFileSystemModel(QFileSystemModel):
    """
    Custom QFileSystemModel that applies underscore word wrapping to display names.
    This ensures folder and file names can wrap at underscores in list and detail views.
    """
    
    def data(self, index, role):
        """Override data method to apply formatting to display names and provide icons for list/detail views"""
        if role == Qt.DisplayRole:
            # Get the original filename from the base model
            original_name = super().data(index, role)
            if original_name:
                # Apply underscore wrapping formatting
                return format_filename_with_underscore_wrap(str(original_name))
        elif role == Qt.DecorationRole and index.column() == 0:
            # Provide the icon for the first column (left end)
            return super().data(index, Qt.DecorationRole)
        # For all other roles, use the original data
        return super().data(index, role)

class WordWrapDelegate(QStyledItemDelegate):
    """
    Custom delegate that handles word wrapping and name truncation.
    Shows truncated names (13 chars) normally, full names when selected.
    """
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent_widget = parent
    
    def paint(self, painter, option, index):
        """Custom paint method that handles truncation, word wrapping, icon drawing, and drive usage bar"""
        import os
        import shutil
        # Draw background and selection
        if option.state & QStyle.State_Selected:
            painter.fillRect(option.rect, option.palette.highlight())
        else:
            painter.fillRect(option.rect, option.palette.base())

        # Draw icon if present
        icon = index.data(Qt.DecorationRole)
        rect = option.rect
        icon_size = option.decorationSize if hasattr(option, 'decorationSize') else QSize(20, 20)
        if isinstance(icon, QIcon):
            icon_rect = QRect(rect.left() + 3, rect.top() + (rect.height() - icon_size.height()) // 2, icon_size.width(), icon_size.height())
            icon.paint(painter, icon_rect, Qt.AlignVCenter | Qt.AlignLeft)
            text_offset = icon_size.width() + 8
        else:
            text_offset = 3

        # Get the original text
        original_text = index.data(Qt.DisplayRole)
        if not original_text:
            return

        # Check if item is selected
        is_selected = option.state & QStyle.State_Selected

        # Apply truncation based on selection state
        display_text = truncate_filename_for_display(str(original_text), max_chars=13, selected=is_selected)

        # Apply underscore wrapping if not truncated
        if is_selected or len(original_text) <= 13:
            display_text = format_filename_with_underscore_wrap(display_text)

        # Set up the text document for rendering
        doc = QTextDocument()
        doc.setPlainText(display_text)
        doc.setDefaultFont(option.font)
        doc.setTextWidth(rect.width() - text_offset - 6)

        # Set word wrap mode to wrap at word boundaries (including zero-width spaces)
        doc.setDefaultTextOption(QTextOption(Qt.AlignLeft | Qt.AlignVCenter))
        text_option = doc.defaultTextOption()
        text_option.setWrapMode(QTextOption.WrapAtWordBoundaryOrAnywhere)
        doc.setDefaultTextOption(text_option)

        # Set text color
        if is_selected:
            painter.setPen(option.palette.highlightedText().color())
        else:
            bg_color = option.palette.base().color()
            is_dark_mode = bg_color.lightness() < 128
            if is_dark_mode:
                font = option.font
                font.setBold(True)
                doc.setDefaultFont(font)
                text_format = QTextCharFormat()
                text_format.setForeground(QBrush(QColor(255, 255, 255)))
                text_format.setFont(font)
                cursor = QTextCursor(doc)
                cursor.select(QTextCursor.Document)
                cursor.setCharFormat(text_format)
                painter.setPen(QColor(255, 255, 255))
            else:
                painter.setPen(option.palette.text().color())

        # Draw the text with proper margins to prevent cutoff, shifted right for icon
        painter.save()
        text_rect = QRect(rect.left() + text_offset, rect.top() + 2, rect.width() - text_offset - 3, rect.height() - 24)
        painter.translate(text_rect.topLeft())
        doc.setTextWidth(text_rect.width())
        doc.drawContents(painter)
        painter.restore()

        # --- Custom: Draw drive usage bar if in drive-list mode and this is a drive root ---
        # Heuristic: If the item is a drive root (like 'C:/'), show the bar
        drive_path = None
        try:
            # Only show for top-level items (parent is invalid)
            if not index.parent().isValid():
                # Try to get the absolute path from the model
                file_info = index.model().fileInfo(index)
                if file_info.isRoot() or file_info.isDir():
                    drive_path = file_info.absoluteFilePath()
                    # On Windows, ensure it ends with a slash (C:/)
                    if os.name == 'nt' and len(drive_path) == 2 and drive_path[1] == ':':
                        drive_path += '/'
        except Exception:
            pass
        if drive_path and os.path.ismount(drive_path):
            try:
                usage = shutil.disk_usage(drive_path)
                percent = int(usage.used / usage.total * 100) if usage.total > 0 else 0
                bar_rect = QRect(rect.left() + text_offset, rect.bottom() - 18, rect.width() - text_offset - 10, 12)
                # Draw background bar
                painter.save()
                painter.setPen(Qt.NoPen)
                painter.setBrush(QColor(220, 220, 220) if not is_selected else QColor(80, 80, 80))
                painter.drawRect(bar_rect)
                # Draw usage bar
                bar_width = int(bar_rect.width() * percent / 100)
                painter.setBrush(QColor(0, 120, 215) if not is_selected else QColor(0, 180, 255))
                painter.drawRect(QRect(bar_rect.left(), bar_rect.top(), bar_width, bar_rect.height()))
                painter.restore()
                # Draw text: 'xx% used, 10.2 GB free of 100 GB'
                used_gb = usage.used / (1024 ** 3)
                total_gb = usage.total / (1024 ** 3)
                free_gb = usage.free / (1024 ** 3)
                usage_text = f"{percent}% used, {free_gb:.1f} GB free of {total_gb:.1f} GB"
                painter.save()
                painter.setPen(QColor(40, 40, 40) if not is_selected else QColor(255, 255, 255))
                font = option.font
                font.setPointSizeF(font.pointSizeF() * 0.9)
                painter.setFont(font)
                painter.drawText(bar_rect, Qt.AlignCenter, usage_text)
                painter.restore()
            except Exception:
                pass
    
    def sizeHint(self, option, index):
        """Calculate the size hint for the text"""
        original_text = index.data(Qt.DisplayRole)
        if not original_text:
            return super().sizeHint(option, index)
        
        # Check if item is selected
        is_selected = option.state & QStyle.State_Selected
        
        # Use truncated text for size calculation when not selected
        display_text = truncate_filename_for_display(str(original_text), max_chars=13, selected=is_selected)
        
        # Create a text document to calculate the required size with margins
        doc = QTextDocument()
        doc.setPlainText(display_text)
        doc.setDefaultFont(option.font)
        # Account for margins when calculating width
        available_width = option.rect.width() - 6 if option.rect.width() > 6 else 200  # Subtract margin space
        doc.setTextWidth(available_width)
        
        text_option = QTextOption(Qt.AlignLeft | Qt.AlignVCenter)
        text_option.setWrapMode(QTextOption.WrapAtWordBoundaryOrAnywhere)
        doc.setDefaultTextOption(text_option)
        
        # Return the calculated size plus margin space
        size = doc.size().toSize()
        size.setWidth(size.width() + 6)  # Add back margin space
        size.setHeight(size.height() + 4)  # Add vertical margin space
        return QSize(size.width(), max(size.height(), option.fontMetrics.height()))

# Cross-platform utility functions
class PlatformUtils:
    @staticmethod
    def get_music_directory():
        """Get user's music directory"""
        home = PlatformUtils.get_home_directory()
        if PlatformUtils.is_windows():
            return os.path.join(home, "Music")
        elif PlatformUtils.is_macos():
            music_path = os.path.join(home, "Music")
            if not os.path.exists(music_path):
                alt_paths = [
                    os.path.join(home, "Musique"),  # French
                    os.path.join(home, "Música"),   # Spanish
                    os.path.join(home, "Music")     # Fallback
                ]
                for path in alt_paths:
                    if os.path.exists(path):
                        return path
            return music_path
        else:  # Linux
            try:
                result = subprocess.run(["xdg-user-dir", "MUSIC"], capture_output=True, text=True, check=True)
                return result.stdout.strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                return os.path.join(home, "Music")

    @staticmethod
    def get_pictures_directory():
        """Get user's pictures directory"""
        home = PlatformUtils.get_home_directory()
        if PlatformUtils.is_windows():
            return os.path.join(home, "Pictures")
        elif PlatformUtils.is_macos():
            pictures_path = os.path.join(home, "Pictures")
            if not os.path.exists(pictures_path):
                alt_paths = [
                    os.path.join(home, "Fotos"),    # Spanish
                    os.path.join(home, "Images"),   # French
                    os.path.join(home, "Pictures")  # Fallback
                ]
                for path in alt_paths:
                    if os.path.exists(path):
                        return path
            return pictures_path
        else:  # Linux
            try:
                result = subprocess.run(["xdg-user-dir", "PICTURES"], capture_output=True, text=True, check=True)
                return result.stdout.strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                return os.path.join(home, "Pictures")

    @staticmethod
    def get_videos_directory():
        """Get user's videos directory"""
        home = PlatformUtils.get_home_directory()
        if PlatformUtils.is_windows():
            return os.path.join(home, "Videos")
        elif PlatformUtils.is_macos():
            videos_path = os.path.join(home, "Movies")
            if not os.path.exists(videos_path):
                alt_paths = [
                    os.path.join(home, "Videos"),   # English fallback
                    os.path.join(home, "Películas"), # Spanish
                    os.path.join(home, "Films"),    # French
                    os.path.join(home, "Movies")     # Fallback
                ]
                for path in alt_paths:
                    if os.path.exists(path):
                        return path
            return videos_path
        else:  # Linux
            try:
                result = subprocess.run(["xdg-user-dir", "VIDEOS"], capture_output=True, text=True, check=True)
                return result.stdout.strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                return os.path.join(home, "Videos")
    """
    Cross-platform utility functions for better OS compatibility
    
    CROSS-PLATFORM IMPROVEMENTS MADE:
    =================================
    
    1. Platform Detection:
       - Unified platform detection using platform.system()
       - Support for Windows, macOS, Linux, and other Unix-like systems
       
    2. File Operations:
       - Cross-platform file opening with default applications
       - Platform-specific file manager reveal functionality
       - Improved safety checks for different file systems
       
    3. Terminal Integration:
       - Windows: Support for Windows Terminal, cmd, PowerShell
       - macOS: Terminal.app integration via AppleScript
       - Linux: Auto-detection of common terminal emulators
       
    4. Keyboard Shortcuts:
       - macOS: Cmd-based shortcuts (Cmd+C, Cmd+V, etc.)
       - Windows/Linux: Ctrl-based shortcuts
       - Platform-appropriate window management shortcuts
       
    5. Trash/Recycle Bin Support:
       - Windows: PowerShell-based Recycle Bin support
       - macOS: AppleScript Finder integration
       - Linux: gio trash command support
       - Fallback to send2trash library if available
       
    6. Path Handling:
       - Cross-platform user directory detection
       - XDG compliance on Linux for Documents, Downloads, Desktop
       - Windows and macOS standard folder locations
       
    7. File System Filtering:
       - macOS: Filter out .DS_Store and resource fork files
       - Windows: Filter out Thumbs.db and desktop.ini
       - Linux: Standard hidden file handling
       
    8. Application Integration:
       - High DPI support for all platforms
       - Platform-specific application properties
       - Proper window management and taskbar integration
    """
    
    @staticmethod
    def get_platform():
        """Get the current platform in a standardized way"""
        system = platform.system().lower()
        if system == 'windows':
            return 'windows'
        elif system == 'darwin':
            return 'macos'
        elif system in ('linux', 'freebsd', 'openbsd', 'netbsd'):
            return 'linux'
        else:
            return 'unknown'
    
    @staticmethod
    def is_windows():
        """Check if running on Windows"""
        return PlatformUtils.get_platform() == 'windows'
    
    @staticmethod
    def is_macos():
        """Check if running on macOS"""
        return PlatformUtils.get_platform() == 'macos'
    
    @staticmethod
    def is_linux():
        """Check if running on Linux/Unix"""
        return PlatformUtils.get_platform() == 'linux'
    
    @staticmethod
    def get_modifier_key():
        """Get the primary modifier key for the platform"""
        return "Cmd" if PlatformUtils.is_macos() else "Ctrl"
    
    @staticmethod
    def get_alt_modifier_key():
        """Get the alternative modifier key for the platform"""
        return "Cmd" if PlatformUtils.is_macos() else "Alt"
    
    @staticmethod
    def detect_system_dark_mode():
        """Detect if the system is using dark mode (macOS specific)"""
        if not PlatformUtils.is_macos():
            return False
        
        try:
            # Check macOS system appearance
            result = subprocess.run([
                'defaults', 'read', '-g', 'AppleInterfaceStyle'
            ], capture_output=True, text=True, timeout=5)
            
            # If the command succeeds and returns "Dark", system is in dark mode
            return result.returncode == 0 and 'Dark' in result.stdout.strip()
        except Exception:
            # If any error occurs, assume light mode
            return False
    
    @staticmethod
    def get_macos_accent_color():
        """Get macOS system accent color"""
        if not PlatformUtils.is_macos():
            return None
        
        try:
            result = subprocess.run([
                'defaults', 'read', '-g', 'AppleAccentColor'
            ], capture_output=True, text=True, timeout=5)
            
            if result.returncode == 0:
                color_code = result.stdout.strip()
                # Convert macOS color codes to CSS colors
                accent_colors = {
                    '-1': '#007AFF',  # Blue (default)
                    '0': '#FF3B30',   # Red
                    '1': '#FF9500',   # Orange  
                    '2': '#FFCC00',   # Yellow
                    '3': '#34C759',   # Green
                    '4': '#007AFF',   # Blue
                    '5': '#5856D6',   # Purple
                    '6': '#FF2D92',   # Pink
                }
                return accent_colors.get(color_code, '#007AFF')
        except Exception:
            pass
        
        return '#007AFF'  # Default blue
    
    @staticmethod
    def get_navigation_modifier():
        """Get the navigation modifier key (for back/forward)"""
        return "Cmd" if PlatformUtils.is_macos() else "Alt"
    
    @staticmethod
    def setup_macos_window_behavior(window):
        """Setup macOS-specific window behavior"""
        if not PlatformUtils.is_macos():
            return
        
        try:
            # Enable window restoration
            window.setProperty("NSWindowRestorationFrameAutosaveName", "MainWindow")
            
            # Set proper window flags for macOS
            window.setWindowFlags(window.windowFlags() | Qt.WindowFullscreenButtonHint)
            
            # Enable native macOS title bar behavior if possible
            try:
                from PyQt5.QtMacExtras import QMacToolBar
                # This would require QtMacExtras, which might not be available
                # So we'll just continue without it
            except ImportError:
                pass
                
        except Exception as e:
            pass
    
    @staticmethod
    def open_file_with_default_app(file_path):
        """Open a file with the default system application"""
        try:
            if PlatformUtils.is_windows():
                os.startfile(file_path)
            elif PlatformUtils.is_macos():
                subprocess.run(["open", file_path], check=True)
            else:  # Linux/Unix
                subprocess.run(["xdg-open", file_path], check=True)
            return True
        except (subprocess.CalledProcessError, OSError, FileNotFoundError) as e:
            print(f"Error opening file {file_path}: {e}")
            return False
    
    @staticmethod
    def reveal_in_file_manager(file_path):
        """Reveal/show a file or folder in the system file manager"""
        try:
            if PlatformUtils.is_windows():
                # Use Windows Explorer to select the file
                subprocess.run(["explorer", "/select,", file_path], check=True)
            elif PlatformUtils.is_macos():
                # Use Finder to reveal the file
                subprocess.run(["open", "-R", file_path], check=True)
            else:  # Linux/Unix
                # Try different file managers
                file_managers = [
                    ["nautilus", "--select", file_path],  # GNOME
                    ["dolphin", "--select", file_path],   # KDE
                    ["thunar", file_path],                # XFCE
                    ["pcmanfm", file_path],               # LXDE
                    ["xdg-open", os.path.dirname(file_path)]  # Fallback
                ]
                
                for fm_cmd in file_managers:
                    try:
                        subprocess.run(fm_cmd, check=True)
                        break
                    except (subprocess.CalledProcessError, FileNotFoundError):
                        continue
            return True
        except Exception as e:
            print(f"Error revealing file {file_path}: {e}")
            return False
    
    @staticmethod
    def open_terminal_at_path(path):
        """Open system terminal at the specified path"""
        try:
            if os.path.isfile(path):
                path = os.path.dirname(path)
            
            if PlatformUtils.is_windows():
                # Try Windows Terminal first, then fall back to cmd
                try:
                    subprocess.Popen(["wt", "-d", path], shell=True)
                except FileNotFoundError:
                    # Fall back to Command Prompt
                    subprocess.Popen(["cmd"], cwd=path, shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE)
            elif PlatformUtils.is_macos():
                # Use AppleScript to open Terminal with better error handling and options
                try:
                    # Try modern Terminal.app AppleScript first
                    script = f'''
                    tell application "Terminal"
                        activate
                        do script "cd {shlex.quote(path)}"
                    end tell
                    '''
                    subprocess.run(["osascript", "-e", script], check=True)
                except Exception as terminal_error:
                    try:
                        # Fallback to iTerm2 if available
                        iterm_script = f'''
                        tell application "iTerm"
                            create window with default profile
                            tell current session of current window
                                write text "cd {shlex.quote(path)}"
                            end tell
                        end tell
                        '''
                        subprocess.run(["osascript", "-e", iterm_script], check=True)
                    except Exception:
                        # Final fallback to simple open command
                        subprocess.run(["open", "-a", "Terminal", path], check=True)
            else:  # Linux/Unix
                # Try different terminal emulators
                terminals = [
                    ["gnome-terminal", "--working-directory", path],
                    ["konsole", "--workdir", path],
                    ["xfce4-terminal", "--working-directory", path],
                    ["lxterminal", "--working-directory", path],
                    ["mate-terminal", "--working-directory", path],
                    ["terminator", "--working-directory", path],
                    ["xterm", "-cd", path],
                    ["urxvt", "-cd", path]
                ]
                
                for term_cmd in terminals:
                    try:
                        subprocess.Popen(term_cmd, cwd=path)
                        break
                    except FileNotFoundError:
                        continue
                else:
                    raise FileNotFoundError("No suitable terminal emulator found")
            return True
        except Exception as e:
            print(f"Error opening terminal at {path}: {e}")
            return False
    
    @staticmethod
    def get_trash_command():
        """Get the appropriate command to move files to trash"""
        if PlatformUtils.is_windows():
            return None  # Will use send2trash library or manual implementation
        elif PlatformUtils.is_macos():
            # Try multiple macOS trash methods
            return ["osascript", "-e", "tell app \"Finder\" to delete POSIX file"]  # Built-in AppleScript method
        else:  # Linux
            return ["gio", "trash"]  # Modern Linux systems
    
    @staticmethod
    def get_home_directory():
        """Get user's home directory in a cross-platform way"""
        return os.path.expanduser("~")
    
    @staticmethod
    def get_documents_directory():
        """Get user's documents directory"""
        home = PlatformUtils.get_home_directory()
        if PlatformUtils.is_windows():
            return os.path.join(home, "Documents")
        elif PlatformUtils.is_macos():
            # Use macOS standard Documents folder
            docs_path = os.path.join(home, "Documents")
            # Also check for localized versions
            if not os.path.exists(docs_path):
                # Try alternative paths on macOS
                alt_paths = [
                    os.path.join(home, "Documents"),
                    os.path.join(home, "Documentos"),  # Spanish
                    os.path.join(home, "Documents")    # Fallback
                ]
                for path in alt_paths:
                    if os.path.exists(path):
                        return path
            return docs_path
        else:  # Linux
            # Try XDG user dirs first
            try:
                result = subprocess.run(["xdg-user-dir", "DOCUMENTS"], 
                                      capture_output=True, text=True, check=True)
                return result.stdout.strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                return os.path.join(home, "Documents")
    
    @staticmethod
    def get_downloads_directory():
        """Get user's downloads directory"""
        home = PlatformUtils.get_home_directory()
        if PlatformUtils.is_windows():
            return os.path.join(home, "Downloads")
        elif PlatformUtils.is_macos():
            # Use macOS standard Downloads folder
            downloads_path = os.path.join(home, "Downloads")
            # Also check for localized versions
            if not os.path.exists(downloads_path):
                # Try alternative paths on macOS
                alt_paths = [
                    os.path.join(home, "Downloads"),
                    os.path.join(home, "Descargas"),   # Spanish
                    os.path.join(home, "Téléchargements"),  # French
                    os.path.join(home, "Downloads")    # Fallback
                ]
                for path in alt_paths:
                    if os.path.exists(path):
                        return path
            return downloads_path
        else:  # Linux
            # Try XDG user dirs first
            try:
                result = subprocess.run(["xdg-user-dir", "DOWNLOAD"], 
                                      capture_output=True, text=True, check=True)
                return result.stdout.strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                return os.path.join(home, "Downloads")
    
    @staticmethod
    def get_desktop_directory():
        """Get user's desktop directory"""
        home = PlatformUtils.get_home_directory()
        if PlatformUtils.is_windows():
            return os.path.join(home, "Desktop")
        elif PlatformUtils.is_macos():
            # Use macOS standard Desktop folder with localization support
            desktop_path = os.path.join(home, "Desktop")
            if not os.path.exists(desktop_path):
                # Try alternative paths on macOS for different languages
                alt_paths = [
                    os.path.join(home, "Desktop"),
                    os.path.join(home, "Escritorio"),  # Spanish
                    os.path.join(home, "Bureau"),      # French
                    os.path.join(home, "Schreibtisch"), # German
                    os.path.join(home, "Desktop")      # Fallback
                ]
                for path in alt_paths:
                    if os.path.exists(path):
                        return path
            return desktop_path
        else:  # Linux
            try:
                result = subprocess.run(["xdg-user-dir", "DESKTOP"], 
                                      capture_output=True, text=True, check=True)
                return result.stdout.strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                return os.path.join(home, "Desktop")
                result = subprocess.run(["xdg-user-dir", "DESKTOP"], 
                                      capture_output=True, text=True, check=True)
                return result.stdout.strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                return os.path.join(home, "Desktop")

# Performance & Memory Optimization Classes
class ThumbnailCache:
    """Persistent disk-based thumbnail cache for performance optimization with thread safety"""
    
    def __init__(self, cache_dir=None):
        import sys, os
        if sys.platform == 'darwin' and not cache_dir:
            home = os.path.expanduser('~')
            forced_dir = os.path.join(home, '.garysfm_thumbnails')
            try:
                os.makedirs(forced_dir, exist_ok=True)
            except Exception:
                forced_dir = '/tmp/garysfm_thumbnails'
                os.makedirs(forced_dir, exist_ok=True)
            self.cache_dir = forced_dir
        else:
            self.cache_dir = cache_dir or os.path.join(tempfile.gettempdir(), 'garysfm_thumbnails')
        self.memory_cache = OrderedDict()  # LRU cache in memory
        self.max_memory_cache = 200  # Reduced from 500 to 200 for better memory usage
        self.cleanup_started = False  # Flag to track cleanup thread
        
        # Add thread safety with lock
        import threading
        self._lock = threading.RLock()  # Reentrant lock for nested calls
        
        os.makedirs(self.cache_dir, exist_ok=True)
        
        # Cache metadata file
        self.metadata_file = os.path.join(self.cache_dir, 'cache_metadata.json')
        self.metadata = self._load_metadata()
        
        # Don't start cleanup thread automatically to avoid exit hanging
        # self._start_cleanup_thread()
    
    def _load_metadata(self):
        """Load cache metadata from disk"""
        try:
            with open(self.metadata_file, 'r') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return {}
    
    def _save_metadata(self):
        """Save cache metadata to disk"""
        try:
            # Write atomically to avoid partial writes from concurrent processes
            import tempfile
            dirp = os.path.dirname(self.metadata_file)
            fd, tmp_path = tempfile.mkstemp(dir=dirp)
            try:
                # Sanitize metadata into JSON-serializable structures (string keys, simple values)
                def _sanitize(obj):
                    # Primitive types allowed as-is
                    if obj is None or isinstance(obj, (str, int, float, bool)):
                        return obj
                    if isinstance(obj, dict):
                        out = {}
                        # Iterate over a snapshot of items to avoid runtime errors if dict is mutated concurrently
                        for k, v in list(obj.items()):
                            try:
                                ks = str(k)
                            except Exception:
                                ks = repr(k)
                            out[ks] = _sanitize(v)
                        return out
                    if isinstance(obj, (list, tuple, set)):
                        return [_sanitize(i) for i in obj]
                    # Fallback: try to JSON-encode, otherwise use repr()
                    try:
                        json.dumps(obj)
                        return obj
                    except Exception:
                        return repr(obj)

                # Copy metadata under lock to get a stable snapshot for serialization
                try:
                    with getattr(self, '_lock'):
                        meta_snapshot = dict(self.metadata)
                except Exception:
                    # Fallback if lock not present or copying fails
                    try:
                        meta_snapshot = dict(self.metadata)
                    except Exception:
                        meta_snapshot = {}

                safe_meta = _sanitize(meta_snapshot)
                with os.fdopen(fd, 'w', encoding='utf-8') as f:
                    json.dump(safe_meta, f, ensure_ascii=False, indent=2)
                # Atomic replace - try os.replace, but fall back to shutil.move or copy on failure
                try:
                    os.replace(tmp_path, self.metadata_file)
                except Exception:
                    logging.getLogger(__name__).warning('atomic replace failed for %s -> %s, attempting fallback', tmp_path, self.metadata_file)
                    try:
                        import shutil
                        shutil.move(tmp_path, self.metadata_file)
                    except Exception:
                        logging.getLogger(__name__).warning('shutil.move fallback failed, attempting file copy', exc_info=True)
                        try:
                            # Last-resort: copy file contents into target path
                            with open(tmp_path, 'rb') as src, open(self.metadata_file, 'wb') as dst:
                                data = src.read()
                                dst.write(data)
                                try:
                                    dst.flush()
                                    os.fsync(dst.fileno())
                                except Exception:
                                    pass
                        except Exception:
                            logging.getLogger(__name__).exception('Failed to persist metadata via any fallback')
            finally:
                try:
                    if os.path.exists(tmp_path):
                        os.remove(tmp_path)
                except Exception:
                    pass
        except Exception:
            logging.getLogger(__name__).exception('Failed to save thumbnail cache metadata')
    
    def _start_cleanup_thread(self):
        """Start background thread to clean old cache files"""
        def cleanup_old_files():
            try:
                cutoff_time = time.time() - (7 * 24 * 3600)  # 7 days ago
                for filename in os.listdir(self.cache_dir):
                    if filename.endswith('.thumb'):
                        filepath = os.path.join(self.cache_dir, filename)
                        if os.path.getmtime(filepath) < cutoff_time:
                            os.remove(filepath)
                            # Remove from metadata
                            key = filename[:-6]  # Remove .thumb extension
                            if key in self.metadata:
                                del self.metadata[key]
                self._save_metadata()
            except Exception:
                pass  # Fail silently for cleanup
        
        cleanup_thread = threading.Thread(target=cleanup_old_files, daemon=True)
        cleanup_thread.start()
    
    def get_cache_key(self, file_path, size, debug_label=None):
        """Generate cache key for file path and size, using normalized absolute path (and realpath on macOS)"""
        import os, sys
        # Always use realpath on macOS to resolve symlinks, and abspath/normcase everywhere
        if sys.platform == 'darwin':
            norm_path = os.path.normcase(os.path.abspath(os.path.realpath(file_path)))
        else:
            norm_path = os.path.normcase(os.path.abspath(file_path))
        # Debug label removed for less verbosity
        path_hash = hashlib.md5(norm_path.encode('utf-8')).hexdigest()
        return f"{path_hash}_{size}"
    
    def get(self, file_path, size):
        logger = logging.getLogger('thumbnail')
        logger.debug("get: %s size=%s", file_path, size)
        """Get cached thumbnail as PNG bytes and reconstruct QPixmap"""
        cache_key = self.get_cache_key(file_path, size, debug_label='GET')
        logger.debug("get_cache_key: %s", cache_key)
        with self._lock:
            if cache_key in self.memory_cache:
                logger.debug('Memory cache hit for %s', cache_key)
                self.memory_cache.move_to_end(cache_key)
                png_bytes = self.memory_cache[cache_key]
                return self._pixmap_from_png_bytes(png_bytes)
        cache_file = os.path.join(self.cache_dir, f"{cache_key}.thumb")
        logger.debug('cache_file: %s', cache_file)
        try:
            dir_listing = os.listdir(self.cache_dir)
        except Exception as e:
            if GLOBAL_DEBUG_ENABLED:
                print(f'[CACHE] Could not list directory {self.cache_dir}: {e}')
        
        # On macOS, use directory listing check instead of os.path.exists due to path encoding issues
        expected_filename = f"{cache_key}.thumb"
        file_exists = os.path.exists(cache_file)
        file_in_listing = False
        try:
            dir_listing = os.listdir(self.cache_dir)
            file_in_listing = expected_filename in dir_listing
        except Exception:
            pass
        
        if GLOBAL_DEBUG_ENABLED:
            print(f'[CACHE] {cache_file} {"found" if cache_file_found else "not found"}')
        
        # Use directory listing check on macOS, os.path.exists elsewhere
        import sys
        cache_file_found = file_in_listing if sys.platform == 'darwin' else file_exists
        
        if cache_file_found:
            logger.debug('Disk cache hit for %s', cache_file)
            try:
                # Guard file_mtime lookup: file_path may not exist locally (remote/iso)
                file_mtime = os.path.getmtime(file_path) if os.path.exists(file_path) else 0
                with self._lock:
                    cache_meta = self.metadata.get(cache_key, {})
                cache_mtime = cache_meta.get('mtime', 0)
                logging.getLogger('thumbnail').debug('file_mtime=%s, cache_mtime=%s for %s', file_mtime, cache_mtime, file_path)
                if not cache_meta:
                    logging.getLogger('thumbnail').debug('No metadata for %s (file: %s)', cache_key, file_path)
                
                # Optimized cache staleness check with grace period and extended validity
                import sys
                import time
                file_ext = os.path.splitext(file_path)[1].lower()
                current_time = time.time()
                
                # Video files on macOS - skip staleness check (existing optimization)
                is_video_file = False
                if sys.platform == 'darwin':
                    video_extensions = {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v'}
                    is_video_file = file_ext in video_extensions
                
                # Check if this is a stable file type that rarely changes
                is_stable_file = file_ext in STABLE_FILE_EXTENSIONS
                
                # Get cache creation time for extended validity check
                cache_created = cache_meta.get('created', 0)
                cache_age_hours = (current_time - cache_created) / 3600 if cache_created > 0 else float('inf')
                
                cache_is_valid = False
                if is_video_file:
                    # For video files on macOS, always consider cache valid if it exists
                    cache_is_valid = True
                    logging.getLogger('thumbnail').debug('Video file on macOS - skipping staleness check for %s', file_path)
                elif is_stable_file and cache_age_hours < EXTENDED_CACHE_VALIDITY_HOURS:
                    # For stable file types (images, PDFs), use extended cache validity
                    cache_is_valid = True
                    logging.getLogger('thumbnail').debug('Stable file type with extended validity for %s (age: %.1f hours)', file_path, cache_age_hours)
                else:
                    # Normal staleness check with grace period
                    time_diff = file_mtime - cache_mtime
                    if time_diff <= CACHE_GRACE_PERIOD_SECONDS:
                        cache_is_valid = True
                        if GLOBAL_DEBUG_ENABLED:
                            logging.getLogger('thumbnail').debug('Cache valid with grace period for %s (diff: %.1f seconds)', file_path, time_diff)
                    else:
                        cache_is_valid = file_mtime <= cache_mtime
                        if GLOBAL_DEBUG_ENABLED:
                            logging.getLogger('thumbnail').debug('Traditional staleness check for %s (valid: %s)', file_path, cache_is_valid)
                
                if cache_is_valid:
                    logging.getLogger('thumbnail').debug('Cache is valid for %s', file_path)
                    try:
                        with open(cache_file, 'rb') as f:
                            png_bytes = f.read()
                        logging.getLogger('thumbnail').debug('Read %d bytes from cache file for %s', len(png_bytes), file_path)
                        self._add_to_memory_cache(cache_key, png_bytes)
                        return self._pixmap_from_png_bytes(png_bytes)
                    except Exception as e:
                        logging.getLogger('thumbnail').exception('Exception reading cache file for %s: %s', file_path, e)
                else:
                    logging.getLogger('thumbnail').debug('Cache is stale for %s', file_path)
            except Exception as e:
                logging.getLogger('thumbnail').exception('Exception in get() for %s: %s', file_path, e)
        else:
            logging.getLogger('thumbnail').debug('No cache file found for %s', file_path)
        return None

    def is_cached(self, file_path, size):
        """Quick check whether a thumbnail exists and is up-to-date for file_path at size.
        This is a fast, read-only check that avoids loading the thumbnail bytes.
        Returns True if cached and fresh, False otherwise.
        """
        try:
            cache_key = self.get_cache_key(file_path, size)
            with self._lock:
                if cache_key in self.memory_cache:
                    return True
            cache_file = os.path.join(self.cache_dir, f"{cache_key}.thumb")
            
            # On macOS, use directory listing check instead of os.path.exists due to path encoding issues
            import sys
            if sys.platform == 'darwin':
                try:
                    dir_listing = os.listdir(self.cache_dir)
                    expected_filename = f"{cache_key}.thumb"
                    if expected_filename not in dir_listing:
                        return False
                except Exception:
                    return False
            else:
                if not os.path.exists(cache_file):
                    return False
            
            try:
                # Guard file_mtime lookup: file_path may not exist locally (remote/iso)
                file_mtime = os.path.getmtime(file_path) if os.path.exists(file_path) else 0
                with self._lock:
                    cache_meta = self.metadata.get(cache_key, {})
                cache_mtime = cache_meta.get('mtime', 0)
                
                # Optimized cache staleness check with grace period and extended validity
                import time
                file_ext = os.path.splitext(file_path)[1].lower()
                current_time = time.time()
                
                # Video files on macOS - skip staleness check (existing optimization)
                is_video_file = False
                if sys.platform == 'darwin':
                    video_extensions = {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v'}
                    is_video_file = file_ext in video_extensions
                
                # Check if this is a stable file type that rarely changes
                is_stable_file = file_ext in STABLE_FILE_EXTENSIONS
                
                # Get cache creation time for extended validity check
                cache_created = cache_meta.get('created', 0)
                cache_age_hours = (current_time - cache_created) / 3600 if cache_created > 0 else float('inf')
                
                if is_video_file:
                    # For video files on macOS, always consider cache valid if it exists
                    return True
                elif is_stable_file and cache_age_hours < EXTENDED_CACHE_VALIDITY_HOURS:
                    # For stable file types (images, PDFs), use extended cache validity
                    return True
                else:
                    # Normal staleness check with grace period
                    time_diff = file_mtime - cache_mtime
                    if time_diff <= CACHE_GRACE_PERIOD_SECONDS:
                        return True
                    else:
                        return file_mtime <= cache_mtime
            except Exception:
                return False
        except Exception:
            return False

    def _pixmap_from_png_bytes(self, png_bytes):
        from PyQt5.QtCore import QByteArray
        pixmap = QPixmap()
        pixmap.loadFromData(QByteArray(png_bytes), 'PNG')
        return pixmap
    
    def put(self, file_path, size, thumbnail_data):
        logger = logging.getLogger('thumbnail')
        logger.debug('put: %s size=%s', file_path, size)
        """Store thumbnail as PNG bytes in cache with thread safety"""
        from PyQt5.QtCore import QBuffer, QByteArray
        import time
        cache_key = self.get_cache_key(file_path, size, debug_label='PUT')
        logger.debug('put_cache_key: %s', cache_key)
        # Accept either QPixmap or PNG bytes
        if isinstance(thumbnail_data, QPixmap):
            buffer = QBuffer()
            buffer.open(QBuffer.ReadWrite)
            thumbnail_data.save(buffer, 'PNG')
            png_bytes = buffer.data().data()
            buffer.close()
        elif isinstance(thumbnail_data, (bytes, bytearray)):
            png_bytes = bytes(thumbnail_data)
        else:
            logger.warning('Unsupported thumbnail_data type: %s', type(thumbnail_data))
            return
        logger.debug('Writing %d bytes to cache for %s size=%s', len(png_bytes), file_path, size)
        self._add_to_memory_cache(cache_key, png_bytes)
        try:
            cache_file = os.path.join(self.cache_dir, f"{cache_key}.thumb")
            logger.info('Writing thumbnail to: %s', cache_file)
            with open(cache_file, 'wb') as f:
                f.write(png_bytes)
            logger.info('Thumbnail cached: %s (%d bytes)', cache_file, len(png_bytes))
            
            # Store metadata with both mtime and creation timestamp for optimized staleness checking
            file_mtime = os.path.getmtime(file_path) if os.path.exists(file_path) else time.time()
            with self._lock:
                self.metadata[cache_key] = {
                    'mtime': file_mtime,
                    'created': time.time()
                }
            self._save_metadata()
        except Exception as e:
            logger.error('Failed to cache thumbnail: %s', e)
    
    def _add_to_memory_cache(self, key, value):
        """Add item to memory cache with LRU eviction and thread safety"""
        with self._lock:  # Thread-safe access to cache
            if key in self.memory_cache:
                self.memory_cache.move_to_end(key)
            else:
                self.memory_cache[key] = value
                # Remove oldest items if cache is full
                while len(self.memory_cache) > self.max_memory_cache:
                    self.memory_cache.popitem(last=False)
    
    def clear_memory_cache(self):
        """Clear the in-memory cache with thread safety"""
        with self._lock:
            self.memory_cache.clear()
    
    def cleanup(self):
        """Clean up cache resources and memory"""
        try:
            self.memory_cache.clear()
            import gc
            gc.collect()
        except Exception:
            pass

class BookmarkManager:
    """
    Manages bookmarks/favorites for the file manager.
    Provides functionality to add, remove, organize, and persist bookmarks.
    """
    
    def __init__(self, config_dir=None):
        """Initialize the bookmark manager"""
        import os
        import tempfile
        
        # Determine config directory
        if config_dir:
            self.config_dir = config_dir
        else:
            # Use platform-appropriate config directory
            if PlatformUtils.is_windows():
                self.config_dir = os.path.join(os.path.expanduser("~"), "AppData", "Local", "garysfm")
            elif PlatformUtils.is_macos():
                self.config_dir = os.path.join(os.path.expanduser("~"), "Library", "Application Support", "garysfm")
            else:  # Linux
                self.config_dir = os.path.join(os.path.expanduser("~"), ".config", "garysfm")
        
        # Ensure config directory exists
        try:
            os.makedirs(self.config_dir, exist_ok=True)
        except Exception:
            # Fallback to temp directory
            self.config_dir = os.path.join(tempfile.gettempdir(), "garysfm")
            os.makedirs(self.config_dir, exist_ok=True)
        
        self.bookmarks_file = os.path.join(self.config_dir, "bookmarks.json")
        self.bookmarks = []
        self.load_bookmarks()
    
    def load_bookmarks(self):
        """Load bookmarks from disk"""
        try:
            if os.path.exists(self.bookmarks_file):
                with open(self.bookmarks_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.bookmarks = data.get('bookmarks', [])
                    # Validate bookmarks format
                    for bookmark in self.bookmarks[:]:  # Copy to avoid modification during iteration
                        if not isinstance(bookmark, dict) or 'name' not in bookmark or 'path' not in bookmark:
                            self.bookmarks.remove(bookmark)
            else:
                # Create default bookmarks
                self.create_default_bookmarks()
        except Exception as e:
            if GLOBAL_DEBUG_ENABLED:
                print(f"[BOOKMARKS] Error loading bookmarks: {e}")
            self.create_default_bookmarks()
    
    def create_default_bookmarks(self):
        """Create default bookmarks for common directories"""
        self.bookmarks = []
        
        # Add common user directories
        try:
            home = PlatformUtils.get_home_directory()
            desktop = PlatformUtils.get_desktop_directory()
            documents = PlatformUtils.get_documents_directory()
            downloads = PlatformUtils.get_downloads_directory()
            pictures = PlatformUtils.get_pictures_directory()
            music = PlatformUtils.get_music_directory()
            videos = PlatformUtils.get_videos_directory()
            
            default_bookmarks = [
                {"name": "🏠 Home", "path": home},
                {"name": "🖥️ Desktop", "path": desktop},
                {"name": "📄 Documents", "path": documents},
                {"name": "📥 Downloads", "path": downloads},
                {"name": "🖼️ Pictures", "path": pictures},
                {"name": "🎵 Music", "path": music},
                {"name": "🎬 Videos", "path": videos},
            ]
            
            # Only add directories that actually exist
            for bookmark in default_bookmarks:
                if os.path.exists(bookmark["path"]):
                    self.bookmarks.append(bookmark)
            
            # Add system drives on Windows
            if PlatformUtils.is_windows():
                import string
                for drive in string.ascii_uppercase:
                    drive_path = f"{drive}:\\"
                    if os.path.exists(drive_path):
                        self.bookmarks.append({"name": f"💾 Drive {drive}:", "path": drive_path})
            
        except Exception as e:
            if GLOBAL_DEBUG_ENABLED:
                print(f"[BOOKMARKS] Error creating default bookmarks: {e}")
        
        self.save_bookmarks()
    
    def save_bookmarks(self):
        """Save bookmarks to disk"""
        try:
            data = {
                "version": "1.0",
                "bookmarks": self.bookmarks
            }
            with open(self.bookmarks_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            if GLOBAL_DEBUG_ENABLED:
                print(f"[BOOKMARKS] Error saving bookmarks: {e}")
    
    def add_bookmark(self, name, path):
        """Add a new bookmark"""
        # Normalize the path
        path = os.path.normpath(os.path.abspath(path))
        
        # Check if bookmark already exists
        for bookmark in self.bookmarks:
            if bookmark["path"] == path:
                if GLOBAL_DEBUG_ENABLED:
                    print(f"[BOOKMARKS] Bookmark already exists: {path}")
                return False
        
        # Add the bookmark
        bookmark = {"name": name, "path": path}
        self.bookmarks.append(bookmark)
        self.save_bookmarks()
        
        if GLOBAL_DEBUG_ENABLED:
            print(f"[BOOKMARKS] Added bookmark: {name} -> {path}")
        return True
    
    def remove_bookmark(self, path):
        """Remove a bookmark by path"""
        path = os.path.normpath(os.path.abspath(path))
        
        for i, bookmark in enumerate(self.bookmarks):
            if bookmark["path"] == path:
                removed = self.bookmarks.pop(i)
                self.save_bookmarks()
                if GLOBAL_DEBUG_ENABLED:
                    print(f"[BOOKMARKS] Removed bookmark: {removed['name']}")
                return True
        
        return False
    
    def remove_bookmark_by_index(self, index):
        """Remove a bookmark by index"""
        if 0 <= index < len(self.bookmarks):
            removed = self.bookmarks.pop(index)
            self.save_bookmarks()
            if GLOBAL_DEBUG_ENABLED:
                print(f"[BOOKMARKS] Removed bookmark: {removed['name']}")
            return True
        return False
    
    def get_bookmarks(self):
        """Get all bookmarks"""
        return self.bookmarks.copy()
    
    def is_bookmarked(self, path):
        """Check if a path is bookmarked"""
        path = os.path.normpath(os.path.abspath(path))
        for bookmark in self.bookmarks:
            if bookmark["path"] == path:
                return True
        return False
    
    def get_bookmark_name(self, path):
        """Get the name of a bookmark by path"""
        path = os.path.normpath(os.path.abspath(path))
        for bookmark in self.bookmarks:
            if bookmark["path"] == path:
                return bookmark["name"]
        return None
    
    def move_bookmark(self, from_index, to_index):
        """Move a bookmark from one position to another"""
        if 0 <= from_index < len(self.bookmarks) and 0 <= to_index < len(self.bookmarks):
            bookmark = self.bookmarks.pop(from_index)
            self.bookmarks.insert(to_index, bookmark)
            self.save_bookmarks()
            return True
        return False
    
    def rename_bookmark(self, path, new_name):
        """Rename a bookmark"""
        path = os.path.normpath(os.path.abspath(path))
        for bookmark in self.bookmarks:
            if bookmark["path"] == path:
                bookmark["name"] = new_name
                self.save_bookmarks()
                return True
        return False

class VirtualFileLoader:
    """Virtual file loader for large directories with lazy loading"""
    
    def __init__(self, chunk_size=100):
        self.chunk_size = chunk_size
        self.loaded_chunks = {}
        self.total_items = 0
        self.directory_cache = {}
        self.executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix="FileLoader")
    
    def load_directory_async(self, directory_path, callback, sort_func=None):
        """Load directory contents asynchronously in chunks"""
        def load_worker():
            try:
                if not os.path.exists(directory_path):
                    callback([], True)  # Empty list, done
                    return

                # Get all items
                try:
                    # Clear caches first
                    if hasattr(self, 'loaded_chunks'):
                        self.loaded_chunks.clear()
                    if hasattr(self, 'directory_cache'):
                        self.directory_cache.clear()
                    # Shutdown executor with timeout
                    if hasattr(self, 'executor') and self.executor:
                        try:
                            # Cancel all pending futures
                            self.executor.shutdown(wait=False)
                            import time
                            time.sleep(0.1)
                        except Exception as e:
                            print(f"Error shutting down executor: {e}")
                            try:
                                self.executor.shutdown(wait=False)
                            except:
                                pass
                except Exception as e:
                    print(f"Error during VirtualFileLoader cleanup: {e}")

                # Build the items list (was missing, causing 'items' undefined errors)
                try:
                    import time
                    # Include full paths for items for consistency with other loaders
                    items = [os.path.join(directory_path, name) for name in os.listdir(directory_path)]
                    if sort_func:
                        try:
                            items = sorted(items, key=sort_func)
                        except Exception:
                            items = sorted(items)
                    else:
                        items = sorted(items)
                except Exception as e:
                    print(f"[VirtualFileLoader] Failed to list directory {directory_path}: {e}")
                    callback([], True)
                    return

                # Send items in chunks
                for i in range(0, len(items), self.chunk_size):
                    chunk = items[i:i + self.chunk_size]
                    chunk_index = i // self.chunk_size
                    self.loaded_chunks[chunk_index] = chunk

                    # Call callback with chunk and completion status
                    is_complete = (i + self.chunk_size) >= len(items)
                    callback(chunk, is_complete)

                    # Small delay to prevent UI blocking
                    time.sleep(0.001)

            except Exception as e:
                callback([], True)  # Error occurred, return empty
        
        future = self.executor.submit(load_worker)
        return future
    
    def get_chunk(self, chunk_index):
        """Get a specific chunk by index"""
        return self.loaded_chunks.get(chunk_index, [])
    
    def cleanup(self):
        """Clean up resources with improved shutdown handling"""
        try:
            # ...removed debug print...
            
            # Clear caches first
            if hasattr(self, 'loaded_chunks'):
                self.loaded_chunks.clear()
            if hasattr(self, 'directory_cache'):
                self.directory_cache.clear()
            
            # Shutdown executor with timeout
            if hasattr(self, 'executor') and self.executor:
                try:
                    # ...removed debug print...
                    # Cancel all pending futures
                    self.executor.shutdown(wait=False)
                    
                    # Give it a moment to shut down gracefully
                    import time
                    time.sleep(0.1)
                    
                    # ...removed debug print...
                except Exception as e:
                    print(f"Error shutting down executor: {e}")
                    # Force shutdown if graceful fails
                    try:
                        self.executor.shutdown(wait=False)
                    except:
                        pass
                        
            # ...removed debug print...
            
        except Exception as e:
            print(f"Error during VirtualFileLoader cleanup: {e}")

class MemoryManager:
    """Memory usage optimization and automatic garbage collection"""
    def add_cleanup_callback(self, callback):
        """Register a callback to be called during memory cleanup."""
        self.cleanup_callbacks.append(callback)
    
    def __init__(self, check_interval=30):
        self.check_interval = check_interval
        self.last_cleanup = time.time()
        self.memory_threshold = 150 * 1024 * 1024  # Reduced from 200MB to 150MB for more aggressive cleanup
        self.cleanup_callbacks = []
        self.running = True  # Add running flag for clean shutdown
        self.monitor_thread = None  # Keep reference to thread
        
        # Start memory monitoring thread
        self._start_monitoring_thread()
    
    def _start_monitoring_thread(self):
        """Start background memory monitoring with leak detection"""
        def monitor_memory():
            while self.running:  # Check running flag instead of infinite loop
                try:
                    import psutil
                    process = psutil.Process()
                    memory_usage = process.memory_info().rss
                    memory_mb = memory_usage / 1024 / 1024
                    
                    # Check for memory threshold breach
                    if memory_usage > self.memory_threshold:
                        # ...removed debug print...
                        self.force_cleanup()
                    
                    # Regular cleanup every interval
                    if time.time() - self.last_cleanup > self.check_interval:
                        # ...removed debug print...
                        self.routine_cleanup()
                    
                    # Check for memory leaks (increasing memory without cleanup)
                    if not hasattr(self, '_last_memory_check'):
                        self._last_memory_check = memory_usage
                        self._memory_growth_counter = 0
                    else:
                        memory_growth = memory_usage - self._last_memory_check
                        if memory_growth > 50 * 1024 * 1024:  # 50MB growth
                            self._memory_growth_counter += 1
                            # ...removed debug print...
                            if self._memory_growth_counter >= 3:  # 3 consecutive growths
                                # ...removed debug print...
                                self.force_cleanup()
                                self._memory_growth_counter = 0
                        else:
                            self._memory_growth_counter = 0
                        
                        self._last_memory_check = memory_usage
                        
                    time.sleep(min(self.check_interval, 5))  # Check at least every 5 seconds
                    
                except ImportError:
                    # psutil not available, do basic cleanup periodically
                    if self.running:  # Check running flag
                        time.sleep(min(self.check_interval, 5))
                        if time.time() - self.last_cleanup > self.check_interval:
                            self.routine_cleanup()
                except Exception as e:
                    print(f"Error in memory monitoring: {e}")
                    if self.running:  # Check running flag
                        time.sleep(min(self.check_interval, 5))
        
        self.monitor_thread = threading.Thread(target=monitor_memory, daemon=True)
        def monitor_memory():
            while self.running:  # Check running flag instead of infinite loop
                try:
                    import psutil
                    process = psutil.Process()
                    memory_usage = process.memory_info().rss
                    # Check for memory threshold breach
                    if memory_usage > self.memory_threshold:
                        self.force_cleanup()
                    # Regular cleanup every interval
                    if time.time() - self.last_cleanup > self.check_interval:
                        self.routine_cleanup()
                    # Check for memory leaks (increasing memory without cleanup)
                    if not hasattr(self, '_last_memory_check'):
                        self._last_memory_check = memory_usage
                        self._memory_growth_counter = 0
                    else:
                        memory_growth = memory_usage - self._last_memory_check
                        if memory_growth > 50 * 1024 * 1024:  # 50MB growth
                            self._memory_growth_counter += 1
                            if self._memory_growth_counter >= 3:  # 3 consecutive growths
                                self.force_cleanup()
                                self._memory_growth_counter = 0
                        else:
                            self._memory_growth_counter = 0
                        self._last_memory_check = memory_usage
                    time.sleep(min(self.check_interval, 5))  # Check at least every 5 seconds
                except ImportError:
                    # psutil not available, do basic cleanup periodically
                    if self.running:  # Check running flag
                        time.sleep(min(self.check_interval, 5))
                        if time.time() - self.last_cleanup > self.check_interval:
                            self.routine_cleanup()
                except Exception as e:
                    print(f"Error in memory monitoring: {e}")
                    if self.running:  # Check running flag
                        time.sleep(min(self.check_interval, 5))
            self.last_cleanup = time.time()
    
    def force_cleanup(self):
        """Force aggressive memory cleanup with detailed reporting"""
        try:
            # ...removed debug print...
            
            # Memory usage before cleanup
            try:
                import psutil
                process = psutil.Process()
                memory_before = process.memory_info().rss / 1024 / 1024  # MB
                # ...removed debug print...
            except ImportError:
                memory_before = 0
            
            # More aggressive cleanup
            for callback in self.cleanup_callbacks:
                try:
                    callback(aggressive=True)
                except Exception as e:
                    print(f"Aggressive cleanup callback error: {e}")
            
            # Multiple garbage collection passes with detailed reporting
            import gc
            total_collected = 0
            for i in range(3):
                collected = gc.collect()
                total_collected += collected
                print(f"GC pass {i+1}: collected {collected} objects")
                
                # Check for remaining garbage
                if gc.garbage:
                    print(f"Warning: {len(gc.garbage)} objects still in gc.garbage after pass {i+1}")
            
            # Final memory report
            try:
                if memory_before > 0:
                    memory_after = process.memory_info().rss / 1024 / 1024  # MB
                    memory_freed = memory_before - memory_after
                    print(f"Memory after aggressive cleanup: {memory_after:.1f} MB")
                    print(f"Total memory freed: {memory_freed:.1f} MB")
                    print(f"Total objects collected: {total_collected}")
            except:
                pass
            
            self.last_cleanup = time.time()
        except Exception as e:
            print(f"Error in aggressive cleanup: {e}")
    
    def cleanup(self):
        """Clean up memory manager and stop background thread - PLATFORM AWARE"""
        self.running = False
        if self.monitor_thread and self.monitor_thread.is_alive():
            # Platform-specific timeout handling
            import platform
            platform_name = platform.system().lower()
            
            if platform_name == 'darwin':  # macOS
                # macOS handles threads more gracefully, allow slightly more time
                self.monitor_thread.join(timeout=0.2)
            elif platform_name == 'windows':  # Windows
                # Windows needs immediate termination
                self.monitor_thread.join(timeout=0.05)
            else:  # Linux and others
                # Standard timeout for Linux
                self.monitor_thread.join(timeout=0.1)
            
            # Force daemon thread termination - don't wait beyond timeout

class BackgroundFileMonitor:
    """Background file system monitoring for automatic updates with thread safety.

    This implementation polls monitored directories for modification time changes,
    coalesces rapid events with a debounce window, and marshals callbacks to the
    Qt main thread using GuiInvoker.instance().invoke signal.
    """

    def __init__(self):
        # Core state
        self.monitored_directories = set()
        self.callbacks = defaultdict(list)
        self.executor = ThreadPoolExecutor(max_workers=1, thread_name_prefix="FileMonitor")
        self.running = True

        # Thread-safety
        import threading
        self._lock = threading.RLock()

        # Debounce configuration: coalesce rapid modification events per-directory
        self._debounce_seconds = 0.5
        self._pending_events = {}  # directory -> last event timestamp

        # Drive change detection
        self._last_drives = set()
        self._drive_callbacks = []

        # Start monitoring thread
        self._start_monitoring()

    def _start_monitoring(self):
        """Start background file monitoring worker (runs in executor)."""

        def monitor_worker():
            directory_mtimes = {}
            while self.running:
                try:
                    now = time.time()

                    # Check monitored directories for mtime changes
                    for directory in list(self.monitored_directories):
                        if not os.path.exists(directory):
                            # If directory removed, stop monitoring it
                            try:
                                self.remove_directory(directory)
                            except Exception:
                                pass
                            continue

                        try:
                            current_mtime = os.path.getmtime(directory)
                            last_mtime = directory_mtimes.get(directory, 0)

                            if current_mtime > last_mtime:
                                # Update last seen mtime and note a pending event time
                                directory_mtimes[directory] = current_mtime
                                self._pending_events[directory] = now

                        except (OSError, PermissionError):
                            pass

                    # Check pending events and invoke callbacks only after debounce window
                    to_invoke = []
                    for d, ts in list(self._pending_events.items()):
                        if time.time() >= ts + getattr(self, '_debounce_seconds', 0.5):
                            to_invoke.append(d)

                    for d in to_invoke:
                        try:
                            for callback in list(self.callbacks.get(d, [])):
                                try:
                                    # Use GuiInvoker to marshal the callback to the main thread
                                    try:
                                        GuiInvoker.instance().invoke.emit(lambda dd=d, cb=callback: cb(dd))
                                    except Exception:
                                        callback(d)
                                except Exception:
                                    pass
                        finally:
                            # Remove pending event after invocation
                            try:
                                del self._pending_events[d]
                            except Exception:
                                pass

                    # Check for system drive changes (added/removed drives)
                    try:
                        drives = set()
                        try:
                            if os.name == 'nt':
                                import string, ctypes
                                bitmask = ctypes.cdll.kernel32.GetLogicalDrives()
                                for i in range(26):
                                    if bitmask & (1 << i):
                                        drives.add(f"{string.ascii_uppercase[i]}:/")
                            else:
                                drives.add(os.path.abspath(os.sep))
                        except Exception:
                            drives.add(os.path.abspath(os.sep))

                        if drives != getattr(self, '_last_drives', set()):
                            self._last_drives = drives
                            # Notify drive callbacks on GUI thread
                            for cb in list(self._drive_callbacks):
                                try:
                                    try:
                                        GuiInvoker.instance().invoke.emit(lambda ds=drives, c=cb: c(ds))
                                    except Exception:
                                        cb(drives)
                                except Exception:
                                    pass
                    except Exception:
                        pass

                    time.sleep(0.25)  # Check frequently to keep debounce responsive
                except Exception:
                    time.sleep(0.5)

        # Submit the worker to the executor
        try:
            self.executor.submit(monitor_worker)
        except Exception:
            # If executor submission fails, ensure running flag is False
            self.running = False

    def add_directory(self, directory_path, callback):
        """Add directory to monitor with callback (thread-safe)."""
        with self._lock:
            self.monitored_directories.add(directory_path)
            self.callbacks[directory_path].append(callback)

    def remove_directory(self, directory_path):
        """Remove directory from monitoring (thread-safe)."""
        with self._lock:
            self.monitored_directories.discard(directory_path)
            if directory_path in self.callbacks:
                del self.callbacks[directory_path]

    def cleanup(self):
        """Clean up resources - PLATFORM AWARE"""
        self.running = False

        import platform
        platform_name = platform.system().lower()

        try:
            if platform_name == 'darwin':  # macOS
                # macOS can handle a brief wait for graceful shutdown
                try:
                    self.executor.shutdown(wait=True, timeout=0.1)
                except TypeError:
                    # Older Python versions don't support timeout arg
                    self.executor.shutdown(wait=True)
            elif platform_name == 'windows':  # Windows
                # Windows needs immediate shutdown
                self.executor.shutdown(wait=False)
            else:  # Linux and others
                # Standard immediate shutdown
                self.executor.shutdown(wait=False)
        except Exception:
            # Fallback for any platform
            try:
                self.executor.shutdown(wait=False)
            except Exception:
                pass

        self.monitored_directories.clear()
        self.callbacks.clear()

    def add_drive_callback(self, callback):
        """Register a callback to be invoked when system drives change.

        Callback will be called with the new set of drives.
        """
        with self._lock:
            if callback not in self._drive_callbacks:
                self._drive_callbacks.append(callback)

    def remove_drive_callback(self, callback):
        with self._lock:
            try:
                if callback in self._drive_callbacks:
                    self._drive_callbacks.remove(callback)
            except Exception:
                pass

# Advanced Search and Filtering Classes
class SearchEngine:
    """Advanced file search engine with multiple criteria and content search"""
    
    def __init__(self):
        self.search_index = {}  # Cache for metadata searches
        self.content_cache = {}  # Cache for content searches
        self.search_executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix="Search")
        self.indexing_executor = ThreadPoolExecutor(max_workers=1, thread_name_prefix="Indexer")
        
        # Search filters
        self.filters = {
            'name': self._filter_by_name,
            'size': self._filter_by_size,
            'date_modified': self._filter_by_date_modified,
            'date_created': self._filter_by_date_created,
            'type': self._filter_by_type,
            'content': self._search_content,
            'extension': self._filter_by_extension,
            'permissions': self._filter_by_permissions
        }
        
        # File type categories
        self.file_types = {
            'image': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg'],
            'video': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v'],
            'audio': ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma', '.m4a'],
            'document': ['.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt', '.xls', '.xlsx', '.ppt', '.pptx'],
            'code': ['.py', '.js', '.html', '.css', '.cpp', '.c', '.java', '.php', '.rb', '.go'],
            'archive': ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz'],
            'executable': ['.exe', '.msi', '.app', '.deb', '.rpm', '.dmg']
        }
        
        # Content search supported types
        self.text_extensions = {'.txt', '.py', '.js', '.html', '.css', '.json', '.xml', '.yaml', '.yml', 
                               '.md', '.rst', '.ini', '.cfg', '.conf', '.log', '.sql', '.csv'}
    
    def search_files_async(self, directory, query, filters=None, callback=None):
        """Asynchronous file search with progress callbacks"""
        future = self.search_executor.submit(self._search_files_worker, directory, query, filters, callback)
        return future
    
    def _search_files_worker(self, directory, query, filters, callback):
        """Worker method for file searching"""
        try:
            results = []
            total_files = 0
            processed_files = 0
            
            # First pass: count total files for progress tracking
            for root, dirs, files in os.walk(directory):
                total_files += len(files)
            
            if callback:
                callback('progress', {'current': 0, 'total': total_files, 'status': 'Starting search...'})
            
            # Second pass: actual search
            for root, dirs, files in os.walk(directory):
                try:
                    for file in files:
                        if processed_files % 100 == 0 and callback:  # Update every 100 files
                            callback('progress', {
                                'current': processed_files, 
                                'total': total_files, 
                                'status': f'Searching: {file[:30]}...'
                            })
                        
                        file_path = os.path.join(root, file)
                        processed_files += 1
                        
                        try:
                            # Get file info
                            stat_info = os.stat(file_path)
                            file_info = {
                                'path': file_path,
                                'name': file,
                                'size': stat_info.st_size,
                                'modified': stat_info.st_mtime,
                                'created': stat_info.st_ctime,
                                'extension': os.path.splitext(file)[1].lower(),
                                'is_dir': False
                            }
                            
                            # Apply search filters
                            if self._matches_search_criteria(file_info, query, filters):
                                results.append(file_info)
                                
                                # Report incremental results
                                if callback and len(results) % 50 == 0:
                                    callback('result', file_info)
                                    
                        except (OSError, PermissionError):
                            continue  # Skip inaccessible files
                            
                except (OSError, PermissionError):
                    continue  # Skip inaccessible directories
            
            # Include directories in search if requested
            if filters and filters.get('include_directories', False):
                for root, dirs, files in os.walk(directory):
                    for dir_name in dirs:
                        try:
                            dir_path = os.path.join(root, dir_name)
                            stat_info = os.stat(dir_path)
                            dir_info = {
                                'path': dir_path,
                                'name': dir_name,
                                'size': 0,
                                'modified': stat_info.st_mtime,
                                'created': stat_info.st_ctime,
                                'extension': '',
                                'is_dir': True
                            }
                            
                            if self._matches_search_criteria(dir_info, query, filters):
                                results.append(dir_info)
                                
                        except (OSError, PermissionError):
                            continue
            
            if callback:
                callback('complete', {'results': results, 'total_processed': processed_files})
                
            return results
            
        except Exception as e:
            if callback:
                callback('error', {'message': str(e)})
            return []
    
    def _matches_search_criteria(self, file_info, query, filters):
        """Check if file matches all search criteria"""
        # Basic name query (always applied if provided)
        if query and not self._filter_by_name(file_info, query):
            return False
        
        # Apply additional filters
        if filters:
            for filter_name, filter_value in filters.items():
                if filter_name in self.filters and filter_value is not None:
                    if not self.filters[filter_name](file_info, filter_value):
                        return False
        
        return True
    
    def _filter_by_name(self, file_info, pattern):
        """Filter by filename pattern (supports wildcards)"""
        import fnmatch
        return fnmatch.fnmatch(file_info['name'].lower(), pattern.lower())
    
    def _filter_by_size(self, file_info, size_criteria):
        """Filter by file size criteria: {'min': bytes, 'max': bytes}"""
        file_size = file_info['size']
        if 'min' in size_criteria and file_size < size_criteria['min']:
            return False
        if 'max' in size_criteria and file_size > size_criteria['max']:
            return False
        return True
    
    def _filter_by_date_modified(self, file_info, date_criteria):
        """Filter by modification date: {'after': timestamp, 'before': timestamp}"""
        mod_time = file_info['modified']
        if 'after' in date_criteria and mod_time < date_criteria['after']:
            return False
        if 'before' in date_criteria and mod_time > date_criteria['before']:
            return False
        return True
    
    def _filter_by_date_created(self, file_info, date_criteria):
        """Filter by creation date: {'after': timestamp, 'before': timestamp}"""
        create_time = file_info['created']
        if 'after' in date_criteria and create_time < date_criteria['after']:
            return False
        if 'before' in date_criteria and create_time > date_criteria['before']:
            return False
        return True
    
    def _filter_by_type(self, file_info, file_type):
        """Filter by file type category"""
        if file_type in self.file_types:
            return file_info['extension'] in self.file_types[file_type]
        return False
    
    def _filter_by_extension(self, file_info, extensions):
        """Filter by specific file extensions (list)"""
        if isinstance(extensions, str):
            extensions = [extensions]
        return file_info['extension'] in [ext.lower() for ext in extensions]
    
    def _filter_by_permissions(self, file_info, permission_criteria):
        """Filter by file permissions (readable, writable, executable)"""
        try:
            path = file_info['path']
            if permission_criteria.get('readable') and not os.access(path, os.R_OK):
                return False
            if permission_criteria.get('writable') and not os.access(path, os.W_OK):
                return False
            if permission_criteria.get('executable') and not os.access(path, os.X_OK):
                return False
            return True
        except:
            return False
    
    def _search_content(self, file_info, search_term):
        """Search file content for text"""
        if file_info['is_dir']:
            return False
            
        if file_info['extension'] not in self.text_extensions:
            return False
        
        # Check cache first
        cache_key = f"{file_info['path']}:{file_info['modified']}"
        if cache_key in self.content_cache:
            return search_term.lower() in self.content_cache[cache_key].lower()
        
        try:
            with open(file_info['path'], 'r', encoding='utf-8', errors='ignore') as f:
                # Read first 1MB for content search
                content = f.read(1024 * 1024)
                self.content_cache[cache_key] = content
                return search_term.lower() in content.lower()
        except:
            return False
    
    def cleanup(self):
        """Clean up search engine resources"""
        try:
            self.search_executor.shutdown(wait=False)
            self.indexing_executor.shutdown(wait=False)
            self.search_index.clear()
            self.content_cache.clear()
        except Exception as e:
            print(f"Error cleaning up search engine: {e}")



# ==================== CONCURRENT FILE TRANSFER MANAGER ====================

from enum import Enum, auto
from PyQt5.QtCore import QObject, pyqtSignal, QTimer, QMutex, QMutexLocker
from PyQt5.QtWidgets import QProgressBar, QLabel, QHBoxLayout, QVBoxLayout, QWidget, QPushButton
import uuid
import queue
import threading

class TransferStatus(Enum):
    """Status of file transfer operations"""
    QUEUED = auto()
    RUNNING = auto()
    PAUSED = auto()
    COMPLETED = auto()
    FAILED = auto()
    CANCELLED = auto()

@dataclass
class TransferInfo:
    """Information about a file transfer operation"""
    id: str
    operation_type: str  # 'copy', 'move', 'delete'
    source_paths: List[Union[str, Path]]
    destination_path: Union[str, Path]
    status: TransferStatus
    progress: float  # 0.0 to 100.0
    current_file: str
    total_files: int
    processed_files: int
    total_bytes: int
    processed_bytes: int
    speed_mbps: float
    eta_seconds: int
    error_message: str
    start_time: float
    end_time: Optional[float]

class MergeFileConflictDialog(QDialog):
    """Simplified conflict resolution dialog for files during directory merge"""
    
    def __init__(self, source_path, dest_path, parent=None):
        super().__init__(parent)
        self.source_path = Path(source_path)
        self.dest_path = Path(dest_path)
        self.resolution = None
        self.apply_to_all = False
        
        self.setWindowTitle("File Conflict During Directory Merge")
        self.setModal(True)
        self.setMinimumSize(500, 300)
        
        # Theme will be applied in showEvent to ensure dialog is visible
        self._theme_applied = False
        
        self._setup_ui()
        self._load_file_info()
    
    def _apply_dialog_styling(self):
        """Apply current QSS theme from parent application to merge file conflict dialog"""
        try:
            print(f"[DEBUG] MergeFileConflictDialog: Attempting to apply theme")
            
            # Find the main application window (SimpleFileManager) - try multiple methods
            main_window = None
            
            # Method 1: Check parent hierarchy
            parent = self.parent()
            while parent:
                if isinstance(parent, QMainWindow) or parent.__class__.__name__ == 'SimpleFileManager':
                    main_window = parent
                    print(f"[DEBUG] Found main window via parent hierarchy: {parent.__class__.__name__}")
                    break
                parent = parent.parent()
            
            # Method 2: If parent method failed, search through all application windows
            if not main_window:
                from PyQt5.QtWidgets import QApplication
                for widget in QApplication.allWidgets():
                    if widget.__class__.__name__ == 'SimpleFileManager':
                        main_window = widget
                        print(f"[DEBUG] Found main window via QApplication search: {widget.__class__.__name__}")
                        break
            
            if main_window:
                # Use the current QSS theme from the main application
                current_qss = main_window.styleSheet()
                print(f"[DEBUG] Main window stylesheet length: {len(current_qss)} chars")
                
                if current_qss and len(current_qss.strip()) > 0:
                    print(f"[DEBUG] Applying current QSS theme to MergeFileConflictDialog ({len(current_qss)} chars)")
                    
                    # Copy the main window's palette to this dialog for proper theme color inheritance
                    self.setPalette(main_window.palette())
                    print(f"[DEBUG] Copied main window palette to dialog")
                    
                    # Check if the theme contains dialog-specific rules
                    enhanced_qss = current_qss
                    # Remove CSS comments and check for actual QDialog selectors
                    import re
                    content_no_comments = re.sub(r'/\*.*?\*/', '', current_qss, flags=re.DOTALL)
                    dialog_pattern = r'(?:^|[\s,])\s*QDialog(?:\s*::\w+|\s*:\w+)?\s*\{'
                    has_dialog_rules = bool(re.search(dialog_pattern, content_no_comments, re.MULTILINE | re.IGNORECASE))
                    
                    if not has_dialog_rules:
                        print("[DEBUG] Theme missing QDialog rules, adding dialog enhancements")
                        
                        # Extract colors from current theme (through main window)
                        if hasattr(main_window, '_extract_theme_colors'):
                            theme_colors = main_window._extract_theme_colors(current_qss)
                            print(f"[DEBUG] Extracted theme colors: {theme_colors}")
                            dialog_enhancements = main_window._generate_dialog_enhancement_css(theme_colors)
                        else:
                            print("[DEBUG] Main window missing color extraction methods, using fallback")
                            dialog_enhancements = """
                        
/* Dialog enhancements fallback */
QDialog {
    background-color: #ffffff;
    color: #000000;
    border: 1px solid #cccccc;
    border-radius: 4px;
    padding: 4px;
}

QDialog QPushButton {
    background-color: #f0f0f0;
    color: #000000;
    border: 1px solid #cccccc;
    border-radius: 4px;
    min-width: 80px;
    padding: 6px 12px;
}

QDialog QPushButton:hover {
    background-color: #e0e0e0;
}
"""
                        enhanced_qss = current_qss + dialog_enhancements
                        print(f"[DEBUG] Enhanced QSS length: {len(enhanced_qss)} chars (added {len(dialog_enhancements)} chars)")
                    else:
                        print("[DEBUG] Theme already contains QDialog rules, using as-is")
                    
                    self.setStyleSheet(enhanced_qss)
                    return
                else:
                    print("[DEBUG] Main window has no QSS theme, using fallback styling")
            else:
                print("[DEBUG] Main window not found, using fallback styling")
                
            self._apply_fallback_styling()
                
        except Exception as e:
            print(f"[DEBUG] Error applying QSS theme to dialog: {e}")
            self._apply_fallback_styling()
    
    def _apply_fallback_styling(self):
        """Apply minimal fallback styling if QSS theme is not available"""
        fallback_style = """
        QDialog {
            background-color: #ffffff;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
        }
        QPushButton {
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-weight: bold;
        }
        QPushButton:hover {
            background-color: #2980b9;
        }
        """
        self.setStyleSheet(fallback_style)
        
    def _setup_ui(self):
        """Setup the simplified dialog UI"""
        layout = QVBoxLayout(self)
        
        # Header with conflict description
        header_label = QLabel()
        header_label.setWordWrap(True)
        header_text = f"A file with the same name already exists in the destination.\n\nDo you want to overwrite it or skip this file?"
        header_label.setText(header_text)
        layout.addWidget(header_label)
        
        # File comparison area
        comparison_frame = QFrame()
        comparison_frame.setFrameStyle(QFrame.Box)
        comparison_layout = QHBoxLayout(comparison_frame)
        
        # Source file info
        source_group = QGroupBox("Source File")
        source_layout = QVBoxLayout(source_group)
        
        self.source_name_label = QLabel()
        self.source_size_label = QLabel()
        self.source_date_label = QLabel()
        source_layout.addWidget(QLabel("Name:"))
        source_layout.addWidget(self.source_name_label)
        source_layout.addWidget(QLabel("Size:"))
        source_layout.addWidget(self.source_size_label)
        source_layout.addWidget(QLabel("Modified:"))
        source_layout.addWidget(self.source_date_label)
        source_layout.addStretch()
        
        # Destination file info
        dest_group = QGroupBox("Existing File")
        dest_layout = QVBoxLayout(dest_group)
        
        self.dest_name_label = QLabel()
        self.dest_size_label = QLabel()
        self.dest_date_label = QLabel()
        dest_layout.addWidget(QLabel("Name:"))
        dest_layout.addWidget(self.dest_name_label)
        dest_layout.addWidget(QLabel("Size:"))
        dest_layout.addWidget(self.dest_size_label)
        dest_layout.addWidget(QLabel("Modified:"))
        dest_layout.addWidget(self.dest_date_label)
        dest_layout.addStretch()
        
        comparison_layout.addWidget(source_group)
        comparison_layout.addWidget(dest_group)
        layout.addWidget(comparison_frame)
        
        # Resolution options (simplified for merge)
        options_group = QGroupBox("Choose an action:")
        options_layout = QVBoxLayout(options_group)
        
        self.button_group = QButtonGroup()
        
        # Overwrite option
        self.overwrite_radio = QRadioButton("Overwrite the existing file")
        self.overwrite_radio.setChecked(True)  # Default selection
        self.button_group.addButton(self.overwrite_radio, 0)
        options_layout.addWidget(self.overwrite_radio)
        
        # Skip option
        self.skip_radio = QRadioButton("Skip this file (keep existing)")
        self.button_group.addButton(self.skip_radio, 1)
        options_layout.addWidget(self.skip_radio)
        
        layout.addWidget(options_group)
        
        # Apply to all checkbox
        self.apply_to_all_cb = QCheckBox("Apply this action to all file conflicts during this merge")
        layout.addWidget(self.apply_to_all_cb)
        
        # Button box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self._on_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
    def _load_file_info(self):
        """Load and display file information"""
        try:
            # Source file info
            if self.source_path.exists():
                self.source_name_label.setText(self.source_path.name)
                size = self.source_path.stat().st_size
                self.source_size_label.setText(self._format_size(size))
                mtime = self.source_path.stat().st_mtime
                self.source_date_label.setText(self._format_date(mtime))
            else:
                self.source_name_label.setText(self.source_path.name)
                self.source_size_label.setText("Unknown")
                self.source_date_label.setText("Unknown")
                
            # Destination file info
            if self.dest_path.exists():
                self.dest_name_label.setText(self.dest_path.name)
                size = self.dest_path.stat().st_size
                self.dest_size_label.setText(self._format_size(size))
                mtime = self.dest_path.stat().st_mtime
                self.dest_date_label.setText(self._format_date(mtime))
            else:
                self.dest_name_label.setText(self.dest_path.name)
                self.dest_size_label.setText("Unknown")
                self.dest_date_label.setText("Unknown")
                
        except Exception as e:
            print(f"Error loading file info: {e}")
    
    def _format_size(self, size_bytes):
        """Format file size in human readable format"""
        if size_bytes == 0:
            return "0 B"
        size_names = ["B", "KB", "MB", "GB", "TB"]
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"
    
    def _format_date(self, timestamp):
        """Format timestamp as readable date"""
        from datetime import datetime
        dt = datetime.fromtimestamp(timestamp)
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    
    def _on_accept(self):
        """Handle dialog acceptance"""
        checked_id = self.button_group.checkedId()
        
        if checked_id == 0:  # Overwrite
            self.resolution = "replace"
        elif checked_id == 1:  # Skip
            self.resolution = "skip"
        
        self.apply_to_all = self.apply_to_all_cb.isChecked()
        self.accept()
    
    def get_resolution(self):
        """Get the user's resolution choice"""
        return {
            'action': self.resolution,
            'apply_to_all': self.apply_to_all
        }

    def showEvent(self, event):
        """Apply theme when dialog is shown"""
        print(f"[DEBUG] MergeFileConflictDialog showEvent called, _theme_applied: {getattr(self, '_theme_applied', 'NOT_SET')}")
        super().showEvent(event)
        if not getattr(self, '_theme_applied', False):
            print(f"[DEBUG] MergeFileConflictDialog applying theme via showEvent")
            self._apply_dialog_styling()
            self._theme_applied = True
        else:
            print(f"[DEBUG] MergeFileConflictDialog theme already applied, skipping")

class ConflictResolutionDialog(QDialog):
    """Advanced conflict resolution dialog for file operations"""
    
    def __init__(self, source_path, dest_path, operation_type="copy", parent=None):
        super().__init__(parent)
        self.source_path = Path(source_path)
        self.dest_path = Path(dest_path)
        self.operation_type = operation_type
        self.resolution = None
        self.apply_to_all = False
        self.new_name = None
        
        # Check if we're dealing with directories
        self.is_directory_conflict = (self.source_path.is_dir() and self.dest_path.is_dir())
        
        self.setWindowTitle("Directory Conflict" if self.is_directory_conflict else "File Conflict")
        self.setModal(True)
        self.setMinimumSize(600, 400)
        
        # Theme will be applied in showEvent to ensure dialog is visible
        self._theme_applied = False
        
        self._setup_ui()
        self._load_file_info()
    
    def _apply_dialog_styling(self):
        """Apply current QSS theme from parent application to conflict resolution dialog"""
        try:
            print(f"[DEBUG] ConflictResolutionDialog: Attempting to apply theme")
            
            # Find the main application window (SimpleFileManager) - try multiple methods
            main_window = None
            
            # Method 1: Check parent hierarchy
            parent = self.parent()
            while parent:
                if isinstance(parent, QMainWindow) or parent.__class__.__name__ == 'SimpleFileManager':
                    main_window = parent
                    print(f"[DEBUG] Found main window via parent hierarchy: {parent.__class__.__name__}")
                    break
                parent = parent.parent()
            
            # Method 2: If parent method failed, search through all application windows
            if not main_window:
                from PyQt5.QtWidgets import QApplication
                for widget in QApplication.allWidgets():
                    if widget.__class__.__name__ == 'SimpleFileManager':
                        main_window = widget
                        print(f"[DEBUG] Found main window via QApplication search: {widget.__class__.__name__}")
                        break
            
            if main_window:
                # Use the current QSS theme from the main application
                current_qss = main_window.styleSheet()
                print(f"[DEBUG] Main window stylesheet length: {len(current_qss)} chars")
                
                if current_qss and len(current_qss.strip()) > 0:
                    print(f"[DEBUG] Applying current QSS theme to ConflictResolutionDialog ({len(current_qss)} chars)")
                    
                    # Copy the main window's palette to this dialog for proper theme color inheritance
                    self.setPalette(main_window.palette())
                    print(f"[DEBUG] Copied main window palette to dialog")
                    
                    # Check if the theme contains dialog-specific rules
                    enhanced_qss = current_qss
                    # Remove CSS comments and check for actual QDialog selectors
                    import re
                    content_no_comments = re.sub(r'/\*.*?\*/', '', current_qss, flags=re.DOTALL)
                    dialog_pattern = r'(?:^|[\s,])\s*QDialog(?:\s*::\w+|\s*:\w+)?\s*\{'
                    has_dialog_rules = bool(re.search(dialog_pattern, content_no_comments, re.MULTILINE | re.IGNORECASE))
                    
                    if not has_dialog_rules:
                        print("[DEBUG] Theme missing QDialog rules, adding dialog enhancements")
                        
                        # Extract colors from current theme (through main window)
                        if hasattr(main_window, '_extract_theme_colors'):
                            theme_colors = main_window._extract_theme_colors(current_qss)
                            print(f"[DEBUG] Extracted theme colors: {theme_colors}")
                            dialog_enhancements = main_window._generate_dialog_enhancement_css(theme_colors)
                        else:
                            print("[DEBUG] Main window missing color extraction methods, using fallback")
                            dialog_enhancements = """
                        
/* Dialog enhancements fallback */
QDialog {
    background-color: #ffffff;
    color: #000000;
    border: 1px solid #cccccc;
    border-radius: 4px;
    padding: 4px;
}

QDialog QPushButton {
    background-color: #f0f0f0;
    color: #000000;
    border: 1px solid #cccccc;
    border-radius: 4px;
    min-width: 80px;
    padding: 6px 12px;
}

QDialog QPushButton:hover {
    background-color: #e0e0e0;
}
"""
                        enhanced_qss = current_qss + dialog_enhancements
                        print(f"[DEBUG] Enhanced QSS length: {len(enhanced_qss)} chars (added {len(dialog_enhancements)} chars)")
                    else:
                        print("[DEBUG] Theme already contains QDialog rules, using as-is")
                    
                    self.setStyleSheet(enhanced_qss)
                    return
                else:
                    print("[DEBUG] Main window has no QSS theme, using fallback styling")
            else:
                print("[DEBUG] Main window not found, using fallback styling")
                
            self._apply_fallback_styling()
                
        except Exception as e:
            print(f"[DEBUG] Error applying QSS theme to dialog: {e}")
            self._apply_fallback_styling()
    
    def _apply_fallback_styling(self):
        """Apply minimal fallback styling if QSS theme is not available"""
        fallback_style = """
        QDialog {
            background-color: #ffffff;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
        }
        QPushButton {
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-weight: bold;
        }
        QPushButton:hover {
            background-color: #2980b9;
        }
        QLineEdit {
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            padding: 4px;
        }
        """
        self.setStyleSheet(fallback_style)
        
    def _setup_ui(self):
        """Setup the dialog UI"""
        layout = QVBoxLayout(self)
        
        # Header with conflict description
        header_label = QLabel()
        header_label.setWordWrap(True)
        if self.is_directory_conflict:
            if self.operation_type == "copy":
                header_text = f"A directory with the same name already exists in the destination folder.\n\nWhat would you like to do?"
            elif self.operation_type == "move":
                header_text = f"A directory with the same name already exists in the destination folder.\n\nWhat would you like to do?"
            else:
                header_text = f"Directory conflict detected.\n\nWhat would you like to do?"
        else:
            if self.operation_type == "copy":
                header_text = f"A file with the same name already exists in the destination folder.\n\nWhat would you like to do?"
            elif self.operation_type == "move":
                header_text = f"A file with the same name already exists in the destination folder.\n\nWhat would you like to do?"
            else:
                header_text = f"File conflict detected.\n\nWhat would you like to do?"
        header_label.setText(header_text)
        layout.addWidget(header_label)
        
        # File comparison area
        comparison_frame = QFrame()
        comparison_frame.setFrameStyle(QFrame.Box)
        comparison_layout = QHBoxLayout(comparison_frame)
        
        # Source file info
        source_group = QGroupBox("Source Directory" if self.is_directory_conflict else "Source File")
        source_layout = QVBoxLayout(source_group)
        
        self.source_name_label = QLabel()
        self.source_size_label = QLabel()
        self.source_date_label = QLabel()
        source_layout.addWidget(QLabel("Name:"))
        source_layout.addWidget(self.source_name_label)
        source_layout.addWidget(QLabel("Size:"))
        source_layout.addWidget(self.source_size_label)
        source_layout.addWidget(QLabel("Modified:"))
        source_layout.addWidget(self.source_date_label)
        source_layout.addStretch()
        
        # Destination file info
        dest_group = QGroupBox("Existing Directory" if self.is_directory_conflict else "Existing File")
        dest_layout = QVBoxLayout(dest_group)
        
        self.dest_name_label = QLabel()
        self.dest_size_label = QLabel()
        self.dest_date_label = QLabel()
        dest_layout.addWidget(QLabel("Name:"))
        dest_layout.addWidget(self.dest_name_label)
        dest_layout.addWidget(QLabel("Size:"))
        dest_layout.addWidget(self.dest_size_label)
        dest_layout.addWidget(QLabel("Modified:"))
        dest_layout.addWidget(self.dest_date_label)
        dest_layout.addStretch()
        
        comparison_layout.addWidget(source_group)
        comparison_layout.addWidget(dest_group)
        layout.addWidget(comparison_frame)
        
        # Resolution options
        options_group = QGroupBox("Choose an action:")
        options_layout = QVBoxLayout(options_group)
        
        self.button_group = QButtonGroup()
        
        # Replace option
        replace_text = "Replace the existing directory" if self.is_directory_conflict else "Replace the existing file"
        self.replace_radio = QRadioButton(replace_text)
        self.replace_radio.setChecked(True)  # Default selection
        self.button_group.addButton(self.replace_radio, 0)
        options_layout.addWidget(self.replace_radio)
        
        # Keep both option
        keep_both_text = "Keep both directories (rename new directory)" if self.is_directory_conflict else "Keep both files (rename new file)"
        self.keep_both_radio = QRadioButton(keep_both_text)
        self.button_group.addButton(self.keep_both_radio, 1)
        options_layout.addWidget(self.keep_both_radio)
        
        # Custom name option
        custom_layout = QHBoxLayout()
        self.custom_radio = QRadioButton("Rename to:")
        self.button_group.addButton(self.custom_radio, 2)
        self.custom_name_edit = QLineEdit()
        self.custom_name_edit.setEnabled(False)
        custom_layout.addWidget(self.custom_radio)
        custom_layout.addWidget(self.custom_name_edit)
        options_layout.addLayout(custom_layout)
        
        # Skip option
        self.skip_radio = QRadioButton("Skip this directory" if self.is_directory_conflict else "Skip this file")
        self.button_group.addButton(self.skip_radio, 3)
        options_layout.addWidget(self.skip_radio)
        
        # Merge option (for directories only)
        self.merge_radio = QRadioButton("Merge directories (combine contents)")
        self.button_group.addButton(self.merge_radio, 4)
        if self.is_directory_conflict:
            options_layout.addWidget(self.merge_radio)
        else:
            self.merge_radio.setVisible(False)
        
        # Connect radio button signals
        self.custom_radio.toggled.connect(self._on_custom_radio_toggled)
        self.custom_name_edit.textChanged.connect(self._on_custom_name_changed)
        
        layout.addWidget(options_group)
        
        # Apply to all checkbox
        self.apply_to_all_cb = QCheckBox("Apply this action to all conflicts")
        layout.addWidget(self.apply_to_all_cb)
        
        # Button box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self._on_accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
    def _load_file_info(self):
        """Load and display file information"""
        try:
            # Source file info
            if self.source_path.exists():
                self.source_name_label.setText(self.source_path.name)
                if self.source_path.is_dir():
                    # For directories, show item count
                    try:
                        item_count = len(list(self.source_path.iterdir()))
                        self.source_size_label.setText(f"{item_count} items")
                    except PermissionError:
                        self.source_size_label.setText("Access denied")
                else:
                    # For files, show size
                    size = self.source_path.stat().st_size
                    self.source_size_label.setText(self._format_size(size))
                mtime = self.source_path.stat().st_mtime
                self.source_date_label.setText(self._format_date(mtime))
            else:
                self.source_name_label.setText(self.source_path.name)
                self.source_size_label.setText("Unknown")
                self.source_date_label.setText("Unknown")
                
            # Destination file info
            if self.dest_path.exists():
                self.dest_name_label.setText(self.dest_path.name)
                if self.dest_path.is_dir():
                    # For directories, show item count
                    try:
                        item_count = len(list(self.dest_path.iterdir()))
                        self.dest_size_label.setText(f"{item_count} items")
                    except PermissionError:
                        self.dest_size_label.setText("Access denied")
                else:
                    # For files, show size
                    size = self.dest_path.stat().st_size
                    self.dest_size_label.setText(self._format_size(size))
                mtime = self.dest_path.stat().st_mtime
                self.dest_date_label.setText(self._format_date(mtime))
            else:
                self.dest_name_label.setText(self.dest_path.name)
                self.dest_size_label.setText("Unknown")
                self.dest_date_label.setText("Unknown")
                
            # Set default custom name
            self.custom_name_edit.setText(self.source_path.name)
            
        except Exception as e:
            print(f"Error loading file info: {e}")
    
    def _format_size(self, size_bytes):
        """Format file size in human readable format"""
        if size_bytes == 0:
            return "0 B"
        size_names = ["B", "KB", "MB", "GB", "TB"]
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"
    
    def _format_date(self, timestamp):
        """Format timestamp as readable date"""
        from datetime import datetime
        dt = datetime.fromtimestamp(timestamp)
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    
    def _on_custom_radio_toggled(self, checked):
        """Enable/disable custom name edit when radio is toggled"""
        self.custom_name_edit.setEnabled(checked)
        if checked:
            self.custom_name_edit.setFocus()
            self.custom_name_edit.selectAll()
    
    def _on_custom_name_changed(self, text):
        """Auto-select custom radio when user types in the field"""
        if text and not self.custom_radio.isChecked():
            self.custom_radio.setChecked(True)
    
    def _on_accept(self):
        """Handle dialog acceptance"""
        checked_id = self.button_group.checkedId()
        
        if checked_id == 0:  # Replace
            self.resolution = "replace"
        elif checked_id == 1:  # Keep both
            self.resolution = "keep_both"
        elif checked_id == 2:  # Custom name
            custom_name = self.custom_name_edit.text().strip()
            if not custom_name:
                QMessageBox.warning(self, "Invalid Name", "Please enter a valid filename.")
                return
            self.resolution = "rename"
            self.new_name = custom_name
        elif checked_id == 3:  # Skip
            self.resolution = "skip"
        elif checked_id == 4:  # Merge directories
            self.resolution = "merge"
        
        self.apply_to_all = self.apply_to_all_cb.isChecked()
        self.accept()
    
    def get_resolution(self):
        """Get the user's resolution choice"""
        return {
            'action': self.resolution,
            'new_name': self.new_name,
            'apply_to_all': self.apply_to_all
        }

    def showEvent(self, event):
        """Apply theme when dialog is shown"""
        print(f"[DEBUG] ConflictResolutionDialog showEvent called, _theme_applied: {getattr(self, '_theme_applied', 'NOT_SET')}")
        super().showEvent(event)
        if not getattr(self, '_theme_applied', False):
            print(f"[DEBUG] ConflictResolutionDialog applying theme via showEvent")
            self._apply_dialog_styling()
            self._theme_applied = True
        else:
            print(f"[DEBUG] ConflictResolutionDialog theme already applied, skipping")

class ConcurrentTransferManager(QObject):
    """Manages multiple concurrent file transfer operations"""
    
    # Signals for UI updates
    transfer_added = pyqtSignal(str)  # transfer_id
    transfer_updated = pyqtSignal(str, dict)  # transfer_id, update_data
    transfer_completed = pyqtSignal(str, bool, str)  # transfer_id, success, message
    all_transfers_completed = pyqtSignal()
    
    def __init__(self, max_concurrent_transfers: int = 3) -> None:
        super().__init__()
        self.max_concurrent_transfers = max_concurrent_transfers
        self.transfers: Dict[str, TransferInfo] = {}
        self.active_workers: Dict[str, AsyncFileOperationWorker] = {}
        self.transfer_queue = queue.Queue()
        self.mutex = QMutex()
        self.logger = setup_logger(f'{__name__}.ConcurrentTransferManager')
        
        # Start transfer processor timer (for GUI environments)
        self.transfer_processor_timer = QTimer()
        self.transfer_processor_timer.timeout.connect(self._process_transfer_queue)
        
        # Try to start timer - will work in GUI environments
        try:
            self.transfer_processor_timer.start(100)  # Check every 100ms
        except Exception:
            # Timer won't work outside GUI - that's okay, we'll use direct processing
            self.logger.debug("Timer-based processing unavailable, using direct processing")
        
    def add_transfer(
        self, 
        source_paths: List[Union[str, Path]], 
        destination_path: Union[str, Path], 
        operation_type: str
    ) -> str:
        """Add a new transfer to the queue"""
        transfer_id = str(uuid.uuid4())
        
        transfer_info = TransferInfo(
            id=transfer_id,
            operation_type=operation_type,
            source_paths=[Path(p) for p in source_paths],
            destination_path=Path(destination_path),
            status=TransferStatus.QUEUED,
            progress=0.0,
            current_file="",
            total_files=len(source_paths),
            processed_files=0,
            total_bytes=0,
            processed_bytes=0,
            speed_mbps=0.0,
            eta_seconds=0,
            error_message="",
            start_time=time.time(),
            end_time=None
        )
        
        with QMutexLocker(self.mutex):
            self.transfers[transfer_id] = transfer_info
        
        self.transfer_queue.put(transfer_id)
        self.transfer_added.emit(transfer_id)
        
        # Immediately try to process transfers (for non-GUI environments or immediate processing)
        self._process_transfer_queue()
        
        self.logger.info(f"Added transfer {transfer_id}: {operation_type} {len(source_paths)} items to {destination_path}")
        return transfer_id
    
    def _process_transfer_queue(self) -> None:
        """Process queued transfers if slots are available"""
        with QMutexLocker(self.mutex):
            active_count = len([t for t in self.transfers.values() if t.status == TransferStatus.RUNNING])
        
        if active_count >= self.max_concurrent_transfers:
            return
            
        try:
            if not self.transfer_queue.empty():
                transfer_id = self.transfer_queue.get_nowait()
                self._start_transfer(transfer_id)
        except queue.Empty:
            pass
    
    def _start_transfer(self, transfer_id: str) -> None:
        """Start a specific transfer"""
        with QMutexLocker(self.mutex):
            if transfer_id not in self.transfers:
                return
            
            transfer_info = self.transfers[transfer_id]
            if transfer_info.status != TransferStatus.QUEUED:
                return
                
            transfer_info.status = TransferStatus.RUNNING
        
        # Create and configure the operation
        operation = AsyncFileOperation(
            source_paths=[str(p) for p in transfer_info.source_paths],
            destination_path=str(transfer_info.destination_path),
            operation_type=transfer_info.operation_type
        )
        
        # Create worker thread
        worker = AsyncFileOperationWorker(operation)
        
        # Connect signals
        worker.progress.connect(lambda progress: self._update_transfer_progress(transfer_id, progress))
        worker.fileProgress.connect(lambda current, total: self._update_file_progress(transfer_id, current, total))
        worker.byteProgress.connect(lambda current, total: self._update_byte_progress(transfer_id, current, total))
        worker.speedUpdate.connect(lambda speed: self._update_transfer_speed(transfer_id, speed))
        worker.etaUpdate.connect(lambda eta: self._update_transfer_eta(transfer_id, eta))
        worker.statusChanged.connect(lambda status: self._update_transfer_status(transfer_id, status))
        worker.finished.connect(lambda success, message, stats: self._transfer_finished(transfer_id, success, message, stats))
        worker.errorOccurred.connect(lambda path, error, action: self._transfer_error(transfer_id, path, error, action))
        worker.conflictResolution.connect(lambda source, dest, op, response: self._handle_conflict_resolution(source, dest, op, response, worker))
        
        # Store worker and start
        with QMutexLocker(self.mutex):
            self.active_workers[transfer_id] = worker
        
        worker.start()
        self.logger.info(f"Started transfer {transfer_id}")
    
    @profile_performance('transfer_progress_update')
    def _update_transfer_progress(self, transfer_id: str, progress: int) -> None:
        """Update transfer progress"""
        with QMutexLocker(self.mutex):
            if transfer_id in self.transfers:
                self.transfers[transfer_id].progress = float(progress)
                
        self.transfer_updated.emit(transfer_id, {'progress': progress})
    
    def _update_file_progress(self, transfer_id: str, current: int, total: int) -> None:
        """Update file progress"""
        with QMutexLocker(self.mutex):
            if transfer_id in self.transfers:
                transfer_info = self.transfers[transfer_id]
                transfer_info.processed_files = current
                transfer_info.total_files = total
                
        self.transfer_updated.emit(transfer_id, {'processed_files': current, 'total_files': total})
    
    def _update_byte_progress(self, transfer_id: str, current: int, total: int) -> None:
        """Update byte progress"""
        with QMutexLocker(self.mutex):
            if transfer_id in self.transfers:
                transfer_info = self.transfers[transfer_id]
                transfer_info.processed_bytes = current
                transfer_info.total_bytes = total
                
        self.transfer_updated.emit(transfer_id, {'processed_bytes': current, 'total_bytes': total})
    
    def _update_transfer_speed(self, transfer_id: str, speed_str: str) -> None:
        """Update transfer speed"""
        try:
            # Parse speed string (e.g., "1.5 MB/s")
            if 'MB/s' in speed_str:
                speed_mbps = float(speed_str.split()[0])
            elif 'KB/s' in speed_str:
                speed_mbps = float(speed_str.split()[0]) / 1024
            else:
                speed_mbps = 0.0
                
            with QMutexLocker(self.mutex):
                if transfer_id in self.transfers:
                    self.transfers[transfer_id].speed_mbps = speed_mbps
                    
            self.transfer_updated.emit(transfer_id, {'speed': speed_str})
        except (ValueError, IndexError):
            pass
    
    def _update_transfer_eta(self, transfer_id: str, eta_str: str) -> None:
        """Update estimated time remaining"""
        try:
            # Parse ETA string (e.g., "5m 30s")
            eta_seconds = 0
            if 'h' in eta_str:
                hours = int(eta_str.split('h')[0])
                eta_seconds += hours * 3600
            if 'm' in eta_str:
                minutes_part = eta_str.split('h')[-1] if 'h' in eta_str else eta_str
                minutes = int(minutes_part.split('m')[0])
                eta_seconds += minutes * 60
            if 's' in eta_str:
                seconds_part = eta_str.split('m')[-1] if 'm' in eta_str else eta_str
                seconds = int(seconds_part.split('s')[0])
                eta_seconds += seconds
                
            with QMutexLocker(self.mutex):
                if transfer_id in self.transfers:
                    self.transfers[transfer_id].eta_seconds = eta_seconds
                    
            self.transfer_updated.emit(transfer_id, {'eta': eta_str})
        except (ValueError, IndexError):
            pass
    
    def _update_transfer_status(self, transfer_id: str, status: str) -> None:
        """Update transfer status message"""
        with QMutexLocker(self.mutex):
            if transfer_id in self.transfers:
                self.transfers[transfer_id].current_file = status
                
        self.transfer_updated.emit(transfer_id, {'current_file': status})
    
    def _transfer_finished(self, transfer_id: str, success: bool, message: str, stats: dict) -> None:
        """Handle transfer completion"""
        with QMutexLocker(self.mutex):
            if transfer_id in self.transfers:
                transfer_info = self.transfers[transfer_id]
                transfer_info.status = TransferStatus.COMPLETED if success else TransferStatus.FAILED
                transfer_info.end_time = time.time()
                if not success:
                    transfer_info.error_message = message
            
            # Clean up worker
            if transfer_id in self.active_workers:
                worker = self.active_workers[transfer_id]
                worker.deleteLater()
                del self.active_workers[transfer_id]
        
        self.transfer_completed.emit(transfer_id, success, message)
        self.logger.info(f"Transfer {transfer_id} finished: success={success}, message={message}")
        
        # Check if all transfers are completed
        with QMutexLocker(self.mutex):
            active_transfers = [t for t in self.transfers.values() 
                              if t.status in [TransferStatus.QUEUED, TransferStatus.RUNNING, TransferStatus.PAUSED]]
        
        if not active_transfers:
            self.all_transfers_completed.emit()
    
    def _transfer_error(self, transfer_id: str, path: str, error: str, action: str) -> None:
        """Handle transfer error"""
        with QMutexLocker(self.mutex):
            if transfer_id in self.transfers:
                self.transfers[transfer_id].error_message = f"{path}: {error}"
        
        self.transfer_updated.emit(transfer_id, {'error': f"{path}: {error}"})
        self.logger.error(f"Transfer {transfer_id} error: {path}: {error}")
    
    def _handle_conflict_resolution(self, source_path: str, dest_path: str, operation_type: str, response_holder: object, worker):
        """Handle file conflict resolution from worker thread"""
        try:
            if operation_type == 'merge_file':
                # Show simplified merge conflict dialog
                dialog = MergeFileConflictDialog(source_path, dest_path, self.parent())
            else:
                # Show full conflict dialog on main thread
                dialog = ConflictResolutionDialog(source_path, dest_path, operation_type, self.parent())
            
            result = dialog.exec_()
            
            if result == QDialog.Accepted:
                resolution = dialog.get_resolution()
                worker.resolve_conflict(resolution)
            else:
                # User cancelled, treat as skip
                worker.resolve_conflict({'action': 'skip', 'apply_to_all': False})
                
        except Exception as e:
            print(f"Error in conflict resolution: {e}")
            # Fallback to skip on error
            worker.resolve_conflict({'action': 'skip', 'apply_to_all': False})
    
    def cancel_transfer(self, transfer_id: str) -> bool:
        """Cancel a specific transfer"""
        with QMutexLocker(self.mutex):
            if transfer_id not in self.transfers:
                return False
                
            transfer_info = self.transfers[transfer_id]
            
            if transfer_info.status == TransferStatus.QUEUED:
                transfer_info.status = TransferStatus.CANCELLED
                return True
            elif transfer_info.status == TransferStatus.RUNNING:
                if transfer_id in self.active_workers:
                    worker = self.active_workers[transfer_id]
                    worker.operation.cancel()
                    transfer_info.status = TransferStatus.CANCELLED
                    return True
        
        return False
    
    def pause_transfer(self, transfer_id: str) -> bool:
        """Pause a specific transfer"""
        with QMutexLocker(self.mutex):
            if transfer_id not in self.transfers:
                return False
                
            transfer_info = self.transfers[transfer_id]
            
            if transfer_info.status == TransferStatus.RUNNING:
                if transfer_id in self.active_workers:
                    worker = self.active_workers[transfer_id]
                    worker.operation.pause()
                    transfer_info.status = TransferStatus.PAUSED
                    return True
        
        return False
    
    def resume_transfer(self, transfer_id: str) -> bool:
        """Resume a paused transfer"""
        with QMutexLocker(self.mutex):
            if transfer_id not in self.transfers:
                return False
                
            transfer_info = self.transfers[transfer_id]
            
            if transfer_info.status == TransferStatus.PAUSED:
                if transfer_id in self.active_workers:
                    worker = self.active_workers[transfer_id]
                    worker.operation.resume()
                    transfer_info.status = TransferStatus.RUNNING
                    return True
        
        return False
    
    def get_transfer_info(self, transfer_id: str) -> Optional[TransferInfo]:
        """Get information about a specific transfer"""
        with QMutexLocker(self.mutex):
            return self.transfers.get(transfer_id)
    
    def get_all_transfers(self) -> List[TransferInfo]:
        """Get information about all transfers"""
        with QMutexLocker(self.mutex):
            return list(self.transfers.values())
    
    def get_active_transfers(self) -> List[TransferInfo]:
        """Get all active (running or paused) transfers"""
        with QMutexLocker(self.mutex):
            return [t for t in self.transfers.values() 
                   if t.status in [TransferStatus.RUNNING, TransferStatus.PAUSED]]
    
    def clear_completed_transfers(self) -> None:
        """Remove completed and failed transfers from the list"""
        with QMutexLocker(self.mutex):
            completed_ids = [tid for tid, transfer in self.transfers.items() 
                           if transfer.status in [TransferStatus.COMPLETED, TransferStatus.FAILED, TransferStatus.CANCELLED]]
            
            for transfer_id in completed_ids:
                del self.transfers[transfer_id]
    
    def shutdown(self) -> None:
        """Shutdown the transfer manager and cancel all operations"""
        self.transfer_processor_timer.stop()
        
        with QMutexLocker(self.mutex):
            # Cancel all active transfers
            for transfer_id in list(self.active_workers.keys()):
                worker = self.active_workers[transfer_id]
                worker.operation.cancel()
                worker.wait(5000)  # Wait up to 5 seconds for graceful shutdown
                worker.deleteLater()
            
            self.active_workers.clear()
            self.transfers.clear()

# Global transfer manager instance
transfer_manager = ConcurrentTransferManager()

# ==================== TRANSFER PROGRESS UI WIDGET ====================

class TransferProgressWidget(QWidget):
    """Widget to display progress of a single file transfer"""
    
    def __init__(self, transfer_id: str, transfer_info: TransferInfo, parent=None):
        super().__init__(parent)
        self.transfer_id = transfer_id
        self.logger = setup_logger(f'{__name__}.TransferProgressWidget')
        self._setup_ui(transfer_info)
        
    def _setup_ui(self, transfer_info: TransferInfo) -> None:
        """Setup the UI components"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        
        # Header with operation type and action buttons
        header_layout = QHBoxLayout()
        
        # Operation info
        operation_text = f"{transfer_info.operation_type.title()}: {len(transfer_info.source_paths)} items"
        if len(transfer_info.source_paths) == 1:
            operation_text = f"{transfer_info.operation_type.title()}: {transfer_info.source_paths[0].name}"
        
        self.operation_label = QLabel(operation_text)
        self.operation_label.setStyleSheet("font-weight: bold;")
        header_layout.addWidget(self.operation_label)
        
        header_layout.addStretch()
        
        # Control buttons
        self.pause_button = QPushButton("⏸")
        self.pause_button.setToolTip("Pause transfer")
        self.pause_button.setMaximumWidth(30)
        self.pause_button.clicked.connect(self._toggle_pause)
        header_layout.addWidget(self.pause_button)
        
        self.cancel_button = QPushButton("✖")
        self.cancel_button.setToolTip("Cancel transfer")
        self.cancel_button.setMaximumWidth(30)
        self.cancel_button.clicked.connect(self._cancel_transfer)
        header_layout.addWidget(self.cancel_button)
        
        layout.addLayout(header_layout)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(100)
        self.progress_bar.setValue(int(transfer_info.progress))
        layout.addWidget(self.progress_bar)
        
        # Status information
        status_layout = QHBoxLayout()
        
        # Current file
        self.current_file_label = QLabel("Preparing...")
        self.current_file_label.setStyleSheet("color: #666; font-size: 10px;")
        status_layout.addWidget(self.current_file_label)
        
        status_layout.addStretch()
        
        # Speed and ETA
        self.speed_eta_label = QLabel("")
        self.speed_eta_label.setStyleSheet("color: #666; font-size: 10px;")
        status_layout.addWidget(self.speed_eta_label)
        
        layout.addLayout(status_layout)
        
        # File progress
        self.file_progress_label = QLabel("0 / 0 files")
        self.file_progress_label.setStyleSheet("color: #666; font-size: 10px;")
        layout.addWidget(self.file_progress_label)
        
        # Update initial state
        self._update_status(transfer_info.status)
    
    def update_transfer(self, update_data: dict) -> None:
        """Update the widget with new transfer data"""
        if 'progress' in update_data:
            self.progress_bar.setValue(int(update_data['progress']))
        
        if 'current_file' in update_data:
            current_file = update_data['current_file']
            if len(current_file) > 50:
                current_file = "..." + current_file[-47:]
            self.current_file_label.setText(current_file)
        
        if 'processed_files' in update_data and 'total_files' in update_data:
            self.file_progress_label.setText(f"{update_data['processed_files']} / {update_data['total_files']} files")
        
        if 'speed' in update_data or 'eta' in update_data:
            speed = update_data.get('speed', '')
            eta = update_data.get('eta', '')
            if speed and eta:
                self.speed_eta_label.setText(f"{speed} • ETA: {eta}")
            elif speed:
                self.speed_eta_label.setText(speed)
            elif eta:
                self.speed_eta_label.setText(f"ETA: {eta}")
        
        if 'error' in update_data:
            self.current_file_label.setText(f"Error: {update_data['error']}")
            self.current_file_label.setStyleSheet("color: #d32f2f; font-size: 10px;")
    
    def _update_status(self, status: TransferStatus) -> None:
        """Update UI based on transfer status"""
        if status == TransferStatus.RUNNING:
            self.pause_button.setText("⏸")
            self.pause_button.setToolTip("Pause transfer")
            self.progress_bar.setStyleSheet("")
        elif status == TransferStatus.PAUSED:
            self.pause_button.setText("▶")
            self.pause_button.setToolTip("Resume transfer")
            self.progress_bar.setStyleSheet("QProgressBar::chunk { background-color: orange; }")
        elif status == TransferStatus.COMPLETED:
            self.pause_button.setEnabled(False)
            self.cancel_button.setText("✓")
            self.cancel_button.setToolTip("Completed")
            self.cancel_button.setEnabled(False)
            self.progress_bar.setStyleSheet("QProgressBar::chunk { background-color: green; }")
            self.current_file_label.setText("Transfer completed successfully")
            self.current_file_label.setStyleSheet("color: #388e3c; font-size: 10px;")
        elif status == TransferStatus.FAILED:
            self.pause_button.setEnabled(False)
            self.cancel_button.setText("✗")
            self.cancel_button.setToolTip("Failed")
            self.cancel_button.setEnabled(False)
            self.progress_bar.setStyleSheet("QProgressBar::chunk { background-color: red; }")
        elif status == TransferStatus.CANCELLED:
            self.pause_button.setEnabled(False)
            self.cancel_button.setEnabled(False)
            self.progress_bar.setStyleSheet("QProgressBar::chunk { background-color: gray; }")
            self.current_file_label.setText("Transfer cancelled")
            self.current_file_label.setStyleSheet("color: #666; font-size: 10px;")
    
    def _toggle_pause(self) -> None:
        """Toggle pause/resume for this transfer"""
        transfer_info = transfer_manager.get_transfer_info(self.transfer_id)
        if not transfer_info:
            return
            
        if transfer_info.status == TransferStatus.RUNNING:
            if transfer_manager.pause_transfer(self.transfer_id):
                self._update_status(TransferStatus.PAUSED)
        elif transfer_info.status == TransferStatus.PAUSED:
            if transfer_manager.resume_transfer(self.transfer_id):
                self._update_status(TransferStatus.RUNNING)
    
    def _cancel_transfer(self) -> None:
        """Cancel this transfer"""
        if transfer_manager.cancel_transfer(self.transfer_id):
            self._update_status(TransferStatus.CANCELLED)

class TransferManagerWidget(QWidget):
    """Widget to display and manage all active file transfers"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.transfer_widgets: Dict[str, TransferProgressWidget] = {}
        self.logger = setup_logger(f'{__name__}.TransferManagerWidget')
        self._setup_ui()
        self._connect_signals()
        
    def _setup_ui(self) -> None:
        """Setup the UI components"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        
        # Header
        header_layout = QHBoxLayout()
        
        self.title_label = QLabel("File Transfers")
        self.title_label.setStyleSheet("font-weight: bold; font-size: 12px;")
        header_layout.addWidget(self.title_label)
        
        header_layout.addStretch()
        
        self.clear_button = QPushButton("Clear Completed")
        self.clear_button.clicked.connect(self._clear_completed)
        header_layout.addWidget(self.clear_button)
        
        layout.addLayout(header_layout)
        
        # Transfers container
        self.transfers_layout = QVBoxLayout()
        layout.addLayout(self.transfers_layout)
        
        # No transfers message
        self.no_transfers_label = QLabel("No active transfers")
        self.no_transfers_label.setStyleSheet("color: #666; font-style: italic; text-align: center;")
        self.transfers_layout.addWidget(self.no_transfers_label)
        
        layout.addStretch()
    
    def _connect_signals(self) -> None:
        """Connect signals from the transfer manager"""
        transfer_manager.transfer_added.connect(self._on_transfer_added)
        transfer_manager.transfer_updated.connect(self._on_transfer_updated)
        transfer_manager.transfer_completed.connect(self._on_transfer_completed)
    
    def _on_transfer_added(self, transfer_id: str) -> None:
        """Handle new transfer added"""
        transfer_info = transfer_manager.get_transfer_info(transfer_id)
        if not transfer_info:
            return
            
        # Hide no transfers message
        self.no_transfers_label.setVisible(False)
        
        # Make sure the parent widget is visible when transfers are added
        if self.parent() and hasattr(self.parent(), 'transfer_manager_widget'):
            self.parent().transfer_manager_widget.show()
        
        # Create widget for this transfer
        widget = TransferProgressWidget(transfer_id, transfer_info, self)
        self.transfer_widgets[transfer_id] = widget
        self.transfers_layout.addWidget(widget)
        
        self._update_title()
        self.logger.debug(f"Added transfer widget for {transfer_id}")
    
    def _on_transfer_updated(self, transfer_id: str, update_data: dict) -> None:
        """Handle transfer progress update"""
        if transfer_id in self.transfer_widgets:
            self.transfer_widgets[transfer_id].update_transfer(update_data)
    
    def _on_transfer_completed(self, transfer_id: str, success: bool, message: str) -> None:
        """Handle transfer completion"""
        if transfer_id in self.transfer_widgets:
            transfer_info = transfer_manager.get_transfer_info(transfer_id)
            if transfer_info:
                self.transfer_widgets[transfer_id]._update_status(transfer_info.status)
        
        self._update_title()
        self.logger.info(f"Transfer {transfer_id} completed: success={success}")
    
    def _clear_completed(self) -> None:
        """Clear completed transfers"""
        transfer_manager.clear_completed_transfers()
        
        # Remove widgets for completed transfers
        completed_widgets = []
        for transfer_id, widget in self.transfer_widgets.items():
            transfer_info = transfer_manager.get_transfer_info(transfer_id)
            if not transfer_info:  # Transfer was cleared
                completed_widgets.append(transfer_id)
        
        for transfer_id in completed_widgets:
            widget = self.transfer_widgets[transfer_id]
            self.transfers_layout.removeWidget(widget)
            widget.deleteLater()
            del self.transfer_widgets[transfer_id]
        
        # Show no transfers message if needed
        if not self.transfer_widgets:
            self.no_transfers_label.setVisible(True)
        
        self._update_title()
    
    def _update_title(self) -> None:
        """Update the title with active transfer count"""
        active_count = len([t for t in transfer_manager.get_all_transfers() 
                           if t.status in [TransferStatus.RUNNING, TransferStatus.PAUSED, TransferStatus.QUEUED]])
        
        if active_count > 0:
            self.title_label.setText(f"File Transfers ({active_count} active)")
        else:
            self.title_label.setText("File Transfers")

# Background Operations Classes
class AsyncFileOperation(QObject):
    statusChanged = pyqtSignal(str)  # Current operation status
    finished = pyqtSignal(bool, str, dict)  # Success, message, stats
    errorOccurred = pyqtSignal(str, str, str)  # File path, error message, suggested action
    
    def __init__(self, source_paths, destination_path, operation_type):
        super().__init__()
        self.source_paths = source_paths
        self.destination_path = destination_path
        self.operation_type = operation_type  # 'copy', 'move', 'delete'
        self.cancelled = False
        self.paused = False
        self.start_time = None
        self.total_bytes = 0
        self.processed_bytes = 0
        self.skip_errors = False
        self.overwrite_all = False
        self.skip_all = False
        
    def cancel(self):
        self.cancelled = True
        
    def pause(self):
        self.paused = True
        
    def resume(self):
        self.paused = False
        
    def set_error_handling(self, skip_errors=False):
        self.skip_errors = skip_errors

class AsyncFileOperationWorker(QThread):
    """Advanced worker thread for asynchronous file operations"""
    progress = pyqtSignal(int)
    fileProgress = pyqtSignal(int, int)
    byteProgress = pyqtSignal(int, int)
    speedUpdate = pyqtSignal(str)
    etaUpdate = pyqtSignal(str)
    statusChanged = pyqtSignal(str)
    finished = pyqtSignal(bool, str, dict)
    error = pyqtSignal(str)  # Simplified error signal for compatibility
    errorOccurred = pyqtSignal(str, str, str)
    confirmationNeeded = pyqtSignal(str, str, str)  # Title, message, file path
    conflictResolution = pyqtSignal(str, str, str, object)  # source, dest, operation, response_object
    
    def __init__(self, operation):
        super().__init__()
        self.operation = operation
        self.buffer_size = 64 * 1024  # 64KB buffer for copying
        self.update_interval = 0.5  # Update progress every 500ms
        self.last_update_time = 0
        self.last_processed_bytes = 0
        
        # Conflict resolution state
        self.conflict_resolution = None
        self.apply_to_all_conflicts = False
        self.waiting_for_conflict_resolution = False
    
    def resolve_conflict(self, resolution_data):
        """Called from main thread to provide conflict resolution"""
        self.conflict_resolution = resolution_data
        self.waiting_for_conflict_resolution = False
    
    def _handle_file_conflict(self, source_path, dest_path):
        """Handle file conflicts with user interaction"""
        if self.apply_to_all_conflicts and self.conflict_resolution:
            # Use previous resolution if "apply to all" was selected
            return self._apply_conflict_resolution(source_path, dest_path, self.conflict_resolution)
        
        # Create a response object to hold the result
        response_holder = {'resolved': False, 'result': None}
        
        # Signal the main thread to show conflict dialog
        self.conflictResolution.emit(str(source_path), str(dest_path), self.operation.operation_type, response_holder)
        
        # Wait for resolution from main thread
        self.waiting_for_conflict_resolution = True
        while self.waiting_for_conflict_resolution and not self.operation.cancelled:
            QThread.msleep(50)  # Small delay to prevent busy waiting
        
        if self.operation.cancelled:
            return None
            
        if self.conflict_resolution:
            # Update apply_to_all state
            if self.conflict_resolution.get('apply_to_all', False):
                self.apply_to_all_conflicts = True
            
            return self._apply_conflict_resolution(source_path, dest_path, self.conflict_resolution)
        
        # Default to skip if no resolution
        return None
    
    def _apply_conflict_resolution(self, source_path, dest_path, resolution):
        """Apply the conflict resolution choice"""
        action = resolution.get('action', 'skip')
        
        if action == 'replace':
            return dest_path
        elif action == 'skip':
            return None
        elif action == 'keep_both':
            return get_nonconflicting_name(dest_path)
        elif action == 'rename':
            new_name = resolution.get('new_name', '')
            if new_name:
                parent_dir = Path(dest_path).parent
                return str(parent_dir / new_name)
            else:
                return get_nonconflicting_name(dest_path)
        elif action == 'merge':
            # For merge, return a special indicator to handle directory merging
            return 'MERGE_DIRECTORIES'
        
        # Default fallback
        return dest_path
        
    def run(self):
        """Main execution thread"""
        try:
            self.operation.start_time = time.time()
            
            # Calculate total size for accurate progress
            if self.operation.operation_type in ['copy', 'move']:
                self.operation.total_bytes = self._calculate_total_size()
                
            if self.operation.operation_type == 'copy':
                self._async_copy_files()
            elif self.operation.operation_type == 'move':
                self._async_move_files()
            elif self.operation.operation_type == 'delete':
                self._async_delete_files()
            
            # Always emit finished signal, whether cancelled or completed
            if self.operation.cancelled:
                self.finished.emit(False, "Operation cancelled by user", {})
            else:
                # Calculate final statistics
                elapsed_time = time.time() - self.operation.start_time
                stats = {
                    'elapsed_time': elapsed_time,
                    'total_bytes': self.operation.total_bytes,
                    'average_speed': self.operation.total_bytes / elapsed_time if elapsed_time > 0 else 0,
                    'files_processed': len(self.operation.source_paths)
                }
                self.finished.emit(True, "Operation completed successfully", stats)
        except Exception as e:
            self.finished.emit(False, str(e), {})
    
    def _calculate_total_size(self):
        """Calculate total size of all files to be processed"""
        total_size = 0
        processed_paths = 0
        total_paths = len(self.operation.source_paths)
        
        # Emit initial status
        self.statusChanged.emit("Calculating total size...")
        
        for source_path in self.operation.source_paths:
            if self.operation.cancelled:
                return total_size
                
            processed_paths += 1
            try:
                if os.path.isfile(source_path):
                    total_size += os.path.getsize(source_path)
                elif os.path.isdir(source_path):
                    # Emit progress while calculating
                    self.statusChanged.emit(f"Scanning: {os.path.basename(source_path)}...")
                    dir_size = 0
                    file_count = 0
                    
                    for root, dirs, files in os.walk(source_path):
                        if self.operation.cancelled:
                            return total_size
                            
                        for file in files:
                            if self.operation.cancelled:
                                return total_size
                                
                            try:
                                file_path = os.path.join(root, file)
                                file_size = os.path.getsize(file_path)
                                dir_size += file_size
                                file_count += 1
                                
                                # Update progress every 100 files to avoid UI spam
                                if file_count % 100 == 0:
                                    self.statusChanged.emit(f"Scanned {file_count} files in {os.path.basename(source_path)}...")
                                    
                            except (OSError, IOError):
                                continue  # Skip inaccessible files
                                
                    total_size += dir_size
                    
                # Update overall scanning progress
                scan_progress = int((processed_paths / total_paths) * 100)
                self.progress.emit(min(scan_progress, 99))  # Don't show 100% during scanning
                
            except (OSError, IOError):
                continue  # Skip inaccessible paths
                
        self.statusChanged.emit("Starting file operation...")
        return total_size
    
    def _async_copy_files(self):
        """Asynchronous file copying with detailed progress"""
        total_files = len(self.operation.source_paths)
        
        for file_index, source_path in enumerate(self.operation.source_paths):
            if self.operation.cancelled:
                return
                
            # Wait if paused
            while self.operation.paused and not self.operation.cancelled:
                QThread.msleep(100)
            
            self.fileProgress.emit(file_index + 1, total_files)
            filename = os.path.basename(source_path)
            self.statusChanged.emit(f"Copying: {filename}")
            
            try:
                if os.path.isdir(source_path):
                    self._async_copy_directory(source_path, self.operation.destination_path)
                else:
                    dest_path = os.path.join(self.operation.destination_path, filename)
                    self._async_copy_file(source_path, dest_path)
            except Exception as e:
                if not self.operation.skip_errors:
                    self.errorOccurred.emit(source_path, str(e), "skip_retry_abort")
                    self.error.emit(f"Error copying {filename}: {str(e)}")
                    # Wait for user decision or continue if skip_errors is True
                
            self._update_progress()
    
    def _async_copy_file(self, source_path, dest_path):
        """Copy a single file with progress tracking"""
        file_size = os.path.getsize(source_path)
        copied_bytes = 0
        
        # Handle file conflicts with advanced resolution
        if os.path.exists(dest_path):
            resolved_dest = self._handle_file_conflict(source_path, dest_path)
            if resolved_dest is None:
                # Skip this file
                return
            dest_path = resolved_dest
        
        try:
            with open(source_path, 'rb') as src, open(dest_path, 'wb') as dst:
                while copied_bytes < file_size:
                    if self.operation.cancelled:
                        # Clean up partial file on cancellation
                        try:
                            dst.close()
                            if os.path.exists(dest_path):
                                os.remove(dest_path)
                        except:
                            pass
                        return
                    # Wait if paused
                    while self.operation.paused and not self.operation.cancelled:
                        QThread.msleep(100)
                    # Read chunk
                    chunk_size = min(self.buffer_size, file_size - copied_bytes)
                    chunk = src.read(chunk_size)
                    if not chunk:
                        break
                    dst.write(chunk)
                    copied_bytes += len(chunk)
                    self.operation.processed_bytes += len(chunk)
                    # Update progress periodically
                    if time.time() - self.last_update_time > self.update_interval:
                        self._update_progress()
            # Preserve file attributes
            try:
                shutil.copystat(source_path, dest_path)
            except (OSError, IOError):
                pass  # Not critical if we can't copy attributes
        except Exception as e:
            # Clean up partial file on error
            if os.path.exists(dest_path):
                try:
                    os.remove(dest_path)
                except:
                    pass
            raise e
    
    def _async_copy_file_with_merge_logic(self, source_path, dest_path):
        """Copy a single file with merge-specific conflict handling (overwrite/skip only)"""
        # If destination doesn't exist, just copy normally
        if not os.path.exists(dest_path):
            self._async_copy_file_without_conflict_check(source_path, dest_path)
            return
        
        # For merge mode, use simplified conflict resolution
        resolved_dest = self._handle_merge_file_conflict(source_path, dest_path)
        if resolved_dest is None:
            # Skip this file
            return
        
        # Copy the file (resolved_dest should be the same as dest_path for overwrite)
        self._async_copy_file_without_conflict_check(source_path, resolved_dest)
    
    def _async_copy_file_without_conflict_check(self, source_path, dest_path):
        """Copy a single file without conflict checking (internal method)"""
        file_size = os.path.getsize(source_path)
        copied_bytes = 0
        
        try:
            with open(source_path, 'rb') as src, open(dest_path, 'wb') as dst:
                while copied_bytes < file_size:
                    if self.operation.cancelled:
                        # Clean up partial file on cancellation
                        try:
                            dst.close()
                            if os.path.exists(dest_path):
                                os.remove(dest_path)
                        except:
                            pass
                        return
                    # Wait if paused
                    while self.operation.paused and not self.operation.cancelled:
                        QThread.msleep(100)
                    # Read chunk
                    chunk_size = min(self.buffer_size, file_size - copied_bytes)
                    chunk = src.read(chunk_size)
                    if not chunk:
                        break
                    dst.write(chunk)
                    copied_bytes += len(chunk)
                    self.operation.processed_bytes += len(chunk)
                    # Update progress periodically
                    if time.time() - self.last_update_time > self.update_interval:
                        self._update_progress()
            # Preserve file attributes
            try:
                shutil.copystat(source_path, dest_path)
            except (OSError, IOError):
                pass  # Not critical if we can't copy attributes
        except Exception as e:
            # Clean up partial file on error
            if os.path.exists(dest_path):
                try:
                    os.remove(dest_path)
                except:
                    pass
            raise e
    
    def _handle_merge_file_conflict(self, source_path, dest_path):
        """Handle file conflicts during directory merge with simplified overwrite/skip dialog"""
        if self.apply_to_all_conflicts and self.conflict_resolution:
            # Use previous resolution if "apply to all" was selected
            action = self.conflict_resolution.get('action', 'skip')
            if action == 'replace':
                return dest_path
            else:  # skip
                return None
        
        # Create a response object to hold the result
        response_holder = {'resolved': False, 'result': None}
        
        # Signal the main thread to show simplified merge conflict dialog
        self.conflictResolution.emit(str(source_path), str(dest_path), 'merge_file', response_holder)
        
        # Wait for resolution from main thread
        self.waiting_for_conflict_resolution = True
        while self.waiting_for_conflict_resolution and not self.operation.cancelled:
            QThread.msleep(50)  # Small delay to prevent busy waiting
        
        if self.operation.cancelled:
            return None
            
        if self.conflict_resolution:
            # Update apply_to_all state
            if self.conflict_resolution.get('apply_to_all', False):
                self.apply_to_all_conflicts = True
            
            action = self.conflict_resolution.get('action', 'skip')
            if action == 'replace':
                return dest_path
            else:  # skip
                return None
        
        # Default to skip if no resolution
        return None
    
    def _async_copy_directory(self, source_dir, dest_base, is_merge_mode=False):
        """Recursively copy directory structure with conflict resolution"""
        dir_name = os.path.basename(source_dir)
        dest_dir = os.path.join(dest_base, dir_name)
        merge_mode = is_merge_mode
        
        # Handle directory conflicts with advanced resolution
        if os.path.exists(dest_dir) and not is_merge_mode:
            resolved_dest = self._handle_file_conflict(source_dir, dest_dir)
            if resolved_dest is None:
                # Skip this directory
                return
            elif resolved_dest == 'MERGE_DIRECTORIES':
                # Merge: use existing destination directory and enable merge mode
                dest_dir = dest_dir
                merge_mode = True
            else:
                # Replace, rename, or keep both
                if resolved_dest != dest_dir:
                    # If renamed or keep both, use the new path
                    dest_dir = resolved_dest
                if os.path.exists(dest_dir) and resolved_dest != 'MERGE_DIRECTORIES':
                    # For replace: remove existing directory first
                    import shutil
                    shutil.rmtree(dest_dir)
        
        # Create destination directory if it doesn't exist
        if not os.path.exists(dest_dir):
            os.makedirs(dest_dir)
        
        # Copy all files and subdirectories
        for root, dirs, files in os.walk(source_dir):
            if self.operation.cancelled:
                return
                
            # Calculate relative path
            rel_path = os.path.relpath(root, source_dir)
            if rel_path == '.':
                target_dir = dest_dir
            else:
                target_dir = os.path.join(dest_dir, rel_path)
                if not os.path.exists(target_dir):
                    os.makedirs(target_dir)
            
            # Copy files in current directory
            for file in files:
                if self.operation.cancelled:
                    return
                    
                source_file = os.path.join(root, file)
                dest_file = os.path.join(target_dir, file)
                
                try:
                    if merge_mode:
                        self._async_copy_file_with_merge_logic(source_file, dest_file)
                    else:
                        self._async_copy_file(source_file, dest_file)
                except Exception as e:
                    if not self.operation.skip_errors:
                        self.errorOccurred.emit(source_file, str(e), "skip_retry_abort")
            
            # Handle subdirectories recursively
            for subdir in dirs:
                if self.operation.cancelled:
                    return
                    
                source_subdir = os.path.join(root, subdir)
                # For subdirectories in merge mode, continue merge mode
                self._async_copy_directory(source_subdir, target_dir, merge_mode)
    
    def _async_move_files(self):
        """Move files.

        Prefer an atomic/fast filesystem rename (os.replace) when possible
        (same filesystem). If that fails (cross-device link / EXDEV), fall
        back to copy+delete behavior for that specific item.
        """
        import errno

        total_files = len(self.operation.source_paths)

        for file_index, source_path in enumerate(self.operation.source_paths):
            if self.operation.cancelled:
                return

            # Wait if paused
            while self.operation.paused and not self.operation.cancelled:
                QThread.msleep(100)

            self.fileProgress.emit(file_index + 1, total_files)
            filename = os.path.basename(source_path)
            self.statusChanged.emit(f"Moving: {filename}")

            try:
                # Determine final destination path
                dest_path = os.path.join(self.operation.destination_path, filename)
                dest_path = get_nonconflicting_name(dest_path)

                # Compute source size before any move/delete so we can track progress
                def _get_path_size(p):
                    if os.path.isfile(p):
                        try:
                            return os.path.getsize(p)
                        except Exception:
                            return 0
                    size = 0
                    for root, dirs, files in os.walk(p):
                        for f in files:
                            try:
                                size += os.path.getsize(os.path.join(root, f))
                            except Exception:
                                continue
                    return size

                src_size = _get_path_size(source_path)

                try:
                    # Try an atomic/fast move first
                    print(f"[MOVE-DEBUG] Attempting fast move (os.replace): {source_path} -> {dest_path}")
                    os.replace(source_path, dest_path)
                    # Update processed bytes and progress
                    self.operation.processed_bytes += src_size
                    self._update_progress()
                    print(f"[MOVE-DEBUG] Fast move succeeded: {dest_path}")

                except OSError as e:
                    # If cross-device link (EXDEV) or other issue, fall back to copy+delete
                    if getattr(e, 'errno', None) == errno.EXDEV:
                        print(f"[MOVE-DEBUG] EXDEV encountered, falling back to copy+delete for: {source_path}")
                        # Cross-device; perform per-item copy then delete
                        if os.path.isdir(source_path):
                            self._async_copy_directory(source_path, self.operation.destination_path)
                            # After copy, remove source directory
                            try:
                                shutil.rmtree(source_path)
                            except Exception as de:
                                if not self.operation.skip_errors:
                                    self.errorOccurred.emit(source_path, str(de), 'skip_retry_abort')
                        else:
                            dest_file = os.path.join(self.operation.destination_path, filename)
                            dest_file = get_nonconflicting_name(dest_file)
                            self._async_copy_file(source_path, dest_file)
                            try:
                                os.remove(source_path)
                            except Exception as de:
                                if not self.operation.skip_errors:
                                    self.errorOccurred.emit(source_path, str(de), 'skip_retry_abort')
                        print(f"[MOVE-DEBUG] Fallback copy+delete completed for: {source_path}")
                        # After fallback copy/delete, ensure progress updated (copy routines update bytes)
                    else:
                        print(f"[MOVE-DEBUG] OSError during os.replace for {source_path}: {e}")
                        # Unknown OSError; re-raise so caller can handle
                        raise

            except Exception as e:
                if not self.operation.skip_errors:
                    self.errorOccurred.emit(source_path, str(e), 'skip_retry_abort')
                    self.error.emit(f"Error moving {filename}: {str(e)}")

            # Update overall progress at end of item
            self._update_progress()
    
    def _async_delete_files(self):
        """Delete files with progress tracking"""
        total_files = len(self.operation.source_paths)
        
        for file_index, source_path in enumerate(self.operation.source_paths):
            if self.operation.cancelled:
                return
                
            while self.operation.paused and not self.operation.cancelled:
                QThread.msleep(100)
            
            self.fileProgress.emit(file_index + 1, total_files)
            filename = os.path.basename(source_path)
            self.statusChanged.emit(f"Deleting: {filename}")
            
            try:
                if os.path.isdir(source_path):
                    shutil.rmtree(source_path)
                else:
                    os.remove(source_path)
            except Exception as e:
                if not self.operation.skip_errors:
                    self.errorOccurred.emit(source_path, str(e), "skip_retry_abort")
            
            # Update progress
            progress = int((file_index + 1) / total_files * 100)
            self.progress.emit(progress)
    
    def _update_progress(self):
        """Update progress indicators with speed and ETA calculations"""
        current_time = time.time()
        self.last_update_time = current_time
        
        if self.operation.total_bytes > 0:
            # Calculate overall progress
            progress = int((self.operation.processed_bytes / self.operation.total_bytes) * 100)
            self.progress.emit(progress)
            self.byteProgress.emit(self.operation.processed_bytes, self.operation.total_bytes)
            
            # Calculate speed
            elapsed = current_time - self.operation.start_time
            if elapsed > 0:
                bytes_per_second = self.operation.processed_bytes / elapsed
                speed_str = self._format_bytes_per_second(bytes_per_second)
                self.speedUpdate.emit(speed_str)
                
                # Calculate ETA
                if bytes_per_second > 0:
                    remaining_bytes = self.operation.total_bytes - self.operation.processed_bytes
                    eta_seconds = remaining_bytes / bytes_per_second
                    eta_str = self._format_time_duration(eta_seconds)
                    self.etaUpdate.emit(eta_str)
    
    def _format_bytes_per_second(self, bytes_per_second):
        """Format transfer speed in human readable format"""
        units = ['B/s', 'KB/s', 'MB/s', 'GB/s']
        size = bytes_per_second
        for unit in units:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} TB/s"
    
    def _format_time_duration(self, seconds):
        """Format time duration in human readable format"""
        if seconds < 60:
            return f"{int(seconds)} seconds"
        elif seconds < 3600:
            minutes = int(seconds / 60)
            return f"{minutes} minute{'s' if minutes != 1 else ''}"
        else:
            hours = int(seconds / 3600)
            minutes = int((seconds % 3600) / 60)
            return f"{hours}h {minutes}m"

class EnhancedProgressDialog(QDialog):
    def cancel_operation(self):
        """Cancel the current file operation and update the UI."""
        if self.operation:
            self.operation.cancel()
            self.status_label.setText("Cancelling...")
            self.cancel_button.setEnabled(False)
    def toggle_pause(self):
        """Toggle pause/resume for the current operation and update button text."""
        if self.operation:
            self.operation.toggle_paused()
            if self.operation.paused:
                self.pause_button.setText("Resume")
                self.status_label.setText("Paused")
            else:
                self.pause_button.setText("Pause")
                self.status_label.setText("Resuming...")
    """Enhanced progress dialog with detailed statistics and controls"""
    
    def __init__(self, operation_name, total_files=0, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"{operation_name} - File Operation")
        # Make dialog non-modal to prevent UI blocking
        self.setModal(False)
        self.setMinimumSize(450, 300)
        # Keep on top but don't block the main window
        self.setWindowFlags(Qt.Dialog | Qt.WindowStaysOnTopHint)
        self.operation_worker = None
        self.operation = None
        self.total_files = total_files
        self.setup_ui()
        
    def setup_ui(self):
        """Setup the enhanced progress dialog UI"""
        layout = QVBoxLayout()
        
        # Operation status
        self.status_label = QLabel("Initializing...")
        self.status_label.setStyleSheet("font-weight: bold; font-size: 12px;")
        layout.addWidget(self.status_label)
        
        # Overall progress bar
        self.overall_progress = QProgressBar()
        self.overall_progress.setRange(0, 100)
        self.overall_progress.setValue(0)
        self.overall_progress.setTextVisible(True)
        layout.addWidget(self.overall_progress)
        
        # File progress
        self.file_progress_label = QLabel("Files: 0 of 0")
        layout.addWidget(self.file_progress_label)
        
        # Speed and ETA information
        info_layout = QHBoxLayout()
        self.speed_label = QLabel("Speed: --")
        self.eta_label = QLabel("ETA: --")
        info_layout.addWidget(self.speed_label)
        info_layout.addStretch()
        info_layout.addWidget(self.eta_label)
        layout.addLayout(info_layout)
        
        # Bytes progress bar
        self.bytes_progress = QProgressBar()
        self.bytes_progress.setRange(0, 100)
        self.bytes_progress.setValue(0)
        self.bytes_progress.setFormat("0 B / 0 B")
        layout.addWidget(self.bytes_progress)
        
        # Detailed statistics (expandable)
        self.stats_group = QGroupBox("Statistics")
        self.stats_group.setCheckable(True)
        self.stats_group.setChecked(False)
        stats_layout = QVBoxLayout()
        self.stats_text = QTextEdit()
        self.stats_text.setMaximumHeight(100)
        self.stats_text.setReadOnly(True)
        stats_layout.addWidget(self.stats_text)
        self.stats_group.setLayout(stats_layout)
        layout.addWidget(self.stats_group)
        
        # Control buttons
        button_layout = QHBoxLayout()
        
        self.pause_button = QPushButton("Pause")
        self.pause_button.clicked.connect(self.toggle_pause)
        button_layout.addWidget(self.pause_button)
        
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.cancel_operation)
        button_layout.addWidget(self.cancel_button)
        
        button_layout.addStretch()
        
        self.minimize_button = QPushButton("Minimize")
        self.minimize_button.clicked.connect(self.showMinimized)
        button_layout.addWidget(self.minimize_button)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
    
    def start_operation(self, operation):
        """Start the enhanced file operation"""
        self.operation = operation
        self.operation_worker = AsyncFileOperationWorker(operation)
        
        # Enable control buttons
        self.pause_button.setEnabled(True)
        self.cancel_button.setEnabled(True)
        self.pause_button.setText("Pause")
        self.status_label.setText("Starting operation...")
        self.status_label.setStyleSheet("color: blue; font-weight: bold;")
        
        # Connect all signals
        self.operation_worker.progress.connect(self.update_progress)
        self.operation_worker.fileProgress.connect(self.update_file_progress)
        self.operation_worker.byteProgress.connect(self.update_byte_progress)
        self.operation_worker.speedUpdate.connect(self.update_speed)
        self.operation_worker.etaUpdate.connect(self.update_eta)
        self.operation_worker.statusChanged.connect(self.update_status)
        self.operation_worker.finished.connect(self.on_finished)
        self.operation_worker.errorOccurred.connect(self.handle_error)
        
        self.operation_worker.start()
    
    def update_progress(self, percentage):
        """Update overall progress"""
        self.overall_progress.setValue(percentage)
    
    def update_file_progress(self, current, total):
        """Update file progress indicator"""
        self.file_progress_label.setText(f"Files: {current} of {total}")
    
    def update_byte_progress(self, processed, total):
        """Update byte progress bar"""
        if total > 0:
            percentage = int((processed / total) * 100)
            self.bytes_progress.setValue(percentage)
            self.bytes_progress.setFormat(f"{self._format_bytes(processed)} / {self._format_bytes(total)}")
    
    def update_speed(self, speed_str):
        """Update transfer speed display"""
        self.speed_label.setText(f"Speed: {speed_str}")
    
    def update_eta(self, eta_str):
        """Update estimated time remaining"""
        self.eta_label.setText(f"ETA: {eta_str}")
    
    def update_status(self, status):
        """Update current operation status"""
        self.status_label.setText(status)
        # Clear any special styling for normal status updates
        if self.operation and not self.operation.paused and not self.operation.cancelled:
            self.status_label.setStyleSheet("font-weight: bold; font-size: 12px;")
    
    def cleanup(self):
        """Clean up resources with improved shutdown handling"""
        try:
            if hasattr(self, 'loaded_chunks'):
                self.loaded_chunks.clear()
            if hasattr(self, 'directory_cache'):
                self.directory_cache.clear()
            if hasattr(self, 'executor') and self.executor:
                try:
                    self.executor.shutdown(wait=False)
                    import time
                    time.sleep(0.1)
                except Exception:
                    try:
                        self.executor.shutdown(wait=False)
                    except:
                        pass
        except Exception:
            pass
            # Set up a timeout to force close if cancellation hangs
            # This prevents the dialog from hanging indefinitely
            QTimer.singleShot(3000, self.force_close)  # 3 second timeout
        else:
            # Provide immediate feedback
            self.status_label.setText("Cannot cancel - no active operation")
            self.status_label.setStyleSheet("color: red; font-weight: bold;")
    
    def force_close(self):
        """Force close the dialog if cancellation is taking too long"""
        if self.operation and self.operation.cancelled:
            # If operation is cancelled but dialog still open, force close
            self.status_label.setText("Operation cancelled - closing dialog")
            self.accept()
    
    def handle_error(self, file_path, error_msg, suggested_action):
        """Handle errors during file operations"""
        reply = QMessageBox.question(
            self, 
            "File Operation Error",
            f"Error processing: {file_path}\n\nError: {error_msg}\n\nWhat would you like to do?",
            QMessageBox.Retry | QMessageBox.Ignore | QMessageBox.Abort,
            QMessageBox.Retry
        )
        
        if reply == QMessageBox.Abort:
            self.cancel_operation()
        elif reply == QMessageBox.Ignore:
            self.operation.skip_errors = True
    
    def on_finished(self, success, message, stats):
        """Handle operation completion"""
        if success:
            self.status_label.setText("Operation completed successfully!")
            self.overall_progress.setValue(100)
            
            # Update statistics
            if stats:
                stats_text = f"Completed in: {self._format_time_duration(stats.get('elapsed_time', 0))}\n"
                stats_text += f"Files processed: {stats.get('files_processed', 0)}\n"
                stats_text += f"Data processed: {self._format_bytes(stats.get('total_bytes', 0))}\n"
                if stats.get('average_speed', 0) > 0:
                    stats_text += f"Average speed: {self._format_bytes_per_second(stats.get('average_speed', 0))}\n"
                self.stats_text.setText(stats_text)
        else:
            self.status_label.setText(f"Operation failed: {message}")
        
        self.pause_button.setEnabled(False)
        self.cancel_button.setText("Close")
        self.cancel_button.clicked.disconnect()
        self.cancel_button.clicked.connect(self.accept)
        self.cancel_button.setEnabled(True)
        
        # Auto-close after successful operations (optional)
        if success:
            QTimer.singleShot(3000, self.accept)
    
    def _format_bytes(self, bytes_val):
        """Format bytes in human readable format"""
        units = ['B', 'KB', 'MB', 'GB', 'TB']
        size = float(bytes_val)
        for unit in units:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} PB"
    
    def _format_bytes_per_second(self, bytes_per_second):
        """Format transfer speed"""
        return self._format_bytes(bytes_per_second) + "/s"
    
    def _format_time_duration(self, seconds):
        """Format time duration"""
        if seconds < 60:
            return f"{int(seconds)}s"
        elif seconds < 3600:
            minutes = int(seconds / 60)
            seconds = int(seconds % 60)
            return f"{minutes}m {seconds}s"
        else:
            hours = int(seconds / 3600)
            minutes = int((seconds % 3600) / 60)
            return f"{hours}h {minutes}m"
    
    def closeEvent(self, event):
        """Handle dialog close event: just close immediately, no confirmation."""
        event.accept()

    def reject(self):
        """Handle dialog rejection (Escape key, X button): just close immediately, no confirmation."""
        super().reject()

class FileOperation(QObject):
    """Base class for file operations"""
    progress = pyqtSignal(int)  # Progress percentage
    finished = pyqtSignal(bool, str)  # Success, error message
    statusChanged = pyqtSignal(str)  # Status message
    
    def __init__(self, source_paths, destination_path, operation_type):
        super().__init__()
        self.source_paths = source_paths
        self.destination_path = destination_path
        self.operation_type = operation_type  # 'copy', 'move', 'delete'
        self.cancelled = False
        
    def cancel(self):
        self.cancelled = True

class FileOperationWorker(QThread):
    """Worker thread for file operations"""
    progress = pyqtSignal(int)
    finished = pyqtSignal(bool, str)
    statusChanged = pyqtSignal(str)
    
    def __init__(self, operation):
        super().__init__()
        self.operation = operation
        
    def run(self):
        try:
            if self.operation.operation_type == 'copy':
                self._copy_files()
            elif self.operation.operation_type == 'move':
                self._move_files()
            elif self.operation.operation_type == 'delete':
                self._delete_files()
            
            if not self.operation.cancelled:
                self.finished.emit(True, "Operation completed successfully")
        except Exception as e:
            self.finished.emit(False, str(e))
    
    def _copy_files(self):
        total_files = len(self.operation.source_paths)
        for i, source in enumerate(self.operation.source_paths):
            if self.operation.cancelled:
                return
                
            self.statusChanged.emit(f"Copying {os.path.basename(source)}...")
            
            if os.path.isdir(source):
                dest = os.path.join(self.operation.destination_path, os.path.basename(source))
                dest = get_nonconflicting_name(dest)
                shutil.copytree(source, dest, dirs_exist_ok=True)
            else:
                dest = os.path.join(self.operation.destination_path, os.path.basename(source))
                dest = get_nonconflicting_name(dest)
                shutil.copy2(source, dest)
            
            self.progress.emit(int((i + 1) / total_files * 100))
    
    def _move_files(self):
        total_files = len(self.operation.source_paths)
        for i, source in enumerate(self.operation.source_paths):
            if self.operation.cancelled:
                return
                
            self.statusChanged.emit(f"Moving {os.path.basename(source)}...")

            dest = os.path.join(self.operation.destination_path, os.path.basename(source))
            fast_move(source, dest)
            
            self.progress.emit(int((i + 1) / total_files * 100))
    
    def _delete_files(self):
        total_files = len(self.operation.source_paths)
        for i, source in enumerate(self.operation.source_paths):
            if self.operation.cancelled:
                return
                
                
            self.statusChanged.emit(f"Deleting {os.path.basename(source)}...")
            
            if os.path.isdir(source):
                shutil.rmtree(source)
            else:
                os.remove(source)
            
            self.progress.emit(int((i + 1) / total_files * 100))

class OperationProgressDialog(QProgressDialog):
    """Progress dialog for file operations"""
    
    def __init__(self, operation_name, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"{operation_name} Progress")
        self.setLabelText("Initializing...")
        self.setRange(0, 100)
        self.setValue(0)
        self.setModal(True)
        self.setAutoClose(False)
        self.setAutoReset(False)
        self.operation_worker = None
        
    def start_operation(self, operation):
        """Start a background file operation"""
        self.operation_worker = AsyncFileOperationWorker(operation)
        self.operation_worker.progress.connect(self.setValue)
        self.operation_worker.statusChanged.connect(self.setLabelText)
        self.operation_worker.finished.connect(self._on_finished)
        self.canceled.connect(operation.cancel)
        self.operation_worker.start()
        
    def _on_finished(self, success, message, stats):
        if success:
            self.setLabelText("Operation completed successfully")
            self.setValue(100)
        else:
            self.setLabelText(f"Error: {message}")
        
        QTimer.singleShot(2000, self.close)

class SyntaxHighlighter(QSyntaxHighlighter):
    """Syntax highlighter for code preview"""
    
    def __init__(self, document, file_extension):
        super().__init__(document)
        self.file_extension = file_extension.lower()
        self.setup_highlighting_rules()
    
    def setup_highlighting_rules(self):
        """Setup syntax highlighting rules based on file extension"""
        self.highlighting_rules = []
        
        # Python syntax
        if self.file_extension in ['.py', '.pyw']:
            self.setup_python_highlighting()
        # JavaScript/TypeScript
        elif self.file_extension in ['.js', '.ts', '.jsx', '.tsx']:
            self.setup_javascript_highlighting()
        # C/C++
        elif self.file_extension in ['.c', '.cpp', '.h', '.hpp']:
            self.setup_c_highlighting()
        # HTML/XML
        elif self.file_extension in ['.html', '.htm', '.xml']:
            self.setup_html_highlighting()
    
    def setup_python_highlighting(self):
        """Setup Python syntax highlighting"""
        keyword_format = QTextCharFormat()
        keyword_format.setColor(QColor(85, 85, 255))
        keyword_format.setFontWeight(QFont.Bold)
        keywords = ['def', 'class', 'if', 'else', 'elif', 'for', 'while', 'try', 'except', 
                   'import', 'from', 'return', 'yield', 'with', 'as', 'pass', 'break', 'continue']
        for keyword in keywords:
            self.highlighting_rules.append((f'\\b{keyword}\\b', keyword_format))
        
        # Strings
        string_format = QTextCharFormat()
        string_format.setColor(QColor(0, 128, 0))
        self.highlighting_rules.append((r'".*?"', string_format))
        self.highlighting_rules.append((r"'.*?'", string_format))
        
        # Comments
        comment_format = QTextCharFormat()
        comment_format.setColor(QColor(128, 128, 128))
        self.highlighting_rules.append((r'#.*', comment_format))
    
    def setup_javascript_highlighting(self):
        """Setup JavaScript syntax highlighting"""
        keyword_format = QTextCharFormat()
        keyword_format.setColor(QColor( 0 , 255 ,0))
        keyword_format.setFontWeight(QFont.Bold)
        keywords = ['function', 'var', 'let', 'const', 'if', 'else', 'for', 'while', 
                   'return', 'class', 'extends', 'import', 'export', 'default']
        for keyword in keywords:
            self.highlighting_rules.append((f'\\b{keyword}\\b', keyword_format))
    
    def setup_c_highlighting(self):
        """Setup C/C++ syntax highlighting"""
        keyword_format = QTextCharFormat()
        keyword_format.setColor(QColor( 0 , 255 ,0))
        keyword_format.setFontWeight(QFont.Bold)
        keywords = ['int', 'float', 'double', 'char', 'void', 'if', 'else', 'for', 
                   'while', 'return', 'struct', 'class', 'public', 'private', 'protected']
        for keyword in keywords:
            self.highlighting_rules.append((f'\\b{keyword}\\b', keyword_format))
    
    def setup_html_highlighting(self):
        """Setup HTML syntax highlighting"""
        tag_format = QTextCharFormat()
        tag_format.setColor(QColor(128, 0, 128))
        tag_format.setFontWeight(QFont.Bold)
        self.highlighting_rules.append((r'<[^>]+>', tag_format))
    
    def highlightBlock(self, text):
        """Apply syntax highlighting to a block of text"""
        import re
        for pattern, format_obj in self.highlighting_rules:
            for match in re.finditer(pattern, text):
                start, end = match.span()
                self.setFormat(start, end - start, format_obj)

class ClipboardHistoryManager:
    """Advanced clipboard manager with history tracking"""
    def __init__(self):
        self.history = []
        self.max_history = 50
        self.current_operation = None  # 'cut' or 'copy'
        self.current_paths = []
    
    def add_to_history(self, operation, paths, timestamp=None):
        if timestamp is None:
            timestamp = datetime.now()
        
        entry = {
            'operation': operation,
            'paths': paths.copy(),
            'timestamp': timestamp,
            'valid': all(os.path.exists(path) for path in paths)
        }
        
        self.history.insert(0, entry)
        if len(self.history) > self.max_history:
            self.history.pop()
    
    def set_current_operation(self, operation, paths):
        self.current_operation = operation
        self.current_paths = paths.copy()
        self.add_to_history(operation, paths)
    
    def get_current_operation(self):
        return self.current_operation, self.current_paths
    
    def clear_current(self):
        self.current_operation = None
        self.current_paths = []
    
    def get_history(self):
        return self.history

class EnhancedImageViewer(QWidget):
    """Enhanced image viewer with zoom and rotation controls"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self.current_pixmap = None
        self.zoom_factor = 1.0
        self.rotation_angle = 0
        
    def setup_ui(self):
        layout = QVBoxLayout()
        
        # Image controls
        controls_layout = QHBoxLayout()
        
        # Zoom controls
        self.zoom_out_btn = QPushButton("Zoom Out")
        self.zoom_out_btn.clicked.connect(self.zoom_out)
        self.zoom_in_btn = QPushButton("Zoom In")
        self.zoom_in_btn.clicked.connect(self.zoom_in)
        self.zoom_fit_btn = QPushButton("Fit to Window")
        self.zoom_fit_btn.clicked.connect(self.zoom_fit)
        self.zoom_100_btn = QPushButton("100%")
        self.zoom_100_btn.clicked.connect(self.zoom_100)
        
        # Rotation controls
        self.rotate_left_btn = QPushButton("Rotate Left")
        self.rotate_left_btn.clicked.connect(self.rotate_left)
        self.rotate_right_btn = QPushButton("Rotate Right")
        self.rotate_right_btn.clicked.connect(self.rotate_right)
        
        # Zoom level display
        self.zoom_label = QLabel("100%")
        
        controls_layout.addWidget(self.zoom_out_btn)
        controls_layout.addWidget(self.zoom_in_btn)
        controls_layout.addWidget(self.zoom_fit_btn)
        controls_layout.addWidget(self.zoom_100_btn)
        controls_layout.addWidget(QLabel("|"))  # Separator
        controls_layout.addWidget(self.rotate_left_btn)
        controls_layout.addWidget(self.rotate_right_btn)
        controls_layout.addWidget(QLabel("|"))  # Separator
        controls_layout.addWidget(QLabel("Zoom:"))
        controls_layout.addWidget(self.zoom_label)
        controls_layout.addStretch()
        
        layout.addLayout(controls_layout)
        
        # Image display area
        self.scroll_area = QScrollArea()
        self.image_label = QLabel()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setStyleSheet("background-color: #f0f0f0; border: 1px solid #ccc;")
        self.scroll_area.setWidget(self.image_label)
        self.scroll_area.setWidgetResizable(True)
        layout.addWidget(self.scroll_area)
        
        # Image info
        self.info_label = QLabel()
        self.info_label.setWordWrap(True)
        layout.addWidget(self.info_label)
        
        self.setLayout(layout)
        
    def load_image(self, file_path):
        """Load an image file"""
        try:
            self.current_pixmap = QPixmap(file_path)
            if self.current_pixmap.isNull():
                self.image_label.setText("Cannot load image file")
                self.info_label.setText("")
                return False
            
            # Reset view state
            self.zoom_factor = 1.0
            self.rotation_angle = 0
            
            # Display image info
            size = self.current_pixmap.size()
            file_size = os.path.getsize(file_path)
            self.info_label.setText(
                f"Dimensions: {size.width()} x {size.height()} pixels | "
                f"File Size: {self.format_file_size(file_size)}"
            )
            
            self.update_display()
            return True
            
        except Exception as e:
            self.image_label.setText(f"Error loading image: {str(e)}")
            self.info_label.setText("")
            return False
    
    def update_display(self):
        """Update the image display with current zoom and rotation"""
        if not self.current_pixmap:
            return
            
        # Apply rotation
        if self.rotation_angle != 0:
            transform = QTransform().rotate(self.rotation_angle)
            rotated_pixmap = self.current_pixmap.transformed(transform, Qt.SmoothTransformation)
        else:
            rotated_pixmap = self.current_pixmap
        
        # Apply zoom
        if self.zoom_factor != 1.0:
            new_size = rotated_pixmap.size() * self.zoom_factor
            scaled_pixmap = rotated_pixmap.scaled(new_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        else:
            scaled_pixmap = rotated_pixmap
        
        self.image_label.setPixmap(scaled_pixmap)
        self.zoom_label.setText(f"{int(self.zoom_factor * 100)}%")
    
    def zoom_in(self):
        """Zoom in by 25%"""
        self.zoom_factor = min(self.zoom_factor * 1.25, 10.0)  # Max 1000%
        self.update_display()
    
    def zoom_out(self):
        """Zoom out by 25%"""
        self.zoom_factor = max(self.zoom_factor / 1.25, 0.1)  # Min 10%
        self.update_display()
    
    def zoom_fit(self):
        """Fit image to window"""
        if not self.current_pixmap:
            return
            
        # Get available space
        available_size = self.scroll_area.size()
        available_size.setWidth(available_size.width() - 20)  # Account for scrollbars
        available_size.setHeight(available_size.height() - 20)
        
        # Calculate zoom factor to fit
        image_size = self.current_pixmap.size()
        if self.rotation_angle % 180 != 0:
            image_size = QSize(image_size.height(), image_size.width())
        
        zoom_x = available_size.width() / image_size.width()
        zoom_y = available_size.height() / image_size.height()
        self.zoom_factor = min(zoom_x, zoom_y, 1.0)  # Don't zoom beyond 100%
        
        self.update_display()
    
    def zoom_100(self):
        """Reset zoom to 100%"""
        self.zoom_factor = 1.0
        self.update_display()
    
    def rotate_left(self):
        """Rotate image 90 degrees counter-clockwise"""
        self.rotation_angle = (self.rotation_angle - 90) % 360
        self.update_display()
    
    def rotate_right(self):
        """Rotate image 90 degrees clockwise"""
        self.rotation_angle = (self.rotation_angle + 90) % 360
        self.update_display()
    
    def clear(self):
        """Clear the image viewer"""
        self.current_pixmap = None
        self.image_label.clear()
        self.info_label.clear()
        self.zoom_factor = 1.0
        self.rotation_angle = 0
        self.zoom_label.setText("100%")
    
    def format_file_size(self, size):
        """Format file size in human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} PB"

class PreviewPane(QWidget):
    """File preview pane with support for text, images, and basic info"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self.current_file = None
        
    def setup_ui(self):
        layout = QVBoxLayout()
        
        # Header
        self.header_label = QLabel("Preview")
        self.header_label.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(self.header_label)
        
        # Tabbed preview area
        self.preview_tabs = QTabWidget()
        
        # Content tab
        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout()
        
        # Preview area (for images, text, etc.)
        self.preview_area = QScrollArea()
        self.preview_content = QLabel()
        self.preview_content.setAlignment(Qt.AlignCenter)
        self.preview_content.setWordWrap(True)
        self.preview_area.setWidget(self.preview_content)
        self.content_layout.addWidget(self.preview_area)
        
        # Text editor for text files
        self.text_editor = QPlainTextEdit()
        self.text_editor.setReadOnly(True)
        self.text_editor.hide()
        
        # Search widget for text files
        self.search_widget = QWidget()
        self.search_layout = QHBoxLayout()
        self.search_layout.setContentsMargins(0, 0, 0, 0)
        
        self.search_label = QLabel("Search:")
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Enter search term...")
        self.search_prev_btn = QPushButton("Previous")
        self.search_next_btn = QPushButton("Next")
        self.search_case_btn = QPushButton("Aa")
        self.search_case_btn.setCheckable(True)
        self.search_case_btn.setToolTip("Case sensitive")
        self.search_clear_btn = QPushButton("Clear")
        
        # Set button sizes
        for btn in [self.search_prev_btn, self.search_next_btn, self.search_case_btn, self.search_clear_btn]:
            btn.setMaximumWidth(80)
        
        self.search_layout.addWidget(self.search_label)
        self.search_layout.addWidget(self.search_input, 1)
        self.search_layout.addWidget(self.search_prev_btn)
        self.search_layout.addWidget(self.search_next_btn)
        self.search_layout.addWidget(self.search_case_btn)
        self.search_layout.addWidget(self.search_clear_btn)
        
        self.search_widget.setLayout(self.search_layout)
        self.search_widget.hide()
        
        # Connect search functionality
        self.search_input.textChanged.connect(self.on_search_text_changed)
        self.search_input.returnPressed.connect(self.search_next)
        self.search_prev_btn.clicked.connect(self.search_previous)
        self.search_next_btn.clicked.connect(self.search_next)
        self.search_case_btn.clicked.connect(self.on_search_text_changed)
        self.search_clear_btn.clicked.connect(self.clear_search)
        
        self.content_layout.addWidget(self.search_widget)
        self.content_layout.addWidget(self.text_editor)
        
        # Enhanced image viewer
        self.image_viewer = EnhancedImageViewer()
        self.image_viewer.hide()
        self.content_layout.addWidget(self.image_viewer)
        
        self.content_widget.setLayout(self.content_layout)
        self.preview_tabs.addTab(self.content_widget, "Content")
        
        # Properties tab
        self.properties_widget = QWidget()
        self.properties_layout = QVBoxLayout()
        self.properties_text = QTextEdit()
        self.properties_text.setReadOnly(True)
        self.properties_layout.addWidget(self.properties_text)
        self.properties_widget.setLayout(self.properties_layout)
        self.preview_tabs.addTab(self.properties_widget, "Properties")
        
        # Metadata tab
        self.metadata_widget = QWidget()
        self.metadata_layout = QVBoxLayout()
        self.metadata_text = QTextEdit()
        self.metadata_text.setReadOnly(True)
        self.metadata_text.setFont(QFont("Consolas", 9))  # Use monospace font for better alignment
        self.metadata_layout.addWidget(self.metadata_text)
        self.metadata_widget.setLayout(self.metadata_layout)
        self.preview_tabs.addTab(self.metadata_widget, "Metadata")
        
        # Hex viewer tab
        self.hex_widget = QWidget()
        self.hex_layout = QVBoxLayout()
        
        # Hex viewer controls
        hex_controls = QHBoxLayout()
        self.hex_offset_label = QLabel("Offset: 0x00000000")
        self.hex_encoding_combo = QComboBox()
        self.hex_encoding_combo.addItems(["ASCII", "UTF-8", "UTF-16", "Latin-1"])
        self.hex_encoding_combo.currentTextChanged.connect(self.update_hex_ascii)
        hex_controls.addWidget(QLabel("Encoding:"))
        hex_controls.addWidget(self.hex_encoding_combo)
        hex_controls.addStretch()
        hex_controls.addWidget(self.hex_offset_label)
        self.hex_layout.addLayout(hex_controls)
        
        # Hex viewer text area
        self.hex_text = QTextEdit()
        self.hex_text.setReadOnly(True)
        self.hex_text.setFont(QFont("Consolas", 9))  # Monospace font for hex display
        self.hex_text.setLineWrapMode(QTextEdit.NoWrap)
        self.hex_layout.addWidget(self.hex_text)
        
        self.hex_widget.setLayout(self.hex_layout)
        self.preview_tabs.addTab(self.hex_widget, "Hex View")
        
        # Store current hex data for encoding changes
        self.current_hex_data = None
        
        layout.addWidget(self.preview_tabs)
        self.setLayout(layout)
    
    def preview_file(self, file_path):
        if not os.path.exists(file_path):
            self.clear_preview()
            return
            
        self.current_file = file_path
        file_info = QFileInfo(file_path)
        
        # Update header
        self.header_label.setText(f"Preview: {file_info.fileName()}")
        
        # Update properties
        self.update_properties(file_info)
        
        # Update metadata and hex view for files
        if file_info.isFile():
            self.update_metadata(file_path)
            self.update_hex_view(file_path)
        else:
            # Clear metadata and hex view for folders
            self.metadata_text.clear()
            self.hex_text.clear()
            self.current_hex_data = None
        
        # Update content preview
        if file_info.isFile():
            self.update_content_preview(file_path)
        else:
            self.update_folder_preview(file_path)
    
    def update_content_preview(self, file_path):
        """Enhanced content preview with syntax highlighting"""
        self.text_editor.hide()
        self.preview_area.show()
        
        file_ext = os.path.splitext(file_path)[1].lower()
        mime_type, _ = mimetypes.guess_type(file_path)
        
        # Check if it's an archive file first
        if ArchiveManager.is_archive(file_path):
            self.preview_archive_info(file_path)
        elif mime_type and mime_type.startswith('image/'):
            self.preview_image(file_path)
        elif self.is_code_file(file_ext):
            self.preview_code_file(file_path, file_ext)
        elif mime_type and mime_type.startswith('text/') or file_ext in ['.txt', '.log', '.md', '.json', '.xml', '.csv']:
            self.preview_text_file_enhanced(file_path, file_ext)
        elif file_ext in ['.pdf']:
            self.preview_pdf_info(file_path)
        elif file_ext in ['.docx', '.doc', '.xlsx', '.xls', '.pptx', '.ppt']:
            self.preview_office_document(file_path)
        elif mime_type and mime_type.startswith('video/'):
            self.preview_video_info(file_path)
        elif mime_type and mime_type.startswith('audio/'):
            self.preview_audio_info(file_path)
        else:
            self.preview_generic_file(file_path)
    
    def is_code_file(self, ext):
        """Check if file extension indicates a code file"""
        code_extensions = ['.py', '.js', '.ts', '.jsx', '.tsx', '.html', '.htm', '.css', '.scss',
                          '.c', '.cpp', '.h', '.hpp', '.java', '.php', '.rb', '.go', '.rs', '.swift',
                          '.kt', '.scala', '.sh', '.bash', '.ps1', '.sql', '.r', '.matlab', '.m']
        return ext in code_extensions
    
    def preview_code_file(self, file_path, file_ext):
        """Preview code files with syntax highlighting"""
        try:
            file_size = os.path.getsize(file_path)
            if file_size > 512 * 1024:  # 512KB limit for code files
                self.preview_content.setText(f"Code file too large to preview ({file_size} bytes)")
                return
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
                content = file.read()
            
            # Switch to text editor for syntax highlighting
            self.preview_area.hide()
            self.text_editor.show()
            self.text_editor.setPlainText(content)
            
            # Apply syntax highlighting
            if hasattr(self, 'highlighter'):
                self.highlighter.setDocument(None)
            self.highlighter = SyntaxHighlighter(self.text_editor.document(), file_ext)
            
        except Exception as e:
            self.preview_content.setText(f"Error previewing code file: {str(e)}")
    
    def preview_text_file_enhanced(self, file_path, file_ext):
        """Enhanced text file preview with formatting and search"""
        try:
            file_size = os.path.getsize(file_path)
            if file_size > 1024 * 1024:  # 1MB limit
                self.preview_content.setText(f"Text file too large to preview ({file_size} bytes)")
                return
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
                content = file.read()
            
            # For structured text files, provide basic formatting
            if file_ext == '.json':
                try:
                    import json
                    parsed = json.loads(content)
                    content = json.dumps(parsed, indent=2)
                except:
                    pass  # Use original content if JSON parsing fails
            elif file_ext == '.md':
                # Basic markdown preview (simple formatting)
                content = self.format_markdown(content)
            
            self.preview_area.hide()
            self.search_widget.show()
            self.text_editor.show()
            self.text_editor.setPlainText(content)
            
            # Clear any previous search
            self.clear_search()
            
        except Exception as e:
            self.preview_content.setText(f"Error previewing text file: {str(e)}")
    
    def on_search_text_changed(self):
        """Handle search text changes"""
        search_text = self.search_input.text()
        if not search_text:
            self.clear_search_highlights()
            return
        
        self.highlight_search_results(search_text)
    
    def search_next(self):
        """Find next occurrence of search text"""
        search_text = self.search_input.text()
        if not search_text:
            return
        
        cursor = self.text_editor.textCursor()
        flags = QTextDocument.FindFlag(0)
        
        if self.search_case_btn.isChecked():
            flags |= QTextDocument.FindCaseSensitively
        
        found_cursor = self.text_editor.document().find(search_text, cursor, flags)
        if found_cursor.isNull():
            # Search from beginning
            found_cursor = self.text_editor.document().find(search_text, 0, flags)
        
        if not found_cursor.isNull():
            self.text_editor.setTextCursor(found_cursor)
            self.text_editor.ensureCursorVisible()
    
    def search_previous(self):
        """Find previous occurrence of search text"""
        search_text = self.search_input.text()
        if not search_text:
            return
        
        cursor = self.text_editor.textCursor()
        cursor.setPosition(cursor.selectionStart())  # Start from beginning of selection
        
        flags = QTextDocument.FindBackward
        if self.search_case_btn.isChecked():
            flags |= QTextDocument.FindCaseSensitively
        
        found_cursor = self.text_editor.document().find(search_text, cursor, flags)
        if found_cursor.isNull():
            # Search from end
            cursor = QTextCursor(self.text_editor.document())
            cursor.movePosition(QTextCursor.End)
            found_cursor = self.text_editor.document().find(search_text, cursor, flags)
        
        if not found_cursor.isNull():
            self.text_editor.setTextCursor(found_cursor)
            self.text_editor.ensureCursorVisible()
    
    def highlight_search_results(self, search_text):
        """Highlight all occurrences of search text"""
        if not search_text:
            return
        
        # Clear previous highlights
        self.clear_search_highlights()
        
        # Create highlight format
        highlight_format = QTextCharFormat()
        highlight_format.setBackground(QColor(255, 255, 0, 100))  # Yellow highlight
        
        cursor = QTextCursor(self.text_editor.document())
        flags = QTextDocument.FindFlag(0)
        
        if self.search_case_btn.isChecked():
            flags |= QTextDocument.FindCaseSensitively
        
        # Find and highlight all occurrences
        while True:
            cursor = self.text_editor.document().find(search_text, cursor, flags)
            if cursor.isNull():
                break
            
            # Apply highlight
            selection = QTextEdit.ExtraSelection()
            selection.format = highlight_format
            selection.cursor = cursor
            
            # Store the selection for later removal
            if not hasattr(self, 'search_selections'):
                self.search_selections = []
            self.search_selections.append(selection)
        
        # Apply all highlights
        if hasattr(self, 'search_selections'):
            self.text_editor.setExtraSelections(self.search_selections)
    
    def clear_search_highlights(self):
        """Clear all search highlights"""
        if hasattr(self, 'search_selections'):
            self.search_selections = []
        self.text_editor.setExtraSelections([])
    
    def clear_search(self):
        """Clear search input and highlights"""
        self.search_input.clear()
        self.clear_search_highlights()
    
    def format_markdown(self, content):
        """Basic markdown formatting for preview"""
        lines = content.split('\n')
        formatted_lines = []
        for line in lines:
            if line.startswith('# '):
                formatted_lines.append(f"━━━ {line[2:]} ━━━")
            elif line.startswith('## '):
                formatted_lines.append(f"── {line[3:]} ──")
            elif line.startswith('### '):
                formatted_lines.append(f"• {line[4:]}")
            else:
                formatted_lines.append(line)
        return '\n'.join(formatted_lines)
    
    def preview_pdf_info(self, file_path):
        """Show enhanced PDF document information with thumbnail and metadata"""
        try:
            file_size = os.path.getsize(file_path)
            info_text = f"PDF Document\n\n"
            info_text += f"File Size: {self.format_file_size(file_size)}\n"
            info_text += f"Location: {file_path}\n\n"
            
            # Try to extract PDF metadata
            pdf_info = self.extract_pdf_metadata(file_path)
            if pdf_info:
                info_text += f"Pages: {pdf_info.get('pages', 'Unknown')}\n"
                info_text += f"Title: {pdf_info.get('title', 'Not specified')}\n"
                info_text += f"Author: {pdf_info.get('author', 'Not specified')}\n"
                info_text += f"Subject: {pdf_info.get('subject', 'Not specified')}\n"
                info_text += f"Creator: {pdf_info.get('creator', 'Not specified')}\n"
                info_text += f"Producer: {pdf_info.get('producer', 'Not specified')}\n"
                info_text += f"Creation Date: {pdf_info.get('creation_date', 'Not specified')}\n"
                info_text += f"Modification Date: {pdf_info.get('mod_date', 'Not specified')}\n\n"
                
                # Try to generate and display PDF thumbnail
                thumbnail_path = self.generate_pdf_thumbnail(file_path)
                if thumbnail_path and os.path.exists(thumbnail_path):
                    try:
                        pixmap = QPixmap(thumbnail_path)
                        if not pixmap.isNull():
                            # Scale thumbnail to fit preview area
                            scaled_pixmap = pixmap.scaled(400, 500, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            self.preview_content.setPixmap(scaled_pixmap)
                            # Set info text as tooltip or status
                            self.preview_content.setToolTip(info_text)
                            return
                    except Exception as e:
                        info_text += f"Thumbnail generation error: {str(e)}\n"
            
            info_text += "Double-click to open with default application."
            self.preview_content.setText(info_text)
            
        except Exception as e:
            self.preview_content.setText(f"Error reading PDF info: {str(e)}")
    
    def extract_pdf_metadata(self, file_path):
        """Extract PDF metadata using PyMuPDF or other available libraries"""
        try:
            import fitz  # PyMuPDF
            doc = fitz.open(file_path)
            
            metadata = {}
            metadata['pages'] = str(len(doc))
            
            # Extract document metadata
            meta = doc.metadata
            if meta:
                metadata['title'] = meta.get('title', '').strip() or 'Not specified'
                metadata['author'] = meta.get('author', '').strip() or 'Not specified'
                metadata['subject'] = meta.get('subject', '').strip() or 'Not specified'
                metadata['creator'] = meta.get('creator', '').strip() or 'Not specified'
                metadata['producer'] = meta.get('producer', '').strip() or 'Not specified'
                
                # Format dates
                creation_date = meta.get('creationDate', '')
                if creation_date:
                    try:
                        # Parse PDF date format (D:YYYYMMDDHHmmSSOHH'mm')
                        if creation_date.startswith('D:'):
                            date_part = creation_date[2:16]  # YYYYMMDDHHmmSS
                            if len(date_part) >= 8:
                                year = date_part[:4]
                                month = date_part[4:6]
                                day = date_part[6:8]
                                metadata['creation_date'] = f"{year}-{month}-{day}"
                            else:
                                metadata['creation_date'] = creation_date
                        else:
                            metadata['creation_date'] = creation_date
                    except:
                        metadata['creation_date'] = creation_date
                
                mod_date = meta.get('modDate', '')
                if mod_date:
                    try:
                        if mod_date.startswith('D:'):
                            date_part = mod_date[2:16]
                            if len(date_part) >= 8:
                                year = date_part[:4]
                                month = date_part[4:6]
                                day = date_part[6:8]
                                metadata['mod_date'] = f"{year}-{month}-{day}"
                            else:
                                metadata['mod_date'] = mod_date
                        else:
                            metadata['mod_date'] = mod_date
                    except:
                        metadata['mod_date'] = mod_date
            
            doc.close()
            return metadata
            
        except ImportError:
            # Try alternative method if PyMuPDF is not available
            try:
                import PyPDF2
                with open(file_path, 'rb') as file:
                    reader = PyPDF2.PdfReader(file)
                    
                    metadata = {}
                    metadata['pages'] = str(len(reader.pages))
                    
                    if reader.metadata:
                        metadata['title'] = reader.metadata.get('/Title', '').strip() or 'Not specified'
                        metadata['author'] = reader.metadata.get('/Author', '').strip() or 'Not specified'
                        metadata['subject'] = reader.metadata.get('/Subject', '').strip() or 'Not specified'
                        metadata['creator'] = reader.metadata.get('/Creator', '').strip() or 'Not specified'
                        metadata['producer'] = reader.metadata.get('/Producer', '').strip() or 'Not specified'
                        
                        creation_date = reader.metadata.get('/CreationDate', '')
                        if creation_date:
                            metadata['creation_date'] = str(creation_date)
                        
                        mod_date = reader.metadata.get('/ModDate', '')
                        if mod_date:
                            metadata['mod_date'] = str(mod_date)
                    
                    return metadata
                    
            except ImportError:
                pass
            except Exception:
                pass
        
        except Exception:
            pass
        
        return None
    
    def generate_pdf_thumbnail(self, file_path):
        """Generate a thumbnail for the PDF file"""
        try:
            # Create thumbnails directory if it doesn't exist
            thumbnails_dir = os.path.join(os.path.dirname(file_path), '.thumbnails')
            if not os.path.exists(thumbnails_dir):
                os.makedirs(thumbnails_dir, exist_ok=True)
            
            # Generate thumbnail filename
            base_name = os.path.splitext(os.path.basename(file_path))[0]
            thumbnail_path = os.path.join(thumbnails_dir, f"{base_name}_thumb.png")
            
            # Check if thumbnail already exists and is newer than PDF
            if os.path.exists(thumbnail_path):
                pdf_mtime = os.path.getmtime(file_path)
                thumb_mtime = os.path.getmtime(thumbnail_path)
                if thumb_mtime > pdf_mtime:
                    return thumbnail_path
            
            # Try to generate thumbnail using PyMuPDF
            import fitz  # PyMuPDF
            doc = fitz.open(file_path)
            if len(doc) > 0:
                page = doc[0]  # First page
                
                # Calculate zoom to get ~400px width
                rect = page.rect
                zoom = 400.0 / rect.width
                mat = fitz.Matrix(zoom, zoom)
                
                pix = page.get_pixmap(matrix=mat)
                pix.save(thumbnail_path)
                
                doc.close()
                
                if os.path.exists(thumbnail_path):
                    return thumbnail_path
            
            doc.close()
                
        except ImportError:
            # Try alternative method if PyMuPDF is not available
            try:
                # Use pdf2image if available
                from pdf2image import convert_from_path
                images = convert_from_path(file_path, first_page=1, last_page=1, dpi=150)
                if images:
                    img = images[0]
                    # Resize to max 400px width
                    if img.width > 400:
                        ratio = 400.0 / img.width
                        new_height = int(img.height * ratio)
                        img = img.resize((400, new_height))
                    
                    thumbnails_dir = os.path.join(os.path.dirname(file_path), '.thumbnails')
                    os.makedirs(thumbnails_dir, exist_ok=True)
                    base_name = os.path.splitext(os.path.basename(file_path))[0]
                    thumbnail_path = os.path.join(thumbnails_dir, f"{base_name}_thumb.png")
                    
                    img.save(thumbnail_path)
                    return thumbnail_path
                    
            except ImportError:
                pass
            except Exception:
                pass
        
        except Exception:
            pass
        
        return None
    
    def preview_office_document(self, file_path):
        """Show Office document information (Word, Excel, PowerPoint)"""
        try:
            file_size = os.path.getsize(file_path)
            _, ext = os.path.splitext(file_path)
            ext = ext.lower()
            
            # Determine document type
            if ext in ['.docx', '.doc']:
                doc_type = "Word Document"
            elif ext in ['.xlsx', '.xls']:
                doc_type = "Excel Spreadsheet"
            elif ext in ['.pptx', '.ppt']:
                doc_type = "PowerPoint Presentation"
            else:
                doc_type = "Office Document"
            
            info_text = f"{doc_type}\n\n"
            info_text += f"File Size: {self.format_file_size(file_size)}\n"
            info_text += f"Location: {file_path}\n\n"
            
            # Try to extract Office document metadata
            office_info = self.extract_office_metadata(file_path)
            if office_info:
                info_text += f"Title: {office_info.get('title', 'Not specified')}\n"
                info_text += f"Author: {office_info.get('author', 'Not specified')}\n"
                info_text += f"Subject: {office_info.get('subject', 'Not specified')}\n"
                info_text += f"Keywords: {office_info.get('keywords', 'Not specified')}\n"
                info_text += f"Creator: {office_info.get('creator', 'Not specified')}\n"
                info_text += f"Last Modified By: {office_info.get('last_modified_by', 'Not specified')}\n"
                info_text += f"Creation Date: {office_info.get('created', 'Not specified')}\n"
                info_text += f"Modified Date: {office_info.get('modified', 'Not specified')}\n"
                
                # Add document-specific info
                if 'pages' in office_info:
                    info_text += f"Pages: {office_info['pages']}\n"
                if 'words' in office_info:
                    info_text += f"Words: {office_info['words']}\n"
                if 'worksheets' in office_info:
                    info_text += f"Worksheets: {office_info['worksheets']}\n"
                if 'slides' in office_info:
                    info_text += f"Slides: {office_info['slides']}\n"
                
                info_text += "\n"
            
            info_text += "Double-click to open with default application."
            self.preview_content.setText(info_text)
            
        except Exception as e:
            self.preview_content.setText(f"Error reading document info: {str(e)}")
    
    def extract_office_metadata(self, file_path):
        """Extract metadata from Office documents"""
        try:
            # Try using python-docx, openpyxl, python-pptx
            _, ext = os.path.splitext(file_path)
            ext = ext.lower()
            
            metadata = {}
            
            if ext in ['.docx']:
                try:
                    from docx import Document
                    doc = Document(file_path)
                    
                    # Core properties
                    core_props = doc.core_properties
                    metadata['title'] = core_props.title or 'Not specified'
                    metadata['author'] = core_props.author or 'Not specified'
                    metadata['subject'] = core_props.subject or 'Not specified'
                    metadata['keywords'] = core_props.keywords or 'Not specified'
                    metadata['creator'] = core_props.creator or 'Not specified'
                    metadata['last_modified_by'] = core_props.last_modified_by or 'Not specified'
                    
                    if core_props.created:
                        metadata['created'] = core_props.created.strftime('%Y-%m-%d')
                    if core_props.modified:
                        metadata['modified'] = core_props.modified.strftime('%Y-%m-%d')
                    
                    # Document statistics
                    try:
                        # Count paragraphs and approximate words
                        paragraphs = len(doc.paragraphs)
                        words = sum(len(p.text.split()) for p in doc.paragraphs if p.text.strip())
                        metadata['pages'] = f"~{max(1, paragraphs // 20)}"  # Rough estimate
                        metadata['words'] = str(words)
                    except:
                        pass
                    
                    return metadata
                    
                except ImportError:
                    pass
                except Exception:
                    pass
            
            elif ext in ['.xlsx']:
                try:
                    from openpyxl import load_workbook
                    wb = load_workbook(file_path, read_only=True, data_only=True)
                    
                    # Workbook properties
                    props = wb.properties
                    metadata['title'] = props.title or 'Not specified'
                    metadata['author'] = props.creator or 'Not specified'
                    metadata['subject'] = props.subject or 'Not specified'
                    metadata['keywords'] = props.keywords or 'Not specified'
                    metadata['creator'] = props.creator or 'Not specified'
                    metadata['last_modified_by'] = props.lastModifiedBy or 'Not specified'
                    
                    if props.created:
                        metadata['created'] = props.created.strftime('%Y-%m-%d')
                    if props.modified:
                        metadata['modified'] = props.modified.strftime('%Y-%m-%d')
                    
                    # Worksheet count
                    metadata['worksheets'] = str(len(wb.worksheets))
                    
                    wb.close()
                    return metadata
                    
                except ImportError:
                    pass
                except Exception:
                    pass
            
            elif ext in ['.pptx']:
                try:
                    from pptx import Presentation
                    prs = Presentation(file_path)
                    
                    # Core properties
                    core_props = prs.core_properties
                    metadata['title'] = core_props.title or 'Not specified'
                    metadata['author'] = core_props.author or 'Not specified'
                    metadata['subject'] = core_props.subject or 'Not specified'
                    metadata['keywords'] = core_props.keywords or 'Not specified'
                    metadata['creator'] = core_props.creator or 'Not specified'
                    metadata['last_modified_by'] = core_props.last_modified_by or 'Not specified'
                    
                    if core_props.created:
                        metadata['created'] = core_props.created.strftime('%Y-%m-%d')
                    if core_props.modified:
                        metadata['modified'] = core_props.modified.strftime('%Y-%m-%d')
                    
                    # Slide count
                    metadata['slides'] = str(len(prs.slides))
                    
                    return metadata
                    
                except ImportError:
                    pass
                except Exception:
                    pass
            
            # Try using OLE for older Office formats (.doc, .xls, .ppt)
            if ext in ['.doc', '.xls', '.ppt']:
                try:
                    import olefile
                    if olefile.isOleFile(file_path):
                        ole = olefile.OleFileIO(file_path)
                        
                        # Try to extract metadata from OLE properties
                        try:
                            meta = ole.get_metadata()
                            if meta:
                                metadata['title'] = meta.title or 'Not specified'
                                metadata['author'] = meta.author or 'Not specified'
                                metadata['subject'] = meta.subject or 'Not specified'
                                metadata['keywords'] = meta.keywords or 'Not specified'
                                metadata['creator'] = meta.author or 'Not specified'
                                
                                if meta.create_time:
                                    metadata['created'] = meta.create_time.strftime('%Y-%m-%d')
                                if meta.last_saved_time:
                                    metadata['modified'] = meta.last_saved_time.strftime('%Y-%m-%d')
                        except:
                            pass
                        
                        ole.close()
                        return metadata
                        
                except ImportError:
                    pass
                except Exception:
                    pass
        
        except Exception:
            pass
        
        return None
    
    def preview_video_info(self, file_path):
        """Show enhanced video file information with thumbnail and metadata"""
        try:
            file_size = os.path.getsize(file_path)
            info_text = f"Video File\n\n"
            info_text += f"File Size: {self.format_file_size(file_size)}\n"
            info_text += f"Location: {file_path}\n\n"
            
            # Try to extract video metadata and generate thumbnail
            video_info = self.extract_video_metadata(file_path)
            if video_info:
                info_text += f"Duration: {video_info.get('duration', 'Unknown')}\n"
                info_text += f"Resolution: {video_info.get('resolution', 'Unknown')}\n"
                info_text += f"Format: {video_info.get('format', 'Unknown')}\n"
                info_text += f"Video Codec: {video_info.get('video_codec', 'Unknown')}\n"
                info_text += f"Audio Codec: {video_info.get('audio_codec', 'Unknown')}\n"
                info_text += f"Bitrate: {video_info.get('bitrate', 'Unknown')}\n"
                info_text += f"Frame Rate: {video_info.get('framerate', 'Unknown')}\n\n"
                
                # Try to generate and display video thumbnail
                thumbnail_path = self.generate_video_thumbnail(file_path)
                if thumbnail_path and os.path.exists(thumbnail_path):
                    try:
                        pixmap = QPixmap(thumbnail_path)
                        if not pixmap.isNull():
                            # Scale thumbnail to fit preview area
                            scaled_pixmap = pixmap.scaled(400, 300, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            self.preview_content.setPixmap(scaled_pixmap)
                            # Set info text as tooltip or status
                            self.preview_content.setToolTip(info_text)
                            return
                    except Exception as e:
                        info_text += f"Thumbnail generation error: {str(e)}\n"
            
            info_text += "Double-click to open with default application."
            self.preview_content.setText(info_text)
            
        except Exception as e:
            self.preview_content.setText(f"Error reading video info: {str(e)}")
    
    def extract_video_metadata(self, file_path):
        """Extract video metadata using ffprobe or fallback methods"""
        try:
            # Try using ffprobe first (part of ffmpeg)
            import subprocess
            import json
            
            cmd = [
                'ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_format', '-show_streams', file_path
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                data = json.loads(result.stdout)
                
                # Extract relevant information
                format_info = data.get('format', {})
                video_stream = None
                audio_stream = None
                
                for stream in data.get('streams', []):
                    if stream.get('codec_type') == 'video' and video_stream is None:
                        video_stream = stream
                    elif stream.get('codec_type') == 'audio' and audio_stream is None:
                        audio_stream = stream
                
                metadata = {}
                
                # Duration
                duration = format_info.get('duration')
                if duration:
                    duration_float = float(duration)
                    hours = int(duration_float // 3600)
                    minutes = int((duration_float % 3600) // 60)
                    seconds = int(duration_float % 60)
                    if hours > 0:
                        metadata['duration'] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
                    else:
                        metadata['duration'] = f"{minutes:02d}:{seconds:02d}"
                
                # Resolution
                if video_stream:
                    width = video_stream.get('width')
                    height = video_stream.get('height')
                    if width and height:
                        metadata['resolution'] = f"{width}x{height}"
                    
                    # Video codec
                    metadata['video_codec'] = video_stream.get('codec_name', 'Unknown')
                    
                    # Frame rate
                    frame_rate = video_stream.get('r_frame_rate')
                    if frame_rate and '/' in frame_rate:
                        try:
                            num, den = frame_rate.split('/')
                            fps = float(num) / float(den)
                            metadata['framerate'] = f"{fps:.2f} fps"
                        except:
                            metadata['framerate'] = frame_rate
                
                # Audio codec
                if audio_stream:
                    metadata['audio_codec'] = audio_stream.get('codec_name', 'Unknown')
                
                # Format
                metadata['format'] = format_info.get('format_name', 'Unknown')
                
                # Bitrate
                bitrate = format_info.get('bit_rate')
                if bitrate:
                    bitrate_mbps = float(bitrate) / 1000000
                    metadata['bitrate'] = f"{bitrate_mbps:.2f} Mbps"
                
                return metadata
                
        except Exception as e:
            # Fallback to basic file information
            pass
        
        # If ffprobe fails, try alternative methods or return basic info
        try:
            # Try using opencv-python if available
            import cv2
            cap = cv2.VideoCapture(file_path)
            if cap.isOpened():
                fps = cap.get(cv2.CAP_PROP_FPS)
                frame_count = cap.get(cv2.CAP_PROP_FRAME_COUNT)
                width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                
                metadata = {}
                if fps > 0 and frame_count > 0:
                    duration = frame_count / fps
                    minutes = int(duration // 60)
                    seconds = int(duration % 60)
                    metadata['duration'] = f"{minutes:02d}:{seconds:02d}"
                
                if width > 0 and height > 0:
                    metadata['resolution'] = f"{width}x{height}"
                
                if fps > 0:
                    metadata['framerate'] = f"{fps:.2f} fps"
                
                cap.release()
                return metadata
                
        except ImportError:
            pass
        except Exception:
            pass
        
        return None
    
    def generate_video_thumbnail(self, file_path):
        """Generate a thumbnail for the video file"""
        try:
            # Create thumbnails directory if it doesn't exist
            thumbnails_dir = os.path.join(os.path.dirname(file_path), '.thumbnails')
            if not os.path.exists(thumbnails_dir):
                os.makedirs(thumbnails_dir, exist_ok=True)
            
            # Generate thumbnail filename
            base_name = os.path.splitext(os.path.basename(file_path))[0]
            thumbnail_path = os.path.join(thumbnails_dir, f"{base_name}_thumb.jpg")
            
            # Check if thumbnail already exists and is newer than video file
            if os.path.exists(thumbnail_path):
                video_mtime = os.path.getmtime(file_path)
                thumb_mtime = os.path.getmtime(thumbnail_path)
                if thumb_mtime > video_mtime:
                    return thumbnail_path
            
            # Try to generate thumbnail using ffmpeg
            import subprocess
            
            cmd = [
                'ffmpeg', '-i', file_path, '-ss', '00:00:10', '-vframes', '1', 
                '-vf', 'scale=400:300:force_original_aspect_ratio=decrease', 
                '-y', thumbnail_path
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            if result.returncode == 0 and os.path.exists(thumbnail_path):
                return thumbnail_path
                
        except Exception as e:
            pass
        
        # Try alternative method using opencv
        try:
            import cv2
            cap = cv2.VideoCapture(file_path)
            if cap.isOpened():
                # Seek to 10 seconds or 10% of video duration
                fps = cap.get(cv2.CAP_PROP_FPS)
                frame_count = cap.get(cv2.CAP_PROP_FRAME_COUNT)
                if fps > 0 and frame_count > 0:
                    seek_frame = min(fps * 10, frame_count * 0.1)  # 10 seconds or 10%
                    cap.set(cv2.CAP_PROP_POS_FRAMES, seek_frame)
                
                ret, frame = cap.read()
                if ret:
                    # Resize frame
                    height, width = frame.shape[:2]
                    if width > 400 or height > 300:
                        scale = min(400/width, 300/height)
                        new_width = int(width * scale)
                        new_height = int(height * scale)
                        frame = cv2.resize(frame, (new_width, new_height))
                    
                    # Save thumbnail
                    thumbnails_dir = os.path.join(os.path.dirname(file_path), '.thumbnails')
                    os.makedirs(thumbnails_dir, exist_ok=True)
                    base_name = os.path.splitext(os.path.basename(file_path))[0]
                    thumbnail_path = os.path.join(thumbnails_dir, f"{base_name}_thumb.jpg")
                    
                    cv2.imwrite(thumbnail_path, frame)
                    cap.release()
                    
                    if os.path.exists(thumbnail_path):
                        return thumbnail_path
                
                cap.release()
                
        except ImportError:
            pass
        except Exception:
            pass
        
        return None
    
    def preview_audio_info(self, file_path):
        """Show audio file information"""
        try:
            file_size = os.path.getsize(file_path)
            info_text = f"Audio File\n\n"
            info_text += f"File Size: {self.format_file_size(file_size)}\n"
            info_text += f"Location: {file_path}\n\n"
            info_text += "Audio preview requires external player.\n"
            info_text += "Double-click to open with default application."

            # Show waveform thumbnail for all supported audio files
            _, ext = os.path.splitext(file_path)
            supported_audio_exts = ['.wav', '.flac', '.ogg', '.aiff', '.aif', '.aifc', '.au', '.snd', '.sf', '.caf', '.mp3', '.oga', '.aac', '.m4a', '.wma', '.opus', '.alac']
            if ext.lower() in supported_audio_exts:
                try:
                    thumbnail_debug('Calling get_waveform_thumbnail for: {}', file_path)
                    pixmap = get_waveform_thumbnail(file_path, width=400, height=80, thumbnail_cache=self.thumbnail_cache)
                    self.preview_content.setPixmap(pixmap)
                except Exception as e:
                    self.preview_content.setText(f"Error generating waveform: {str(e)}\n\n" + info_text)
                    return
                # Add info text below the waveform
                self.preview_content.setText(info_text)
            else:
                self.preview_content.setText(info_text)
        except Exception as e:
            self.preview_content.setText(f"Error reading audio info: {str(e)}")

    def preview_archive_info(self, file_path):
        """Show archive file information"""
        try:
            file_size = os.path.getsize(file_path)
            file_ext = os.path.splitext(file_path)[1].lower()
            
            # Determine archive type
            archive_types = {
                '.zip': 'ZIP Archive',
                '.rar': 'RAR Archive', 
                '.tar': 'TAR Archive',
                '.gz': 'GZIP Archive',
                '.bz2': 'BZIP2 Archive',
                '.7z': '7-Zip Archive'
            }
            
            # Handle compound extensions
            if file_path.lower().endswith('.tar.gz') or file_path.lower().endswith('.tgz'):
                archive_type = 'TAR.GZ Archive'
            elif file_path.lower().endswith('.tar.bz2') or file_path.lower().endswith('.tbz2'):
                archive_type = 'TAR.BZ2 Archive'
            else:
                archive_type = archive_types.get(file_ext, 'Archive')
            
            info_text = f"{archive_type}\n\n"
            info_text += f"File Size: {self.format_file_size(file_size)}\n"
            info_text += f"Location: {file_path}\n\n"
            
            # Try to get archive contents info
            try:
                contents = ArchiveManager.list_archive_contents(file_path)
                if contents:
                    file_count = sum(1 for item in contents if not item['is_dir'])
                    dir_count = sum(1 for item in contents if item['is_dir'])
                    info_text += f"Contents: {file_count} files, {dir_count} folders\n\n"
                else:
                    info_text += "Archive contents could not be read.\n\n"
            except:
                info_text += "Archive contents could not be read.\n\n"
            
            info_text += "Double-click to browse archive contents\n"
            info_text += "Right-click for extraction options."
            
            self.preview_content.setText(info_text)
        except Exception as e:
            self.preview_content.setText(f"Error reading archive info: {str(e)}")
    
    def clear_preview(self):
        """Clear the preview pane content"""
        self.current_file = None
        self.header_label.setText("Preview")
        self.preview_content.clear()
        self.properties_text.clear()
        self.metadata_text.clear()
        self.hex_text.clear()
        self.current_hex_data = None
        
        # Hide all viewers and show default preview area
        self.text_editor.hide()
        self.search_widget.hide()
        self.clear_search()
        self.image_viewer.hide()
        self.image_viewer.clear()
        self.preview_area.show()
    
    def update_properties(self, file_info):
        """Update the properties tab with file information"""
        try:
            properties = []
            properties.append(f"Name: {file_info.fileName()}")
            properties.append(f"Size: {self.format_file_size(file_info.size())}")
            properties.append(f"Path: {file_info.absoluteFilePath()}")
            properties.append(f"Modified: {file_info.lastModified().toString()}")
            properties.append(f"Created: {file_info.birthTime().toString()}")
            properties.append(f"Permissions: {file_info.permissions()}")
            properties.append(f"Owner: {file_info.owner()}")
            
            self.properties_text.setText("\n".join(properties))
        except Exception as e:
            self.properties_text.setText(f"Error getting file properties: {str(e)}")
    
    def update_folder_preview(self, folder_path):
        """Update preview for folders"""
        try:
            file_count = 0
            folder_count = 0
            total_size = 0
            
            for item in os.listdir(folder_path):
                item_path = os.path.join(folder_path, item)
                if os.path.isfile(item_path):
                    file_count += 1
                    try:
                        total_size += os.path.getsize(item_path)
                    except:
                        pass
                elif os.path.isdir(item_path):
                    folder_count += 1
            
            info_text = f"Folder Contents\n\n"
            info_text += f"Files: {file_count}\n"
            info_text += f"Folders: {folder_count}\n"
            info_text += f"Total Size: {self.format_file_size(total_size)}\n"
            
            self.preview_content.setText(info_text)
        except Exception as e:
            self.preview_content.setText(f"Error reading folder: {str(e)}")
    
    def format_file_size(self, size):
        """Format file size in human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} PB"
    
    def preview_image(self, file_path):
        """Preview image files using enhanced image viewer"""
        try:
            # Hide other viewers and show image viewer
            self.preview_area.hide()
            self.text_editor.hide()
            self.image_viewer.show()
            
            # Load image in enhanced viewer
            if not self.image_viewer.load_image(file_path):
                # If enhanced viewer fails, fall back to simple display
                self.image_viewer.hide()
                self.preview_area.show()
                self.preview_content.setText("Cannot preview image file")
            
        except Exception as e:
            # Fall back to simple error display
            self.image_viewer.hide()
            self.preview_area.show()
            self.preview_content.setText(f"Error previewing image: {str(e)}")
    
    def preview_generic_file(self, file_path):
        """Preview for generic/unknown file types"""
        try:
            file_size = os.path.getsize(file_path)
            file_ext = os.path.splitext(file_path)[1].upper()
            
            info_text = f"File Information\n\n"
            info_text += f"Type: {file_ext[1:] if file_ext else 'Unknown'} File\n"
            info_text += f"Size: {self.format_file_size(file_size)}\n"
            info_text += f"Location: {file_path}\n\n"
            info_text += "Double-click to open with default application."
            
            self.preview_content.setText(info_text)
        except Exception as e:
            self.preview_content.setText(f"Error reading file info: {str(e)}")
    
    def update_metadata(self, file_path):
        """Extract and display file metadata"""
        try:
            metadata_info = []
            file_ext = os.path.splitext(file_path)[1].lower()
            
            # Basic file information
            stat_info = os.stat(file_path)
            metadata_info.append("=== FILE SYSTEM METADATA ===")
            metadata_info.append(f"Size: {self.format_file_size(stat_info.st_size)}")
            metadata_info.append(f"Created: {datetime.fromtimestamp(stat_info.st_ctime).strftime('%Y-%m-%d %H:%M:%S')}")
            metadata_info.append(f"Modified: {datetime.fromtimestamp(stat_info.st_mtime).strftime('%Y-%m-%d %H:%M:%S')}")
            metadata_info.append(f"Accessed: {datetime.fromtimestamp(stat_info.st_atime).strftime('%Y-%m-%d %H:%M:%S')}")
            metadata_info.append(f"Mode: {oct(stat_info.st_mode)}")
            metadata_info.append("")
            
            # Image metadata (EXIF)
            if PILLOW_AVAILABLE and file_ext in ['.jpg', '.jpeg', '.tiff', '.tif']:
                try:
                    metadata_info.append("=== IMAGE METADATA (EXIF) ===")
                    with Image.open(file_path) as img:
                        metadata_info.append(f"Dimensions: {img.size[0]} x {img.size[1]} pixels")
                        metadata_info.append(f"Mode: {img.mode}")
                        metadata_info.append(f"Format: {img.format}")
                        
                        # Extract EXIF data
                        exif_data = img._getexif()
                        if exif_data:
                            for tag_id, value in exif_data.items():
                                tag = TAGS.get(tag_id, tag_id)
                                metadata_info.append(f"{tag}: {value}")
                        else:
                            metadata_info.append("No EXIF data found")
                    metadata_info.append("")
                except Exception as e:
                    metadata_info.append(f"Error reading image metadata: {str(e)}")
                    metadata_info.append("")
            
            # Audio metadata
            if MUTAGEN_AVAILABLE and file_ext in ['.mp3', '.flac', '.ogg', '.m4a', '.wav', '.aac']:
                try:
                    metadata_info.append("=== AUDIO METADATA ===")
                    audio_file = mutagen.File(file_path)
                    if audio_file:
                        # Basic audio info
                        if hasattr(audio_file, 'info'):
                            info = audio_file.info
                            if hasattr(info, 'length'):
                                metadata_info.append(f"Duration: {int(info.length//60):02d}:{int(info.length%60):02d}")
                            if hasattr(info, 'bitrate'):
                                metadata_info.append(f"Bitrate: {info.bitrate} bps")
                            if hasattr(info, 'sample_rate'):
                                metadata_info.append(f"Sample Rate: {info.sample_rate} Hz")
                        
                        # Tags
                        if audio_file.tags:
                            for key, value in audio_file.tags.items():
                                if isinstance(value, list):
                                    value = ', '.join(str(v) for v in value)
                                metadata_info.append(f"{key}: {value}")
                        else:
                            metadata_info.append("No tags found")
                    else:
                        metadata_info.append("Could not read audio metadata")
                    metadata_info.append("")
                except Exception as e:
                    metadata_info.append(f"Error reading audio metadata: {str(e)}")
                    metadata_info.append("")
            
            # MIME type information
            mime_type, encoding = mimetypes.guess_type(file_path)
            if mime_type or encoding:
                metadata_info.append("=== MIME INFORMATION ===")
                if mime_type:
                    metadata_info.append(f"MIME Type: {mime_type}")
                if encoding:
                    metadata_info.append(f"Encoding: {encoding}")
                metadata_info.append("")
            
            # File magic information (if available)
            if MAGIC_AVAILABLE:
                try:
                    metadata_info.append("=== FILE TYPE DETECTION ===")
                    file_type = magic.from_file(file_path)
                    metadata_info.append(f"Detected Type: {file_type}")
                    metadata_info.append("")
                except Exception as e:
                    metadata_info.append(f"Error detecting file type: {str(e)}")
                    metadata_info.append("")
            
            if not metadata_info or len(metadata_info) <= 8:  # Only basic info
                metadata_info.append("No additional metadata available for this file type.")
            
            self.metadata_text.setText('\n'.join(metadata_info))
            
        except Exception as e:
            self.metadata_text.setText(f"Error extracting metadata: {str(e)}")
    
    def update_hex_view(self, file_path):
        """Display file content in hexadecimal format"""
        try:
            file_size = os.path.getsize(file_path)
            
            # Limit hex view to first 64KB for performance
            max_bytes = 64 * 1024
            if file_size > max_bytes:
                self.hex_text.setText(f"File too large for hex view. Showing first {max_bytes} bytes of {file_size} total bytes.\n\n")
                bytes_to_read = max_bytes
            else:
                bytes_to_read = file_size
            
            with open(file_path, 'rb') as f:
                data = f.read(bytes_to_read)
            
            self.current_hex_data = data
            self.display_hex_data(data)
            
        except Exception as e:
            self.hex_text.setText(f"Error reading file for hex view: {str(e)}")
    
    def display_hex_data(self, data):
        """Format and display hex data with ASCII interpretation"""
        try:
            hex_lines = []
            encoding = self.hex_encoding_combo.currentText()
            
            for i in range(0, len(data), 16):
                chunk = data[i:i+16]
                
                # Offset
                offset = f"{i:08X}"
                
                # Hex representation
                hex_part = ' '.join(f"{b:02X}" for b in chunk)
                hex_part = hex_part.ljust(47)  # Pad to align ASCII part
                
                # ASCII/Text representation
                ascii_part = ""
                for b in chunk:
                    if encoding == "ASCII":
                        ascii_part += chr(b) if 32 <= b <= 126 else '.'
                    elif encoding == "UTF-8":
                        try:
                            # Try to decode as UTF-8
                            ascii_part += chr(b) if 32 <= b <= 126 else '.'
                        except:
                            ascii_part += '.'
                    elif encoding == "UTF-16":
                        try:
                            if i % 2 == 0 and i + 1 < len(data):
                                # Combine two bytes for UTF-16
                                utf16_char = int.from_bytes(data[i:i+2], 'little')
                                ascii_part += chr(utf16_char) if 32 <= utf16_char <= 126 else '.'
                            else:
                                ascii_part += '.'
                        except:
                            ascii_part += '.'
                    elif encoding == "Latin-1":
                        try:
                            ascii_part += chr(b) if 32 <= b <= 255 else '.'
                        except:
                            ascii_part += '.'
                
                line = f"{offset}  {hex_part}  |{ascii_part}|"
                hex_lines.append(line)
            
            # Update header with current offset info
            self.hex_offset_label.setText(f"Showing {len(data)} bytes")
            
            # Display the formatted hex data
            self.hex_text.setText('\n'.join(hex_lines))
            
        except Exception as e:
            self.hex_text.setText(f"Error formatting hex data: {str(e)}")
    
    def update_hex_ascii(self):
        """Update hex view when encoding changes"""
        if self.current_hex_data:
            self.display_hex_data(self.current_hex_data)

class DirectorySelectionDialog(QDialog):
    def create_new_folder(self):
        """Prompt for a folder name and create it in the currently selected directory."""
        base_dir = self.selected_directory or self.initial_dir
        name, ok = QInputDialog.getText(self, "New Folder", "Folder name:", text="New Folder")
        if ok and name.strip():
            new_folder_path = os.path.join(base_dir, name.strip())
            if os.path.exists(new_folder_path):
                QMessageBox.warning(self, "Error", f"A folder named '{name}' already exists.")
                return
            try:
                os.makedirs(new_folder_path)
                # Navigate to the base directory in the dialog
                try:
                    self.navigate_to(base_dir)
                except Exception:
                    pass
                # Try to refresh parent window views if available so the new folder appears immediately
                try:
                    parent = getattr(self, 'parent', None) or self.parent()
                    if parent and hasattr(parent, 'refresh_current_view'):
                        try:
                            parent.refresh_current_view()
                        except Exception:
                            pass
                    # Also attempt to refresh the active tab if there's a tab manager
                    if parent and hasattr(parent, 'tab_manager'):
                        try:
                            ct = parent.tab_manager.get_current_tab()
                            if ct and hasattr(ct, 'refresh_thumbnail_view'):
                                try:
                                    ct.refresh_thumbnail_view()
                                except Exception:
                                    pass
                        except Exception:
                            pass
                except Exception:
                    pass
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Could not create folder: {str(e)}")
    def on_directory_double_clicked(self, index):
        """Handle double-click on a directory in the tree view: navigate into it."""
        path = self.file_model.filePath(index)
        if os.path.isdir(path):
            self.navigate_to(path)
    def on_directory_clicked(self, index):
        """Handle single click on a directory in the tree view."""
        path = self.file_model.filePath(index)
        if os.path.isdir(path):
            self.selected_directory = path
            self.selected_label.setText(path)
            self.ok_button.setEnabled(True)
    def navigate_home(self):
        """Navigate to the user's home directory."""
        home_dir = os.path.expanduser("~")
        self.navigate_to(home_dir)

    def show_my_computer(self):
        """Set the tree to show connected drives (My Computer view)."""
        try:
            # QFileSystemModel with rootPath set to empty string already exposes drives.
            # Use the model index for the filesystem root so the tree shows available drives.
            root_index = self.file_model.index("")
            self.tree_view.setRootIndex(root_index)
            self.path_label.setText("My Computer")
            self.selected_directory = None
            self.selected_label.setText("No directory selected")
            self.ok_button.setEnabled(False)
        except Exception:
            # Best-effort fallback: navigate to filesystem root
            try:
                self.navigate_to(os.path.abspath(os.sep))
            except Exception:
                pass

    def list_system_drives(self):
        """Return a list of available drive paths (Windows and Unix).

        On Windows this enumerates lettered drives; on Unix returns ['/'].
        """
        drives = []
        try:
            if os.name == 'nt':
                import string
                import ctypes
                bitmask = ctypes.cdll.kernel32.GetLogicalDrives()
                for i in range(26):
                    if bitmask & (1 << i):
                        drives.append(f"{string.ascii_uppercase[i]}:/")
            else:
                drives.append(os.path.abspath(os.sep))
        except Exception:
            drives.append(os.path.abspath(os.sep))
        return drives
    """Built-in directory selection dialog using file manager components"""
    
    def __init__(self, title="Select Directory", initial_dir=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setModal(True)
        self.resize(600, 400)
        
        self.selected_directory = None
        self.initial_dir = initial_dir or os.path.expanduser("~")
        
        self.setup_ui()
        self.navigate_to(self.initial_dir)
    
    def setup_ui(self):
        """Setup the dialog UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)

    # Address bar removed: now only shown in breadcrumb when current folder is clicked

        # Header with navigation controls and current path
        header_layout = QHBoxLayout()
        header_layout.setContentsMargins(5, 2, 5, 2)
        header_layout.setSpacing(5)

        # Up button
        up_button = QPushButton("↑ Up")
        up_button.clicked.connect(self.navigate_up)
        header_layout.addWidget(up_button)

        # Home button
        home_button = QPushButton("🏠 Home")
        home_button.clicked.connect(self.navigate_home)
        header_layout.addWidget(home_button)

        header_layout.addStretch()

        layout.addLayout(header_layout)

        # Current path label
        self.path_label = QLabel()
        self.path_label.setStyleSheet("font-weight: bold; padding: 5px; background-color: #f0f0f0;")
        layout.addWidget(self.path_label)
        
        # Tree view for directory navigation
        self.tree_view = QTreeView()
        self.file_model = QFileSystemModel()

        # If this tab was created as a My Computer tab, show drive list only
        if isinstance(self.initial_dir, str) and self.initial_dir == "__MY_COMPUTER__":
            # Root path empty string exposes drives on most platforms
            self.file_model.setRootPath("")
            self.file_model.setFilter(QDir.Drives | QDir.Dirs | QDir.NoDotAndDotDot)
            self.tree_view.setModel(self.file_model)
            # Use empty root index so drives appear as top-level items
            self.tree_view.setRootIndex(self.file_model.index(""))
            # Update label
            self.selected_label.setText("My Computer")
        else:
            self.file_model.setRootPath("")
            self.file_model.setFilter(QDir.Dirs | QDir.NoDotAndDotDot)
            self.tree_view.setModel(self.file_model)
            self.tree_view.setRootIndex(self.file_model.index(self.initial_dir))
        
        # Hide file columns, only show name
        for i in range(1, self.file_model.columnCount()):
            self.tree_view.hideColumn(i)
        
        self.tree_view.clicked.connect(self.on_directory_clicked)
        self.tree_view.doubleClicked.connect(self.on_directory_double_clicked)
        
        layout.addWidget(self.tree_view)
        
        # Selected directory label
        selected_layout = QHBoxLayout()
        selected_layout.addWidget(QLabel("Selected:"))
        self.selected_label = QLabel("No directory selected")
        self.selected_label.setStyleSheet("font-style: italic;")
        selected_layout.addWidget(self.selected_label)
        selected_layout.addStretch()
        layout.addLayout(selected_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        # New folder button
        new_folder_button = QPushButton("Create New Folder")
        new_folder_button.clicked.connect(self.create_new_folder)
        button_layout.addWidget(new_folder_button)
        
        button_layout.addStretch()
        
        # Standard buttons
        self.ok_button = QPushButton("Select")
        self.ok_button.setEnabled(False)
        self.ok_button.clicked.connect(self.accept)
        
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.reject)
        
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(cancel_button)
        
        layout.addLayout(button_layout)
    
    def navigate_to(self, path):
        """Navigate to a specific directory"""
        try:
            # Handle My Computer sentinel explicitly
            if isinstance(path, str) and path == "__MY_COMPUTER__":
                try:
                    self.show_my_computer()
                except Exception:
                    pass
                return

            # Expand user-friendly paths and environment vars
            if isinstance(path, str):
                path = os.path.expanduser(os.path.expandvars(path))

            if os.path.isdir(path):
                index = self.file_model.index(path)
                try:
                    self.tree_view.setRootIndex(index)
                except Exception:
                    pass
                self.path_label.setText(f"Current: {path}")
                self.selected_directory = path
                self.selected_label.setText(path)
            else:
                # Invalid path entered
                return
        except Exception:
            pass

    def on_address_entered(self):
        """Handle Enter in the address bar: navigate or show error"""
    pass  # Address bar is only shown on demand, logic handled elsewhere
    
    def navigate_up(self):
        """Navigate to parent directory"""
        # Determine current folder from this tab's context (address bar or current_folder)
        current = getattr(self, 'current_folder', '')

        # Normalize and compute parent
        current = os.path.normpath(current) if current else ''
        parent_path = os.path.dirname(current)

        # If current is a drive root (Windows like 'C:\') or filesystem root ('/') then
        # navigate to My Computer instead of trying to go above. Use os.path.ismount which
        # correctly identifies mount points/drive roots across platforms.
        try:
            is_drive_root = bool(current) and os.path.ismount(current)
        except Exception:
            # Fallback: treat filesystem root as drive root
            is_drive_root = (current == os.path.abspath(os.sep))

        if is_drive_root:
            # Switch this tab into My Computer drive-list mode
            try:
                # If this tab supports the sentinel, use it to show drives
                self.navigate_to("__MY_COMPUTER__")
            except Exception:
                # Fallback: set list/detail models to root path
                try:
                    self.list_model.setRootPath("")
                    self.list_view.setRootIndex(self.list_model.index(""))
                except Exception:
                    try:
                        self.list_model.setRootPath(QDir.rootPath())
                        self.list_view.setRootIndex(self.list_model.index(QDir.rootPath()))
                    except Exception:
                        pass
            return

        # Normal parent navigation
        if parent_path and parent_path != current:
            self.navigate_to(parent_path)
    
    def force_cleanup(self):
        """Force aggressive memory cleanup with detailed reporting"""
        try:
            try:
                import psutil
                process = psutil.Process()
                memory_before = process.memory_info().rss / 1024 / 1024  # MB
            except ImportError:
                memory_before = 0
            for callback in self.cleanup_callbacks:
                try:
                    callback(aggressive=True)
                except Exception as e:
                    print(f"Aggressive cleanup callback error: {e}")
            import gc
            total_collected = 0
            for i in range(3):
                collected = gc.collect()
                total_collected += collected
                if gc.garbage:
                    print(f"Warning: {len(gc.garbage)} objects still in gc.garbage after pass {i+1}")
            try:
                if memory_before > 0:
                    memory_after = process.memory_info().rss / 1024 / 1024  # MB
                    memory_freed = memory_before - memory_after
            except:
                pass
            self.last_cleanup = time.time()
        except Exception as e:
            print(f"Error in aggressive cleanup: {e}")
    
    def get_selected_directory(self):
        """Get the selected directory path"""
        return self.selected_directory
    
    def format_file_size(self, size_bytes):
        """Format file size in human readable format"""
        if size_bytes == 0:
            return "0 B"
        size_names = ["B", "KB", "MB", "GB", "TB"]
        import math
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"


class PropertiesDialog(QDialog):
    """Properties dialog for files and directories"""
    
    def __init__(self, file_path, parent=None):
        super().__init__(parent)
        self.file_path = file_path
        self.setWindowTitle(f"Properties - {os.path.basename(file_path)}")
        self.setModal(True)
        self.setMinimumSize(400, 500)
        self.resize(450, 600)
        
        self.setup_ui()
        self.load_properties()
        
    def setup_ui(self):
        """Setup the properties dialog UI"""
        layout = QVBoxLayout(self)
        
        # Create tab widget for different property categories
        tabs = QTabWidget()
        
        # General tab
        general_tab = QWidget()
        general_layout = QFormLayout(general_tab)
        
        # File icon and name
        icon_layout = QHBoxLayout()
        self.icon_label = QLabel()
        self.icon_label.setFixedSize(64, 64)
        self.icon_label.setScaledContents(True)
        icon_layout.addWidget(self.icon_label)
        
        name_layout = QVBoxLayout()
        self.name_label = QLabel()
        self.name_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        self.type_label = QLabel()
        name_layout.addWidget(self.name_label)
        name_layout.addWidget(self.type_label)
        name_layout.addStretch()
        
        icon_layout.addLayout(name_layout)
        icon_layout.addStretch()
        general_layout.addRow(icon_layout)
        
        # File properties
        self.location_label = QLabel()
        self.location_label.setWordWrap(True)
        general_layout.addRow("Location:", self.location_label)
        
        self.size_label = QLabel()
        general_layout.addRow("Size:", self.size_label)
        
        self.size_on_disk_label = QLabel()
        general_layout.addRow("Size on disk:", self.size_on_disk_label)
        
        self.created_label = QLabel()
        general_layout.addRow("Created:", self.created_label)
        
        self.modified_label = QLabel()
        general_layout.addRow("Modified:", self.modified_label)
        
        self.accessed_label = QLabel()
        general_layout.addRow("Accessed:", self.accessed_label)
        
        # Attributes section
        general_layout.addRow(QLabel(""))  # Spacer
        attributes_group = QGroupBox("Attributes")
        attr_layout = QVBoxLayout(attributes_group)
        
        self.readonly_checkbox = QCheckBox("Read-only")
        self.hidden_checkbox = QCheckBox("Hidden")
        self.archive_checkbox = QCheckBox("Archive")
        
        attr_layout.addWidget(self.readonly_checkbox)
        attr_layout.addWidget(self.hidden_checkbox)
        attr_layout.addWidget(self.archive_checkbox)
        
        general_layout.addRow(attributes_group)
        
        tabs.addTab(general_tab, "General")
        
        # Security tab (Windows-specific)
        if os.name == 'nt':
            security_tab = QWidget()
            security_layout = QVBoxLayout(security_tab)
            
            security_info = QTextEdit()
            security_info.setReadOnly(True)
            security_info.setPlainText("Security information will be displayed here...")
            security_layout.addWidget(security_info)
            
            tabs.addTab(security_tab, "Security")
        
        # Details tab
        details_tab = QWidget()
        details_layout = QVBoxLayout(details_tab)
        
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        details_layout.addWidget(self.details_text)
        
        tabs.addTab(details_tab, "Details")
        
        # Extended Information tab
        extended_tab = QWidget()
        extended_layout = QVBoxLayout(extended_tab)
        
        self.extended_text = QTextEdit()
        self.extended_text.setReadOnly(True)
        extended_layout.addWidget(self.extended_text)
        
        tabs.addTab(extended_tab, "Extended")
        
        # Checksums tab (for files only)
        if os.path.isfile(self.file_path):
            checksums_tab = QWidget()
            checksums_layout = QFormLayout(checksums_tab)
            
            # MD5
            self.md5_label = QLabel("Calculating...")
            checksums_layout.addRow("MD5:", self.md5_label)
            
            # SHA1
            self.sha1_label = QLabel("Calculating...")
            checksums_layout.addRow("SHA1:", self.sha1_label)
            
            # SHA256
            self.sha256_label = QLabel("Calculating...")
            checksums_layout.addRow("SHA256:", self.sha256_label)
            
            # CRC32
            self.crc32_label = QLabel("Calculating...")
            checksums_layout.addRow("CRC32:", self.crc32_label)
            
            # Calculate checksums button
            calc_button = QPushButton("Calculate Checksums")
            calc_button.clicked.connect(self.calculate_checksums)
            checksums_layout.addRow(calc_button)
            
            tabs.addTab(checksums_tab, "Checksums")
        
        layout.addWidget(tabs)
        
        # Dialog buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        ok_button = QPushButton("OK")
        ok_button.clicked.connect(self.accept)
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.reject)
        apply_button = QPushButton("Apply")
        apply_button.clicked.connect(self.apply_changes)
        
        button_layout.addWidget(ok_button)
        button_layout.addWidget(cancel_button)
        button_layout.addWidget(apply_button)
        
        layout.addLayout(button_layout)
    
    def load_properties(self):
        """Load and display file properties"""
        try:
            stat_info = os.stat(self.file_path)
            
            # Basic info
            self.name_label.setText(os.path.basename(self.file_path))
            self.location_label.setText(os.path.dirname(self.file_path))
            
            # Determine file type
            if os.path.isdir(self.file_path):
                file_type = "Folder"
                # Count items in directory
                try:
                    items = os.listdir(self.file_path)
                    file_count = sum(1 for item in items if os.path.isfile(os.path.join(self.file_path, item)))
                    folder_count = sum(1 for item in items if os.path.isdir(os.path.join(self.file_path, item)))
                    if file_count > 0 and folder_count > 0:
                        file_type += f" ({file_count} files, {folder_count} folders)"
                    elif file_count > 0:
                        file_type += f" ({file_count} files)"
                    elif folder_count > 0:
                        file_type += f" ({folder_count} folders)"
                except PermissionError:
                    file_type += " (Access denied)"
            else:
                # Get file extension
                _, ext = os.path.splitext(self.file_path)
                if ext:
                    file_type = f"{ext.upper()[1:]} File"
                else:
                    file_type = "File"
                    
            self.type_label.setText(file_type)
            
            # File size
            if os.path.isfile(self.file_path):
                size = stat_info.st_size
                self.size_label.setText(f"{self.format_file_size(size)} ({size:,} bytes)")
                
                # Size on disk (approximate)
                block_size = 4096  # Typical block size
                blocks = (size + block_size - 1) // block_size
                size_on_disk = blocks * block_size
                self.size_on_disk_label.setText(f"{self.format_file_size(size_on_disk)} ({size_on_disk:,} bytes)")
            else:
                # For directories, calculate total size
                total_size = self.calculate_directory_size(self.file_path)
                if total_size >= 0:
                    self.size_label.setText(f"{self.format_file_size(total_size)} ({total_size:,} bytes)")
                    self.size_on_disk_label.setText("Calculating...")
                else:
                    self.size_label.setText("Unknown")
                    self.size_on_disk_label.setText("Unknown")
            
            # Dates
            self.created_label.setText(datetime.fromtimestamp(stat_info.st_ctime).strftime('%Y-%m-%d %H:%M:%S'))
            self.modified_label.setText(datetime.fromtimestamp(stat_info.st_mtime).strftime('%Y-%m-%d %H:%M:%S'))
            self.accessed_label.setText(datetime.fromtimestamp(stat_info.st_atime).strftime('%Y-%m-%d %H:%M:%S'))
            
            # Attributes (Windows specific)
            if os.name == 'nt':
                import stat
                mode = stat_info.st_mode
                self.readonly_checkbox.setChecked(not (mode & stat.S_IWRITE))
                
                # Try to get Windows-specific attributes
                try:
                    import win32api
                    import win32con
                    attrs = win32api.GetFileAttributes(self.file_path)
                    self.hidden_checkbox.setChecked(attrs & win32con.FILE_ATTRIBUTE_HIDDEN)
                    self.archive_checkbox.setChecked(attrs & win32con.FILE_ATTRIBUTE_ARCHIVE)
                except ImportError:
                    self.hidden_checkbox.setEnabled(False)
                    self.archive_checkbox.setEnabled(False)
            else:
                # Unix permissions
                import stat
                mode = stat_info.st_mode
                self.readonly_checkbox.setChecked(not (mode & stat.S_IWUSR))
                self.hidden_checkbox.setChecked(os.path.basename(self.file_path).startswith('.'))
                self.archive_checkbox.setEnabled(False)
            
            # Load icon
            self.load_file_icon()
            
            # Load detailed information
            self.load_detailed_info()
            
            # Load extended information
            self.load_extended_info()
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not load properties: {str(e)}")
    
    def calculate_directory_size(self, directory_path):
        """Calculate total size of directory"""
        total_size = 0
        try:
            for dirpath, dirnames, filenames in os.walk(directory_path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except (OSError, IOError):
                        continue
            return total_size
        except (OSError, IOError):
            return -1
    
    def load_file_icon(self):
        """Load and display file icon"""
        try:
            # Use the icon cache from main window if available
            icon = QApplication.instance().style().standardIcon(
                QStyle.SP_DirIcon if os.path.isdir(self.file_path) else QStyle.SP_FileIcon
            )
            pixmap = icon.pixmap(64, 64)
            self.icon_label.setPixmap(pixmap)
        except Exception:
            pass
    
    def load_detailed_info(self):
        """Load detailed file information"""
        details = []
        
        try:
            stat_info = os.stat(self.file_path)
            
            details.append(f"Full Path: {self.file_path}")
            details.append(f"File Mode: {oct(stat_info.st_mode)}")
            details.append(f"Inode: {stat_info.st_ino}")
            details.append(f"Device: {stat_info.st_dev}")
            details.append(f"Links: {stat_info.st_nlink}")
            details.append(f"UID: {stat_info.st_uid}")
            details.append(f"GID: {stat_info.st_gid}")
            
            if hasattr(stat_info, 'st_blocks'):
                details.append(f"Blocks: {stat_info.st_blocks}")
            if hasattr(stat_info, 'st_blksize'):
                details.append(f"Block Size: {stat_info.st_blksize}")
                
            # MIME type for files
            if os.path.isfile(self.file_path):
                mime_type, _ = mimetypes.guess_type(self.file_path)
                if mime_type:
                    details.append(f"MIME Type: {mime_type}")
            
            self.details_text.setPlainText('\n'.join(details))
            
        except Exception as e:
            self.details_text.setPlainText(f"Error loading details: {str(e)}")
    
    def load_extended_info(self):
        """Load extended file information including media metadata"""
        extended_info = []
        
        try:
            # File extension and description
            file_ext = os.path.splitext(self.file_path)[1].lower()
            extended_info.append(f"File Extension: {file_ext if file_ext else 'None'}")
            
            # Enhanced MIME type detection
            mime_type, encoding = mimetypes.guess_type(self.file_path)
            if mime_type:
                extended_info.append(f"MIME Type: {mime_type}")
            if encoding:
                extended_info.append(f"Encoding: {encoding}")
            
            # File-specific information based on type
            if os.path.isfile(self.file_path):
                # Image information
                if file_ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp']:
                    image_info = self.get_image_info()
                    if image_info:
                        extended_info.extend(image_info)
                
                # Video information
                elif file_ext in ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm']:
                    extended_info.append("Media Type: Video File")
                    video_info = self.get_video_info()
                    if video_info:
                        extended_info.extend(video_info)
                
                # Audio information
                elif file_ext in ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma']:
                    extended_info.append("Media Type: Audio File")
                    audio_info = self.get_audio_info()
                    if audio_info:
                        extended_info.extend(audio_info)
                
                # Document information
                elif file_ext in ['.pdf', '.doc', '.docx', '.txt', '.rtf']:
                    extended_info.append("File Type: Document")
                    doc_info = self.get_document_info()
                    if doc_info:
                        extended_info.extend(doc_info)
                
                # Executable information
                elif file_ext in ['.exe', '.dll', '.sys']:
                    extended_info.append("File Type: Executable/Library")
                    exe_info = self.get_executable_info()
                    if exe_info:
                        extended_info.extend(exe_info)
            
            # File system information
            stat_info = os.stat(self.file_path)
            extended_info.append(f"Inode Number: {stat_info.st_ino}")
            extended_info.append(f"Hard Links: {stat_info.st_nlink}")
            
            # Windows-specific information
            if os.name == 'nt':
                try:
                    import win32api
                    import win32con
                    
                    attrs = win32api.GetFileAttributes(self.file_path)
                    attr_list = []
                    if attrs & win32con.FILE_ATTRIBUTE_READONLY:
                        attr_list.append("Read-only")
                    if attrs & win32con.FILE_ATTRIBUTE_HIDDEN:
                        attr_list.append("Hidden")
                    if attrs & win32con.FILE_ATTRIBUTE_SYSTEM:
                        attr_list.append("System")
                    if attrs & win32con.FILE_ATTRIBUTE_ARCHIVE:
                        attr_list.append("Archive")
                    if attrs & win32con.FILE_ATTRIBUTE_COMPRESSED:
                        attr_list.append("Compressed")
                    if attrs & win32con.FILE_ATTRIBUTE_ENCRYPTED:
                        attr_list.append("Encrypted")
                    
                    if attr_list:
                        extended_info.append(f"Windows Attributes: {', '.join(attr_list)}")
                except ImportError:
                    pass
            
            # Unix permissions (detailed)
            else:
                import stat
                mode = stat_info.st_mode
                permissions = []
                
                # Owner permissions
                if mode & stat.S_IRUSR:
                    permissions.append("r")
                else:
                    permissions.append("-")
                if mode & stat.S_IWUSR:
                    permissions.append("w")
                else:
                    permissions.append("-")
                if mode & stat.S_IXUSR:
                    permissions.append("x")
                else:
                    permissions.append("-")
                
                # Group permissions
                if mode & stat.S_IRGRP:
                    permissions.append("r")
                else:
                    permissions.append("-")
                if mode & stat.S_IWGRP:
                    permissions.append("w")
                else:
                    permissions.append("-")
                if mode & stat.S_IXGRP:
                    permissions.append("x")
                else:
                    permissions.append("-")
                
                # Other permissions
                if mode & stat.S_IROTH:
                    permissions.append("r")
                else:
                    permissions.append("-")
                if mode & stat.S_IWOTH:
                    permissions.append("w")
                else:
                    permissions.append("-")
                if mode & stat.S_IXOTH:
                    permissions.append("x")
                else:
                    permissions.append("-")
                
                extended_info.append(f"Permissions: {''.join(permissions)} ({oct(mode)[-3:]})")
            
            self.extended_text.setPlainText('\n'.join(extended_info))
            
        except Exception as e:
            self.extended_text.setPlainText(f"Error loading extended information: {str(e)}")
    
    def get_image_info(self):
        """Get image-specific information"""
        try:
            from PIL import Image
            with Image.open(self.file_path) as img:
                info = []
                info.append(f"Dimensions: {img.width} x {img.height} pixels")
                info.append(f"Color Mode: {img.mode}")
                info.append(f"Format: {img.format}")
                
                # DPI information
                if hasattr(img, 'info') and 'dpi' in img.info:
                    dpi = img.info['dpi']
                    info.append(f"DPI: {dpi[0]} x {dpi[1]}")
                
                # EXIF data for JPEG files
                if hasattr(img, '_getexif') and img._getexif():
                    exif = img._getexif()
                    if exif:
                        info.append("EXIF Data Available: Yes")
                        # Add some common EXIF fields
                        if 272 in exif:  # Make
                            info.append(f"Camera Make: {exif[272]}")
                        if 271 in exif:  # Model
                            info.append(f"Camera Model: {exif[271]}")
                
                return info
        except ImportError:
            return ["PIL library not available for image analysis"]
        except Exception:
            return ["Could not analyze image file"]
    
    def get_video_info(self):
        """Get video-specific information"""
        try:
            # Basic file size-based estimation
            file_size = os.path.getsize(self.file_path)
            return [f"File contains video data (Size: {self.format_file_size(file_size)})"]
        except Exception:
            return ["Could not analyze video file"]
    
    def get_audio_info(self):
        """Get audio-specific information"""
        try:
            # Basic file size-based estimation
            file_size = os.path.getsize(self.file_path)
            return [f"File contains audio data (Size: {self.format_file_size(file_size)})"]
        except Exception:
            return ["Could not analyze audio file"]
    
    def get_document_info(self):
        """Get document-specific information"""
        try:
            info = []
            file_size = os.path.getsize(self.file_path)
            
            # Try to count lines for text files
            if self.file_path.endswith('.txt'):
                try:
                    with open(self.file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        lines = sum(1 for _ in f)
                    info.append(f"Lines: {lines:,}")
                except Exception:
                    pass
            
            return info
        except Exception:
            return ["Could not analyze document"]
    
    def get_executable_info(self):
        """Get executable-specific information"""
        try:
            info = []
            
            # Windows PE information
            if os.name == 'nt':
                try:
                    import win32api
                    version_info = win32api.GetFileVersionInfo(self.file_path, "\\")
                    if version_info:
                        info.append("PE File: Yes")
                        ms = version_info['FileVersionMS']
                        ls = version_info['FileVersionLS']
                        version = f"{win32api.HIWORD(ms)}.{win32api.LOWORD(ms)}.{win32api.HIWORD(ls)}.{win32api.LOWORD(ls)}"
                        info.append(f"File Version: {version}")
                except ImportError:
                    info.append("Win32 API not available")
                except Exception:
                    pass
            
            return info
        except Exception:
            return ["Could not analyze executable"]
    
    def calculate_checksums(self):
        """Calculate file checksums"""
        import hashlib
        import zlib
        from PyQt5.QtCore import QThread, pyqtSignal
        
        class ChecksumWorker(QThread):
            md5_ready = pyqtSignal(str)
            sha1_ready = pyqtSignal(str)
            sha256_ready = pyqtSignal(str)
            crc32_ready = pyqtSignal(str)
            error_occurred = pyqtSignal(str)
            
            def __init__(self, file_path):
                super().__init__()
                self.file_path = file_path
            
            def run(self):
                try:
                    md5_hash = hashlib.md5()
                    sha1_hash = hashlib.sha1()
                    sha256_hash = hashlib.sha256()
                    crc32_hash = 0
                    
                    with open(self.file_path, 'rb') as f:
                        for chunk in iter(lambda: f.read(8192), b""):
                            md5_hash.update(chunk)
                            sha1_hash.update(chunk)
                            sha256_hash.update(chunk)
                            crc32_hash = zlib.crc32(chunk, crc32_hash)
                    
                    self.md5_ready.emit(md5_hash.hexdigest().upper())
                    self.sha1_ready.emit(sha1_hash.hexdigest().upper())
                    self.sha256_ready.emit(sha256_hash.hexdigest().upper())
                    self.crc32_ready.emit(f"{crc32_hash & 0xffffffff:08X}")
                    
                except Exception as e:
                    self.error_occurred.emit(str(e))
        
        # Start checksum calculation in background
        self.checksum_worker = ChecksumWorker(self.file_path)
        self.checksum_worker.md5_ready.connect(self.md5_label.setText)
        self.checksum_worker.sha1_ready.connect(self.sha1_label.setText)
        self.checksum_worker.sha256_ready.connect(self.sha256_label.setText)
        self.checksum_worker.crc32_ready.connect(self.crc32_label.setText)
        self.checksum_worker.error_occurred.connect(lambda e: self.md5_label.setText(f"Error: {e}"))
        self.checksum_worker.start()
    
    def apply_changes(self):
        """Apply any changes made to file attributes"""
        try:
            if os.name == 'nt':
                # Windows attribute changes
                try:
                    import win32api
                    import win32con
                    
                    attrs = 0
                    if self.readonly_checkbox.isChecked():
                        attrs |= win32con.FILE_ATTRIBUTE_READONLY
                    if self.hidden_checkbox.isChecked():
                        attrs |= win32con.FILE_ATTRIBUTE_HIDDEN
                    if self.archive_checkbox.isChecked():
                        attrs |= win32con.FILE_ATTRIBUTE_ARCHIVE
                    
                    if attrs == 0:
                        attrs = win32con.FILE_ATTRIBUTE_NORMAL
                        
                    win32api.SetFileAttributes(self.file_path, attrs)
                    
                except ImportError:
                    QMessageBox.warning(self, "Warning", "Windows API not available for attribute changes")
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Could not change attributes: {str(e)}")
            else:
                # Unix permission changes
                import stat
                current_mode = os.stat(self.file_path).st_mode
                
                if self.readonly_checkbox.isChecked():
                    # Remove write permission
                    new_mode = current_mode & ~stat.S_IWUSR & ~stat.S_IWGRP & ~stat.S_IWOTH
                else:
                    # Add write permission for user
                    new_mode = current_mode | stat.S_IWUSR
                
                os.chmod(self.file_path, new_mode)
            
            QMessageBox.information(self, "Success", "Properties updated successfully")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not apply changes: {str(e)}")
    
    def format_file_size(self, size_bytes):
        """Format file size in human readable format"""
        if size_bytes == 0:
            return "0 B"
        size_names = ["B", "KB", "MB", "GB", "TB"]
        import math
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"
    
    def preview_image(self, file_path):
        try:
            pixmap = QPixmap(file_path)
            if not pixmap.isNull():
                # Scale image to fit preview area
                scaled_pixmap = pixmap.scaled(300, 300, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.preview_content.setPixmap(scaled_pixmap)
            else:
                self.preview_content.setText("Cannot preview this image format")
        except Exception as e:
            self.preview_content.setText(f"Error previewing image: {str(e)}")
    
    def preview_text_file(self, file_path):
        try:
            file_size = os.path.getsize(file_path)
            if file_size > 1024 * 1024:  # 1MB limit
                self.preview_content.setText("File too large to preview")
                return
                
            self.preview_area.hide()
            self.text_editor.show()
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read(10000)  # Limit to first 10000 characters
                if len(content) == 10000:
                    content += "\n\n... (truncated)"
                self.text_editor.setPlainText(content)
        except Exception as e:
            self.preview_content.setText(f"Error previewing text: {str(e)}")
    
    def preview_generic_file(self, file_path):
        file_info = QFileInfo(file_path)
        info_text = f"File: {file_info.fileName()}\n"
        info_text += f"Size: {self.format_size(file_info.size())}\n"
        info_text += f"Type: {file_info.suffix().upper() if file_info.suffix() else 'Unknown'}\n"
        info_text += "\nPreview not available for this file type"
        self.preview_content.setText(info_text)
    
    def update_folder_preview(self, folder_path):
        self.text_editor.hide()
        self.preview_area.show()
        
        try:
            items = os.listdir(folder_path)
            file_count = sum(1 for item in items if os.path.isfile(os.path.join(folder_path, item)))
            dir_count = sum(1 for item in items if os.path.isdir(os.path.join(folder_path, item)))
            
            folder_name = os.path.basename(folder_path)
            formatted_folder_name = format_filename_with_underscore_wrap(folder_name)
            info_text = f"Folder: {formatted_folder_name}\n\n"
            info_text += f"Contains:\n"
            info_text += f"  {dir_count} folders\n"
            info_text += f"  {file_count} files\n"
            info_text += f"  {len(items)} total items"
            
            self.preview_content.setText(info_text)
        except Exception as e:
            self.preview_content.setText(f"Error reading folder: {str(e)}")
    
    def update_properties(self, file_info):
        props = []
        props.append(f"Name: {file_info.fileName()}")
        props.append(f"Path: {file_info.absoluteFilePath()}")
        props.append(f"Size: {self.format_size(file_info.size())}")
        props.append(f"Modified: {file_info.lastModified().toString()}")
        props.append(f"Type: {file_info.suffix().upper() if file_info.suffix() else 'Folder' if file_info.isDir() else 'File'}")
        
        if file_info.isFile():
            mime_type, _ = mimetypes.guess_type(file_info.absoluteFilePath())
            if mime_type:
                props.append(f"MIME Type: {mime_type}")
        
        self.properties_text.setText("\n".join(props))
    
    def format_size(self, size):
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} TB"
    
    def clear_preview(self):
        self.header_label.setText("Preview")
        self.preview_content.clear()
        self.text_editor.clear()
        self.properties_text.clear()
        self.current_file = None

class EnhancedSearchEngine(QObject):
    """Advanced search engine with multiple search modes and content indexing"""
    searchCompleted = pyqtSignal(list)  # List of search results
    searchProgress = pyqtSignal(int, str)  # Progress percentage, current file
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.search_thread = None
        self.should_stop = False
        
    def search(self, root_path, search_criteria):
        """Perform search based on criteria"""
        if self.search_thread and self.search_thread.isRunning():
            self.stop_search()
        
        self.search_thread = SearchThread(root_path, search_criteria, self)
        self.search_thread.searchCompleted.connect(self.searchCompleted.emit)
        self.search_thread.searchProgress.connect(self.searchProgress.emit)
        self.search_thread.start()
    
    def stop_search(self):
        """Stop current search operation"""
        if self.search_thread:
            self.search_thread.stop()
            self.search_thread.wait(3000)  # Wait up to 3 seconds

class SearchThread(QThread):
    """Background thread for performing file searches"""
    searchCompleted = pyqtSignal(list)
    searchProgress = pyqtSignal(int, str)
    
    def __init__(self, root_path, search_criteria, parent=None):
        super().__init__(parent)
        self.root_path = root_path
        self.search_criteria = search_criteria
        self.should_stop = False
        
    def stop(self):
        self.should_stop = True
        
    def run(self):
        """Execute search in background thread"""
        results = []
        total_files = 0
        processed_files = 0
        
        # First pass: count total files for progress tracking
        try:
            for root, dirs, files in os.walk(self.root_path):
                if self.should_stop:
                    return
                total_files += len(files) + len(dirs)
        except PermissionError:
            total_files = 1000  # Fallback estimate
        
        # Second pass: actual search
        try:
            for root, dirs, files in os.walk(self.root_path):
                if self.should_stop:
                    break
                
                # Search in directories
                for dir_name in dirs[:]:  # Use slice to allow modification during iteration
                    if self.should_stop:
                        break
                    
                    full_path = os.path.join(root, dir_name)
                    if self._matches_criteria(full_path, dir_name, True):
                        results.append({
                            'path': full_path,
                            'name': dir_name,
                            'type': 'directory',
                            'size': 0,
                            'modified': os.path.getmtime(full_path),
                            'relative_path': os.path.relpath(full_path, self.root_path)
                        })
                    
                    processed_files += 1
                    if processed_files % 50 == 0:  # Update progress every 50 items
                        progress = int((processed_files / total_files) * 100)
                        self.searchProgress.emit(progress, f"Searching: {dir_name}")
                
                # Search in files
                for file_name in files:
                    if self.should_stop:
                        break
                    
                    full_path = os.path.join(root, file_name)
                    if self._matches_criteria(full_path, file_name, False):
                        try:
                            file_size = os.path.getsize(full_path)
                            file_modified = os.path.getmtime(full_path)
                            
                            result = {
                                'path': full_path,
                                'name': file_name,
                                'type': 'file',
                                'size': file_size,
                                'modified': file_modified,
                                'relative_path': os.path.relpath(full_path, self.root_path)
                            }
                            
                            # Add content search if enabled
                            if self.search_criteria.get('content_search') and self._is_text_file(file_name):
                                if self._search_file_content(full_path):
                                    result['content_match'] = True
                                    results.append(result)
                                elif not self.search_criteria.get('search_text'):
                                    results.append(result)
                            else:
                                results.append(result)
                        except (OSError, PermissionError):
                            continue  # Skip files we can't access
                    
                    processed_files += 1
                    if processed_files % 50 == 0:
                        progress = int((processed_files / total_files) * 100)
                        self.searchProgress.emit(progress, f"Searching: {file_name}")
        
        except Exception as e:
            print(f"Search error: {e}")
        
        self.searchCompleted.emit(results)
    
    def _matches_criteria(self, full_path, name, is_directory):
        """Check if item matches search criteria"""
        criteria = self.search_criteria
        
        # Text search
        search_text = criteria.get('search_text', '').lower()
        if search_text:
            if criteria.get('regex_mode'):
                try:
                    if not re.search(search_text, name, re.IGNORECASE):
                        return False
                except re.error:
                    # Invalid regex, fall back to plain text
                    if search_text not in name.lower():
                        return False
            else:
                if search_text not in name.lower():
                    return False
        
        # File type filter
        file_type = criteria.get('file_type', 'all')
        if file_type != 'all':
            if file_type == 'folders' and not is_directory:
                return False
            elif file_type == 'files' and is_directory:
                return False
            elif not is_directory:  # Specific file type filters
                ext = os.path.splitext(name)[1].lower()
                if file_type == 'images' and ext not in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']:
                    return False
                elif file_type == 'documents' and ext not in ['.txt', '.doc', '.docx', '.pdf', '.rtf', '.odt', '.xls', '.xlsx', '.ppt', '.pptx']:
                    return False
                elif file_type == 'videos' and ext not in ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v']:
                    return False
                elif file_type == 'audio' and ext not in ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma', '.m4a']:
                    return False
                elif file_type == 'archives' and ext not in ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz']:
                    return False
        
        # Size filter (only for files)
        if not is_directory:
            try:
                file_size = os.path.getsize(full_path)
                size_filter = criteria.get('size_filter', 'any')
                if size_filter == 'small' and file_size >= 1024 * 1024:  # > 1MB
                    return False
                elif size_filter == 'medium' and (file_size < 1024 * 1024 or file_size >= 10 * 1024 * 1024):  # 1-10MB
                    return False
                elif size_filter == 'large' and (file_size < 10 * 1024 * 1024 or file_size >= 100 * 1024 * 1024):  # 10-100MB
                    return False
                elif size_filter == 'very_large' and file_size < 100 * 1024 * 1024:  # < 100MB
                    return False
            except OSError:
                pass
        
        # Date filter
        try:
            file_time = os.path.getmtime(full_path)
            date_filter = criteria.get('date_filter', 'any')
            now = datetime.now()
            if date_filter == 'today':
                file_date = datetime.fromtimestamp(file_time).date()
                if file_date != now.date():
                    return False
            elif date_filter == 'week':
                week_ago = now - timedelta(days=7)
                if file_time < week_ago.timestamp():
                    return False
            elif date_filter == 'month':
                month_ago = now - timedelta(days=30)
                if file_time < month_ago.timestamp():
                    return False
            elif date_filter == 'year':
                year_ago = now - timedelta(days=365)
                if file_time < year_ago.timestamp():
                    return False
        except OSError:
            pass
        
        return True
    
    def _is_text_file(self, filename):
        """Check if file is likely a text file"""
        text_extensions = {'.txt', '.py', '.js', '.html', '.css', '.xml', '.json', '.csv', '.log', '.md', '.rst'}
        ext = os.path.splitext(filename)[1].lower()
        return ext in text_extensions
    
    def _search_file_content(self, file_path):
        """Search within file content"""
        search_text = self.search_criteria.get('search_text', '').lower()
        if not search_text:
            return False
        
        try:
            # Limit file size for content search (max 10MB)
            if os.path.getsize(file_path) > 10 * 1024 * 1024:
                return False
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read().lower()
                if self.search_criteria.get('regex_mode'):
                    try:
                        return bool(re.search(search_text, content, re.IGNORECASE))
                    except re.error:
                        return search_text in content
                else:
                    return search_text in content
        except (OSError, UnicodeDecodeError, PermissionError):
            return False

class SearchFilterWidget(QWidget):
    """Enhanced search and filter widget with advanced filtering options"""
    searchRequested = pyqtSignal(str, dict)  # search_text, filter_options
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.search_engine = EnhancedSearchEngine(self)
        self.current_results = []
        self.search_timer = QTimer()
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self._perform_delayed_search)
        self.setup_ui()
        self.connect_signals()
    
    def setup_ui(self):
        layout = QVBoxLayout()
        layout.setSpacing(8)
        
        # Search input with advanced options
        search_group = QGroupBox("Search")
        search_layout = QVBoxLayout()
        
        # Main search input
        input_layout = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search files and folders...")
        self.search_input.textChanged.connect(self._on_search_text_changed)
        input_layout.addWidget(self.search_input)
        
        self.search_button = QPushButton("Search")
        self.search_button.clicked.connect(self.perform_search)
        input_layout.addWidget(self.search_button)
        
        self.stop_button = QPushButton("Stop")
        self.stop_button.clicked.connect(self.stop_search)
        self.stop_button.setEnabled(False)
        input_layout.addWidget(self.stop_button)
        
        search_layout.addLayout(input_layout)
        
        # Search options
        options_layout = QHBoxLayout()
        self.regex_checkbox = QCheckBox("Regex")
        self.regex_checkbox.setToolTip("Use regular expressions for pattern matching")
        options_layout.addWidget(self.regex_checkbox)
        
        self.content_checkbox = QCheckBox("Search Content")
        self.content_checkbox.setToolTip("Search inside text files (slower)")
        options_layout.addWidget(self.content_checkbox)
        
        self.case_checkbox = QCheckBox("Case Sensitive")
        options_layout.addWidget(self.case_checkbox)
        
        options_layout.addStretch()
        search_layout.addLayout(options_layout)
        
        search_group.setLayout(search_layout)
        layout.addWidget(search_group)
        
        # Advanced filters
        filter_group = QGroupBox("Filters")
        filter_layout = QGridLayout()
        
        # File type filter
        filter_layout.addWidget(QLabel("Type:"), 0, 0)
        self.type_combo = QComboBox()
        self.type_combo.addItems([
            "All", "Files Only", "Folders Only", "Images", "Documents", 
            "Videos", "Audio", "Archives"
        ])
        self.type_combo.currentTextChanged.connect(self._on_filter_changed)
        filter_layout.addWidget(self.type_combo, 0, 1)
        
        # Size filter
        filter_layout.addWidget(QLabel("Size:"), 1, 0)
        self.size_combo = QComboBox()
        self.size_combo.addItems([
            "Any Size", "Small (<1MB)", "Medium (1-10MB)", 
            "Large (10-100MB)", "Very Large (>100MB)"
        ])
        self.size_combo.currentTextChanged.connect(self._on_filter_changed)
        filter_layout.addWidget(self.size_combo, 1, 1)
        
        # Date filter
        filter_layout.addWidget(QLabel("Modified:"), 2, 0)
        self.date_combo = QComboBox()
        self.date_combo.addItems([
            "Any Time", "Today", "This Week", "This Month", "This Year"
        ])
        self.date_combo.currentTextChanged.connect(self._on_filter_changed)
        filter_layout.addWidget(self.date_combo, 2, 1)
        
        # Extension filter
        filter_layout.addWidget(QLabel("Extension:"), 3, 0)
        self.extension_input = QLineEdit()
        self.extension_input.setPlaceholderText("e.g., .txt, .py")
        self.extension_input.textChanged.connect(self._on_filter_changed)
        filter_layout.addWidget(self.extension_input, 3, 1)
        
        filter_group.setLayout(filter_layout)
        layout.addWidget(filter_group)
        
        # Search results area
        results_group = QGroupBox("Results")
        results_layout = QVBoxLayout()
        
        # Results info
        self.results_info = QLabel("Ready to search")
        results_layout.addWidget(self.results_info)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        results_layout.addWidget(self.progress_bar)
        
        # Results list
        self.results_list = QListWidget()
        self.results_list.itemDoubleClicked.connect(self._on_result_double_clicked)
        results_layout.addWidget(self.results_list)
        
        # Results actions
        results_actions = QHBoxLayout()
        self.open_button = QPushButton("Open")
        self.open_button.clicked.connect(self._open_selected_result)
        self.open_button.setEnabled(False)
        results_actions.addWidget(self.open_button)
        
        self.reveal_button = QPushButton("Show in Folder")
        self.reveal_button.clicked.connect(self._reveal_selected_result)
        self.reveal_button.setEnabled(False)
        results_actions.addWidget(self.reveal_button)
        
        self.clear_button = QPushButton("Clear Results")
        self.clear_button.clicked.connect(self.clear_results)
        results_actions.addWidget(self.clear_button)
        
        results_actions.addStretch()
        results_layout.addLayout(results_actions)
        
        results_group.setLayout(results_layout)
        layout.addWidget(results_group)
        
        self.setLayout(layout)
    
    def connect_signals(self):
        """Connect search engine signals"""
        self.search_engine.searchCompleted.connect(self._on_search_completed)
        self.search_engine.searchProgress.connect(self._on_search_progress)
        self.results_list.itemSelectionChanged.connect(self._on_selection_changed)
    
    def _on_search_text_changed(self):
        """Handle search text changes with delay"""
        self.search_timer.stop()
        if len(self.search_input.text()) >= 2:
            self.search_timer.start(500)  # 500ms delay
        elif len(self.search_input.text()) == 0:
            self.clear_results()
    
    def _on_filter_changed(self):
        """Handle filter changes"""
        if self.search_input.text():
            self.search_timer.stop()
            self.search_timer.start(300)  # Shorter delay for filter changes
    
    def _perform_delayed_search(self):
        """Perform search after delay"""
        self.perform_search()
    
    def perform_search(self):
        """Execute search with current criteria"""
        search_text = self.search_input.text().strip()
        
        # Get current tab's folder as search root
        parent_window = self.parent()
        while parent_window and not hasattr(parent_window, 'tab_manager'):
            parent_window = parent_window.parent()
        
        if not parent_window or not parent_window.tab_manager:
            return
        
        current_tab = parent_window.tab_manager.get_current_tab()
        if not current_tab:
            return
        
        search_root = current_tab.current_folder
        
        # Build search criteria
        criteria = {
            'search_text': search_text,
            'file_type': self._get_file_type_key(),
            'size_filter': self._get_size_key(),
            'date_filter': self._get_date_key(),
            'extension': self.extension_input.text().strip(),
            'regex_mode': self.regex_checkbox.isChecked(),
            'content_search': self.content_checkbox.isChecked(),
            'case_sensitive': self.case_checkbox.isChecked()
        }
        
        # Start search
        self.results_info.setText(f"Searching in {search_root}...")
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        self.search_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.clear_results()
        
        self.search_engine.search(search_root, criteria)
    
    def stop_search(self):
        """Stop current search"""
        self.search_engine.stop_search()
        self.progress_bar.setVisible(False)
        self.search_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        self.results_info.setText("Search stopped")
    
    def clear_results(self):
        """Clear search results"""
        self.results_list.clear()
        self.current_results = []
        self.open_button.setEnabled(False)
        self.reveal_button.setEnabled(False)
    
    def _get_file_type_key(self):
        """Convert combo box selection to internal key"""
        type_map = {
            "All": "all",
            "Files Only": "files", 
            "Folders Only": "folders",
            "Images": "images",
            "Documents": "documents",
            "Videos": "videos",
            "Audio": "audio",
            "Archives": "archives"
        }
        return type_map.get(self.type_combo.currentText(), "all")
    
    def _get_size_key(self):
        """Convert size combo to internal key"""
        size_map = {
            "Any Size": "any",
            "Small (<1MB)": "small",
            "Medium (1-10MB)": "medium",
            "Large (10-100MB)": "large",
            "Very Large (>100MB)": "very_large"
        }
        return size_map.get(self.size_combo.currentText(), "any")
    
    def _get_date_key(self):
        """Convert date combo to internal key"""
        date_map = {
            "Any Time": "any",
            "Today": "today",
            "This Week": "week", 
            "This Month": "month",
            "This Year": "year"
        }
        return date_map.get(self.date_combo.currentText(), "any")
    
    def _on_search_completed(self, results):
        """Handle search completion"""
        self.current_results = results
        self.progress_bar.setVisible(False)
        self.search_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        
        self.results_list.clear()
        
        if not results:
            self.results_info.setText("No results found")
            return
        
        self.results_info.setText(f"Found {len(results)} items")
        
        # Sort results by relevance (directories first, then by name)
        results.sort(key=lambda x: (x['type'] != 'directory', x['name'].lower()))
        
        for result in results:
            item_text = result['name']
            if result['type'] == 'directory':
                item_text = f"📁 {item_text}"
            else:
                # Add file size info
                size = result['size']
                if size < 1024:
                    size_str = f"{size} B"
                elif size < 1024 * 1024:
                    size_str = f"{size/1024:.1f} KB"
                elif size < 1024 * 1024 * 1024:
                    size_str = f"{size/(1024*1024):.1f} MB"
                else:
                    size_str = f"{size/(1024*1024*1024):.1f} GB"
                
                item_text = f"📄 {item_text} ({size_str})"
            
            # Add relative path info
            if result['relative_path'] != result['name']:
                item_text += f" - {os.path.dirname(result['relative_path'])}"
            
            item = QListWidgetItem(item_text)
            item.setData(Qt.UserRole, result)
            item.setToolTip(result['path'])
            self.results_list.addItem(item)
    
    def _on_search_progress(self, percentage, current_file):
        """Handle search progress updates"""
        self.progress_bar.setValue(percentage)
        if current_file:
            # Truncate long filenames
            if len(current_file) > 50:
                current_file = current_file[:47] + "..."
            self.results_info.setText(f"Searching... {current_file}")
    
    def _on_selection_changed(self):
        """Handle result selection changes"""
        has_selection = bool(self.results_list.currentItem())
        self.open_button.setEnabled(has_selection)
        self.reveal_button.setEnabled(has_selection)
    
    def _on_result_double_clicked(self, item):
        """Handle double-click on result item"""
        self._open_selected_result()
    
    def _open_selected_result(self):
        """Open the selected result"""
        current_item = self.results_list.currentItem()
        if not current_item:
            return
        
        result = current_item.data(Qt.UserRole)
        if result['type'] == 'directory':
            # Navigate to directory
            self._navigate_to_path(result['path'])
        elif ArchiveManager.is_archive(result['path']):
            # For archive files, use built-in browser
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'browse_archive_contents'):
                main_window = main_window.parent()
            if main_window:
                main_window.browse_archive_contents(result['path'])
            else:
                # Fallback if browse method not found
                QDesktopServices.openUrl(QUrl.fromLocalFile(result['path']))
        else:
            # Open file with default application
            try:
                QDesktopServices.openUrl(QUrl.fromLocalFile(result['path']))
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Could not open file: {e}")
    
    def _reveal_selected_result(self):
        """Reveal selected result in file manager"""
        current_item = self.results_list.currentItem()
        if not current_item:
            return
        
        result = current_item.data(Qt.UserRole)
        if result['type'] == 'directory':
            self._navigate_to_path(result['path'])
        else:
            # Navigate to parent directory and select file
            parent_dir = os.path.dirname(result['path'])
            self._navigate_to_path(parent_dir)
    
    def _navigate_to_path(self, path):
        """Navigate to the specified path in the main window"""
        parent_window = self.parent()
        while parent_window and not hasattr(parent_window, 'tab_manager'):
            parent_window = parent_window.parent()
        
        if parent_window and parent_window.tab_manager:
            current_tab = parent_window.tab_manager.get_current_tab()
            if current_tab:
                current_tab.navigate_to(path)

class SearchFilterWidget_Old(QWidget):
    """Original simple search widget - kept for backward compatibility"""
    searchRequested = pyqtSignal(str, dict)  # search_text, filter_options
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
    
    def setup_ui(self):
        layout = QVBoxLayout()
        
        # Search input
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("Search:"))
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Enter search terms...")
        self.search_input.textChanged.connect(self.on_search_changed)
        search_layout.addWidget(self.search_input)
        
        self.search_button = QPushButton("Search")
        self.search_button.clicked.connect(self.perform_search)
        search_layout.addWidget(self.search_button)
        
        layout.addLayout(search_layout)
        
        # Filter options
        filter_group = QFrame()
        filter_group.setFrameStyle(QFrame.StyledPanel)
        filter_layout = QVBoxLayout()
        
        filter_layout.addWidget(QLabel("Filters:"))
        
        # File type filter
        type_layout = QHBoxLayout()
        type_layout.addWidget(QLabel("Type:"))
        self.type_combo = QComboBox()
        self.type_combo.addItems(["All", "Files Only", "Folders Only", "Images", "Documents", "Videos", "Audio"])
        self.type_combo.currentTextChanged.connect(self.on_filter_changed)
        type_layout.addWidget(self.type_combo)
        filter_layout.addLayout(type_layout)
        
        # Size filter
        size_layout = QHBoxLayout()
        size_layout.addWidget(QLabel("Size:"))
        self.size_combo = QComboBox()
        self.size_combo.addItems(["Any Size", "Small (<1MB)", "Medium (1-10MB)", "Large (10-100MB)", "Very Large (>100MB)"])
        self.size_combo.currentTextChanged.connect(self.on_filter_changed)
        size_layout.addWidget(self.size_combo)
        filter_layout.addLayout(size_layout)
        
        # Date filter
        date_layout = QHBoxLayout()
        date_layout.addWidget(QLabel("Modified:"))
        self.date_combo = QComboBox()
        self.date_combo.addItems(["Any Time", "Today", "This Week", "This Month", "This Year"])
        self.date_combo.currentTextChanged.connect(self.on_filter_changed)
        date_layout.addWidget(self.date_combo)
        filter_layout.addLayout(date_layout)
        
        filter_group.setLayout(filter_layout)
        layout.addWidget(filter_group)
        
        self.setLayout(layout)
    
    def on_search_changed(self):
        if len(self.search_input.text()) >= 2 or len(self.search_input.text()) == 0:
            self.perform_search()
    
    def on_filter_changed(self):
        self.perform_search()
    
    def perform_search(self):
        search_text = self.search_input.text()
        filter_options = {
            'type': self.type_combo.currentText(),
            'size': self.size_combo.currentText(),
            'date': self.date_combo.currentText()
        }
        self.searchRequested.emit(search_text, filter_options)

class ViewModeManager:
    """Manages different view modes for the file display"""
    THUMBNAIL_VIEW = "thumbnail"
    ICON_VIEW = "icon"
    LIST_VIEW = "list"
    DETAIL_VIEW = "detail"
    
    def __init__(self):
        self.current_mode = self.THUMBNAIL_VIEW
        self.view_widgets = {}
    
    def set_mode(self, mode):
        # Accept ICON_VIEW as a valid mode as well
        if mode in [self.THUMBNAIL_VIEW, self.ICON_VIEW, self.LIST_VIEW, self.DETAIL_VIEW]:
            self.current_mode = mode
    
    def get_mode(self):
        return self.current_mode

class IconWidget(QWidget):
    clicked = pyqtSignal(str, object)  # Pass the event modifiers
    doubleClicked = pyqtSignal(str)
    rightClicked = pyqtSignal(str, QPoint)

    def __init__(self, file_name, full_path, is_dir, thumbnail_size=64, thumbnail_cache=None, use_icon_only=False, parent=None):
        super().__init__(parent)
        self.file_name = file_name
        self.full_path = full_path
        self.is_dir = is_dir
        self.thumbnail_size = thumbnail_size
        self.thumbnail_cache = thumbnail_cache
        self.use_icon_only = use_icon_only
        self.dark_mode = False
        self.is_selected = False

        layout = QVBoxLayout()
        layout.setSpacing(2)
        layout.setContentsMargins(4, 4, 4, 4)

        # Create icon or thumbnail
        pixmap = self.create_icon_or_thumbnail(full_path, is_dir)
        self.icon_label = QLabel()
        self.icon_label.setPixmap(pixmap)
        self.icon_label.setAlignment(Qt.AlignCenter | Qt.AlignVCenter)
        self.icon_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.icon_label.setMinimumHeight(self.thumbnail_size)
        self.icon_label.setMaximumHeight(16777215)
        self.icon_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.icon_label.setMinimumHeight(self.thumbnail_size)
        self.icon_label.setMaximumHeight(16777215)  # No artificial max height

        # Pie chart for drive usage (only for drives in My Computer)
        self.pie_chart_label = None
        show_drive_pie = False
        import os, shutil
        # Heuristic: show pie if this is a drive root (C:/ etc) and in My Computer
        try:
            # Only show for top-level drives (not folders/files)
            if os.name == 'nt' and len(full_path) >= 2 and full_path[1] == ':' and (full_path.endswith('/') or full_path.endswith('\\')):
                if os.path.ismount(full_path):
                    show_drive_pie = True
            elif os.name != 'nt' and os.path.ismount(full_path):
                show_drive_pie = True
        except Exception:
            pass
        if show_drive_pie:
            try:
                usage = shutil.disk_usage(full_path)
                percent = usage.used / usage.total if usage.total > 0 else 0
                pie_size = max(18, int(self.thumbnail_size * 0.38))
                # Make a larger pixmap for text to overflow
                margin = int(pie_size * 0.35)
                total_size = pie_size + margin * 2
                overlay_pixmap = QPixmap(total_size, total_size)
                overlay_pixmap.fill(Qt.transparent)
                painter = QPainter(overlay_pixmap)
                painter.setRenderHint(QPainter.Antialiasing)
                # Draw pie chart centered
                pie_rect = QRect(margin, margin, pie_size, pie_size)
                painter.setBrush(QColor(220, 220, 220))
                painter.setPen(Qt.NoPen)
                painter.drawEllipse(pie_rect)
                painter.setBrush(QColor(0, 120, 215))
                start_angle = 90 * 16
                span_angle = -int(360 * percent * 16)
                painter.drawPie(pie_rect, start_angle, span_angle)
                # Overlay free space in GB as text (can overflow pie)
                free_gb = usage.free / (1024 ** 3)
                painter.setPen(QColor(0, 180, 0))
                font = painter.font()
                font.setPointSizeF(max(6, pie_size * 0.32 * 0.9))
                font.setBold(True)
                painter.setFont(font)
                text = f"{free_gb:.1f}G"
                painter.drawText(overlay_pixmap.rect(), Qt.AlignCenter, text)
                painter.end()
                self.pie_chart_label = QLabel()
                self.pie_chart_label.setPixmap(overlay_pixmap)
                self.pie_chart_label.setAlignment(Qt.AlignCenter | Qt.AlignVCenter)
                self.pie_chart_label.setStyleSheet("background: transparent;")
            except Exception:
                self.pie_chart_label = None

        layout.addWidget(self.icon_label)

        # Create label with filename (apply truncation and underscore wrapping)
        self.label = QLabel()
        font = self.label.font()
        font.setPointSize(8)
        self.label.setFont(font)
        self.label.setWordWrap(True)
        self.label.setAlignment(Qt.AlignCenter | Qt.AlignVCenter)
        self.label.setContentsMargins(2, 2, 2, 2)
        self.label.setStyleSheet("QLabel { padding: 2px; }")
        try:
            self.label.setFixedWidth(self.thumbnail_size)
        except Exception:
            pass
        self.update_label_text()
        layout.addWidget(self.label)

        # Add pie chart below the label if it exists
        if self.pie_chart_label is not None:
            layout.addWidget(self.pie_chart_label)
        self.setLayout(layout)
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        self.setToolTip(full_path)
        self.setStyleSheet("QWidget { border: 2px solid transparent; }")
    
    def update_label_text(self):
        """Update label text based on selection state and apply formatting"""
        # Determine max characters based on current thumbnail width and label font metrics
        try:
            fm = self.label.fontMetrics()
            avg_char_w = max(6, fm.averageCharWidth() or 7)
            max_chars = max(6, int(self.thumbnail_size / avg_char_w))
        except Exception:
            max_chars = 13

        # Apply truncation based on selection state
        display_name = truncate_filename_for_display(self.file_name, max_chars=max_chars, selected=self.is_selected)

        # Apply underscore wrapping if showing full name or if short enough
        if self.is_selected or len(self.file_name) <= max_chars:
            display_name = format_filename_with_underscore_wrap(display_name)

        self.label.setText(display_name)
    
    def set_selected(self, selected):
        """Set the selection state and update display accordingly"""
        if self.is_selected != selected:
            self.is_selected = selected
            self.update_label_text()
            # Update border style to show selection
            if selected:
                self.setStyleSheet("QWidget { border: 2px solid #0078d4; background-color: rgba(0, 120, 212, 0.1); }")
            else:
                self.setStyleSheet("QWidget { border: 2px solid transparent; }")

    def update_style_for_theme(self, dark_mode):
        """Update the widget style based on the current theme"""
        self.dark_mode = dark_mode
        if dark_mode:
            self.label.setStyleSheet("QLabel { color: #ffffff; padding: 2px; }")
        else:
            self.label.setStyleSheet("QLabel { padding: 2px; }")
    
    def update_thumbnail_size(self, new_size):
        """Update the icon/thumbnail size for this widget"""
    # ...removed thumbnail debug message...
        if self.thumbnail_size != new_size:
            self.thumbnail_size = new_size
            # Regenerate the icon with the new size
            pixmap = self.create_icon_or_thumbnail(self.full_path, self.is_dir)
            self.icon_label.setPixmap(pixmap)
            # Resize icon_label widget area if possible
            try:
                self.icon_label.setFixedSize(new_size, new_size)
            except Exception:
                pass
            # Ensure filename label width matches new thumbnail width
            try:
                self.label.setFixedWidth(new_size)
            except Exception:
                pass
            # Refresh text to recalc truncation
            try:
                self.update_label_text()
            except Exception:
                pass
            self.update()  # Force a repaint

    def create_icon_or_thumbnail(self, full_path, is_dir):
        thumbnail_debug('create_icon_or_thumbnail called: {} (is_dir={})', full_path, is_dir)
        """Create either a file icon or an image thumbnail"""
        size = self.thumbnail_size
        # APK thumbnails are handled later once file_ext is available to avoid blocking other logic
        # Determine effective icon-only mode: respect the widget flag or fall back to main window's view mode
        effective_icon_only = getattr(self, 'use_icon_only', False)
        try:
            # Walk up to find the main window and check its view_mode_manager
            parent = self.parent()
            while parent is not None and not hasattr(parent, 'view_mode_manager'):
                parent = parent.parent()
            if parent is not None and hasattr(parent, 'view_mode_manager'):
                if parent.view_mode_manager.get_mode() == ViewModeManager.ICON_VIEW:
                    effective_icon_only = True
            # Respect the global user preference if set on main window
            try:
                if parent is not None and hasattr(parent, 'icon_view_use_icons_only') and not parent.icon_view_use_icons_only:
                    # User asked not to use icons-only behavior; disable the effective flag
                    effective_icon_only = False
                elif parent is not None and hasattr(parent, 'icon_view_use_icons_only') and parent.icon_view_use_icons_only and parent.view_mode_manager.get_mode() == ViewModeManager.ICON_VIEW:
                    effective_icon_only = True
            except Exception:
                pass
            # Also respect a direct flag on the main window if present
            try:
                if parent is not None and hasattr(parent, 'icon_view_active') and parent.icon_view_active:
                    effective_icon_only = True
            except Exception:
                pass
        except Exception:
            pass
        # Debug
        thumbnail_debug('effective_icon_only={} for {}', effective_icon_only, full_path)

        # If this is a directory, handle differently depending on mode
        if is_dir:
            # In icon-only mode show a simple folder icon (no composite previews)
            if effective_icon_only:
                try:
                    icon_provider = QFileIconProvider()
                    folder_info = QFileInfo(full_path)
                    folder_icon = icon_provider.icon(folder_info)
                    if not folder_icon.isNull():
                        pix = folder_icon.pixmap(size, size)
                        if pix.width() != size or pix.height() != size:
                            pix = pix.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                        return pix
                except Exception:
                    # Fallback to generic folder drawing
                    framed_pixmap = QPixmap(size, size)
                    framed_pixmap.fill(Qt.transparent)
                    painter = QPainter(framed_pixmap)
                    try:
                        self.draw_generic_file_icon(painter, size, True)
                    except Exception:
                        pass
                    painter.end()
                    return framed_pixmap
            # Not icon-only: use the composite folder preview as before
            return self.create_folder_preview(full_path, size)

        # Guard: do not attempt to generate thumbnails for thumbnail cache files themselves
        try:
            if is_thumb_file(full_path):
                thumbnail_debug('Skipping thumbnail generation for .thumb file: {}', full_path)
                framed_pixmap = QPixmap(size, size)
                framed_pixmap.fill(Qt.transparent)
                painter = QPainter(framed_pixmap)
                try:
                    # Draw a default file icon into the frame
                    self.draw_default_file_icon(painter, full_path, size)
                except Exception:
                    pass
                try:
                    painter.end()
                except Exception:
                    pass
                return framed_pixmap
        except Exception:
            # if guard check fails, continue with normal behavior
            pass

        # If we're in icon-only mode, avoid expensive thumbnail generation (images, video frames, waveforms)
        if effective_icon_only:
            framed_pixmap = QPixmap(size, size)
            framed_pixmap.fill(Qt.transparent)
            painter = QPainter(framed_pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            try:
                file_ext = os.path.splitext(full_path)[1].lower()
                # In icon-only mode we handle archives/exes/default drawing below; do not special-case APK here
                if ArchiveManager.is_archive(full_path):
                    # For archives, when we're in thumbnail view (not icon-only),
                    # prefer the enhanced preview showing archive contents
                    try:
                        archive_type = ArchiveManager.get_archive_type(full_path)
                    except Exception:
                        archive_type = None
                    
                    if not effective_icon_only:
                        # Show archive contents preview for all archive types in thumbnail mode
                        if archive_type == '.iso':
                            # ISO files: try enhanced ISO thumbnail first, fallback to contents preview
                            try:
                                # draw_archive_icon supports a force_custom flag via locals()
                                self.draw_archive_icon(painter, full_path, size, force_custom=True)
                            except TypeError:
                                # Older call signature fallback
                                try:
                                    self.draw_custom_archive_icon(painter, full_path, size)
                                except Exception:
                                    # If ISO-specific handling fails, show contents preview
                                    archive_preview = ArchiveManager.create_archive_preview_thumbnail(full_path, size)
                                    if archive_preview:
                                        painter.drawPixmap(0, 0, archive_preview)
                                    else:
                                        self.draw_archive_icon(painter, full_path, size)
                        else:
                            # For other archive types (ZIP, RAR, 7z, etc.), show contents preview
                            archive_preview = ArchiveManager.create_archive_preview_thumbnail(full_path, size)
                            if archive_preview:
                                painter.drawPixmap(0, 0, archive_preview)
                            else:
                                # Fallback to regular archive icon
                                self.draw_archive_icon(painter, full_path, size)
                    else:
                        # Icon-only mode: just show regular archive icon
                        self.draw_archive_icon(painter, full_path, size)
                elif file_ext == '.exe' and not is_dir:
                    try:
                        icon = get_exe_icon_qicon(full_path, size)
                        if not icon.isNull():
                            pixmap = icon.pixmap(size, size)
                            painter.drawPixmap(0, 0, pixmap)
                        else:
                            self.draw_default_file_icon(painter, full_path, size)
                    except Exception:
                        self.draw_default_file_icon(painter, full_path, size)
                else:
                    # Generic icon for all other file types in icon view
                    self.draw_default_file_icon(painter, full_path, size)
            except Exception:
                self.draw_generic_file_icon(painter, size, is_dir)
            painter.end()
            return framed_pixmap
        # Try to get thumbnail from cache first for files
        if self.thumbnail_cache:
            thumbnail_debug('Checking cache for {}', full_path)
            cached_thumbnail = self.thumbnail_cache.get(full_path, size)
            if cached_thumbnail:
                thumbnail_debug('Cache hit for {}, returning cached thumbnail', full_path)
                # Always return a QPixmap, never raw bytes
                if isinstance(cached_thumbnail, QPixmap):
                    return cached_thumbnail
                elif isinstance(cached_thumbnail, (bytes, bytearray)):
                    pixmap = QPixmap()
                    pixmap.loadFromData(cached_thumbnail, 'PNG')
                    return pixmap
                else:
                    thumbnail_debug('Unexpected cached_thumbnail type: {}', type(cached_thumbnail))
                    return QPixmap()
        # Create a consistent-sized frame for all icons
        framed_pixmap = QPixmap(size, size)
        framed_pixmap.fill(Qt.transparent)
        painter = QPainter(framed_pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        # If this is an ISO archive and we're not in icon-only mode, prefer the
        # enhanced archive thumbnail path which extracts/examines the archive contents.
        try:
            if ArchiveManager.is_archive(full_path):
                try:
                    archive_type = ArchiveManager.get_archive_type(full_path)
                except Exception:
                    archive_type = None
                
                if not effective_icon_only:
                    # Show archive contents preview for all archive types in thumbnail mode
                    if archive_type == '.iso':
                        try:
                            # draw_archive_icon supports a force_custom flag; use it to
                            # request the ISO-specific rendering.
                            self.draw_archive_icon(painter, full_path, size, force_custom=True)
                        except TypeError:
                            # older signature fallback
                            try:
                                self.draw_custom_archive_icon(painter, full_path, size)
                            except Exception:
                                # If ISO-specific handling fails, show contents preview
                                archive_preview = ArchiveManager.create_archive_preview_thumbnail(full_path, size)
                                if archive_preview:
                                    painter.drawPixmap(0, 0, archive_preview)
                                else:
                                    self.draw_custom_archive_icon(painter, full_path, size)
                    else:
                        # For other archive types (ZIP, RAR, 7z, etc.), show contents preview
                        archive_preview = ArchiveManager.create_archive_preview_thumbnail(full_path, size)
                        if archive_preview:
                            painter.drawPixmap(0, 0, archive_preview)
                        else:
                            # Fallback to regular archive icon
                            self.draw_custom_archive_icon(painter, full_path, size)
                    try:
                        painter.end()
                    except Exception:
                        pass
                    return framed_pixmap
        except Exception:
            # If any errors occur, fall through to the normal handling below
            pass
        try:
            # ...existing code for file icon/thumbnail drawing...
                image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp', '.ico', '.xcf'}
                if not PlatformUtils.is_macos():
                    image_extensions.add('.svg')
                file_ext = os.path.splitext(full_path)[1].lower()
                thumbnail_debug('[THUMBNAIL-DEBUG] file_ext for {}: {}', full_path, file_ext)

                # APK/XAPK-specific thumbnail: compose Android robot base and overlay extracted icon if available
                if file_ext in ('.apk', '.xapk') and not is_dir:
                    try:
                        import zipfile
                        from io import BytesIO
                        icon_data = None
                        chosen_name = None
                        with zipfile.ZipFile(full_path, 'r') as z:
                            # Prefer using apkutils2 if available to get the declared icon path
                            try:
                                from apkutils2 import APK
                                apkinfo = APK(full_path)
                                icon_path = None
                                # Primary helper
                                try:
                                    icon_path = apkinfo.get_app_icon()
                                except Exception:
                                    icon_path = None
                                # Try several alternative helper names if available
                                if not icon_path:
                                    for meth in ('get_icon', 'get_manifest_icon', 'get_app_icon_path'):
                                        fn = getattr(apkinfo, meth, None)
                                        if callable(fn):
                                            try:
                                                res = fn()
                                                if res:
                                                    icon_path = res
                                                    break
                                            except Exception:
                                                continue
                                # Try to inspect manifest dictionaries returned by apkutils2
                                if not icon_path:
                                    for mf in ('get_manifest', 'get_android_manifest', 'get_manifest_dict'):
                                        fn = getattr(apkinfo, mf, None)
                                        if callable(fn):
                                            try:
                                                manifest = fn()
                                                if isinstance(manifest, dict):
                                                    app = manifest.get('application') or manifest.get('application', {})
                                                    if isinstance(app, dict):
                                                        icon_candidate = app.get('icon') or app.get('@icon') or app.get('android:icon')
                                                        if icon_candidate:
                                                            icon_path = icon_candidate
                                                            break
                                            except Exception:
                                                continue
                                # If icon_path is a resource name (like 'ic_launcher' or 'mipmap/ic_launcher'), map it to a file inside the APK
                                if icon_path and isinstance(icon_path, str):
                                    norm = icon_path
                                    # If it looks like resource reference (no slash, no extension), try to resolve by name
                                    if not norm.startswith('res/') and '/' not in norm and not norm.endswith(('.png', '.webp')):
                                        resname = norm.split('/')[-1]
                                        found = None
                                        for name in z.namelist():
                                            ln = name.lower()
                                            if ln.endswith((resname + '.png', resname + '.webp')):
                                                found = name
                                                break
                                        if found:
                                            icon_path = found
                                # If resolved path exists in the zip, read it
                                if icon_path and icon_path in z.namelist():
                                    try:
                                        icon_data = z.read(icon_path)
                                        chosen_name = icon_path
                                    except Exception:
                                        icon_data = None
                                print(f'[APK-ICON] apkutils2 resolved icon_path={icon_path}')
                            except Exception:
                                # Collect candidate icon files and pick the largest (likely highest-res)
                                candidates = []
                                for name in z.namelist():
                                    ln = name.lower()
                                    # Broader candidate matching: any png/webp under res/ or assets/ or files whose base name hints at an icon
                                    base = os.path.basename(ln)
                                    is_image = ln.endswith(('.png', '.webp'))
                                    likely_icon_name = any(k in base for k in ('icon', 'ic_', 'launcher', 'foreground', 'round', 'logo'))
                                    if is_image and (ln.startswith('res/') or '/assets/' in ln or likely_icon_name):
                                        try:
                                            info = z.getinfo(name)
                                            candidates.append((name, info.file_size))
                                        except Exception:
                                            candidates.append((name, 0))
                                if candidates:
                                    # choose candidate with largest file size
                                    candidates.sort(key=lambda t: t[1], reverse=True)
                                    # log candidate list for debugging
                                    try:
                                        print(f'[APK-ICON] candidates for {full_path}: ' + ', '.join([f"{n}({s})" for n, s in candidates[:10]]))
                                    except Exception:
                                        pass
                                    chosen_name = candidates[0][0]
                                    try:
                                        icon_data = z.read(chosen_name)
                                    except Exception:
                                        icon_data = None
                                # Fallback: if we still have no chosen_name, search for any res/*.png or res/*.webp and pick largest
                                if not icon_data and not chosen_name:
                                    try:
                                        png_candidates = []
                                        for name in z.namelist():
                                            ln = name.lower()
                                            if (ln.startswith('res/') or '/assets/' in ln) and ln.endswith(('.png', '.webp')):
                                                try:
                                                    info = z.getinfo(name)
                                                    png_candidates.append((name, info.file_size))
                                                except Exception:
                                                    png_candidates.append((name, 0))
                                        if png_candidates:
                                            png_candidates.sort(key=lambda t: t[1], reverse=True)
                                            chosen_name = png_candidates[0][0]
                                            try:
                                                icon_data = z.read(chosen_name)
                                                print(f'[APK-ICON] Fallback chose {chosen_name} from res/ entries')
                                            except Exception:
                                                icon_data = None
                                    except Exception:
                                        pass

                        try:
                            sig = None
                            if icon_data:
                                sig = ' '.join([f'{b:02x}' for b in icon_data[:12]])
                        except Exception:
                            sig = None
                        print(f'[APK-ICON] APK handler: chosen icon path={chosen_name} for {full_path}, bytes={'None' if icon_data is None else len(icon_data)}, sig={sig}')

                        # Final guaranteed fallback: if we still have no icon_data, try one more pass to pick largest res/*.png or .webp
                        if not icon_data:
                            try:
                                with zipfile.ZipFile(full_path, 'r') as z_final:
                                    png_candidates = []
                                    for name in z_final.namelist():
                                        ln = name.lower()
                                        if (ln.startswith('res/') or '/assets/' in ln) and ln.endswith(('.png', '.webp')):
                                            try:
                                                info = z_final.getinfo(name)
                                                png_candidates.append((name, info.file_size))
                                            except Exception:
                                                png_candidates.append((name, 0))
                                    if png_candidates:
                                        png_candidates.sort(key=lambda t: t[1], reverse=True)
                                        chosen_name = png_candidates[0][0]
                                        try:
                                            icon_data = z_final.read(chosen_name)
                                            print(f'[APK-ICON] Final fallback chose {chosen_name} ({len(icon_data) if icon_data else 0} bytes)')
                                        except Exception as e_final:
                                            print(f'[APK-ICON] Final fallback read failed: {e_final}')
                            except Exception:
                                pass

                        base_size = size
                        base_pixmap = QPixmap(base_size, base_size)
                        base_pixmap.fill(Qt.transparent)
                        painter_apk = QPainter(base_pixmap)
                        painter_apk.setRenderHint(QPainter.Antialiasing)
                        painter_apk.setBrush(QColor(164, 198, 57))
                        painter_apk.setPen(Qt.NoPen)
                        painter_apk.drawEllipse(base_size//8, base_size//8, base_size*3//4, base_size*3//4)
                        painter_apk.setBrush(Qt.white)
                        eye_r = max(2, base_size//16)
                        painter_apk.drawEllipse(base_size//3, base_size//2, eye_r, eye_r)
                        painter_apk.drawEllipse(base_size*2//3 - eye_r, base_size//2, eye_r, eye_r)
                        painter_apk.setPen(QPen(QColor(164, 198, 57), max(2, base_size//16)))
                        painter_apk.drawLine(base_size//3, base_size//8, base_size//4, base_size//4)
                        painter_apk.drawLine(base_size*2//3, base_size//8, base_size*3//4, base_size//4)
                        painter_apk.setPen(Qt.NoPen)
                        if icon_data:
                            loaded = False
                            try:
                                icon_pix = QPixmap()
                                if icon_pix.loadFromData(icon_data):
                                    loaded = True
                                    print(f'[APK-ICON] QPixmap.loadFromData succeeded for {chosen_name} ({len(icon_data)} bytes)')
                                else:
                                    print(f'[APK-ICON] QPixmap.loadFromData returned null for {chosen_name}, attempting Pillow fallback')
                            except Exception as e:
                                print(f'[APK-ICON] QPixmap.loadFromData exception for {chosen_name}: {e}')

                            if not loaded:
                                # Try Pillow fallback: convert webp or other bytes to PNG bytes
                                try:
                                    from PIL import Image
                                    buf = BytesIO(icon_data)
                                    img = Image.open(buf)
                                    img = img.convert('RGBA')
                                    out = BytesIO()
                                    img.save(out, format='PNG')
                                    png_bytes = out.getvalue()
                                    icon_pix = QPixmap()
                                    if icon_pix.loadFromData(png_bytes):
                                        loaded = True
                                        print(f'[APK-ICON] Pillow fallback succeeded for {chosen_name} (converted to PNG)')
                                except Exception as e:
                                    print(f'[APK-ICON] Pillow fallback failed for {chosen_name}: {e}')

                            if loaded and not icon_pix.isNull():
                                try:
                                    icon_pix = icon_pix.scaled(base_size*3//4, base_size*3//4, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                                    x = (base_size - icon_pix.width()) // 2
                                    y = (base_size - icon_pix.height()) // 2
                                    painter_apk.drawPixmap(x, y, icon_pix)
                                except Exception as e:
                                    print(f'[APK-ICON] Error drawing icon_pix for {full_path}: {e}')
                        else:
                            print(f'[APK-ICON] No direct icon_data extracted for {full_path} (chosen_name={chosen_name}), attempting adaptive icon resolution')
                            # Try to resolve adaptive icons: parse res XML files for foreground/background drawables
                            try:
                                from xml.etree import ElementTree as ET
                                from io import BytesIO as _BytesIO
                                try:
                                    from PIL import Image as _Image
                                except Exception:
                                    _Image = None
                                found_adaptive = False
                                with zipfile.ZipFile(full_path, 'r') as z2:
                                    # Scan all res/*.xml files (some adaptive XMLs use short names like gl.xml)
                                    xml_candidates = [n for n in z2.namelist() if n.lower().startswith('res/') and n.lower().endswith('.xml')]
                                    if xml_candidates:
                                        print(f'[APK-ICON] XML candidates scanning count={len(xml_candidates)} (showing up to 10): {xml_candidates[:10]}')
                                    for xmln in xml_candidates:
                                        try:
                                            xmlbytes = z2.read(xmln)
                                            # Some xml resources in APKs are binary XML; try to decode as utf-8, else skip
                                            try:
                                                xml_text = xmlbytes.decode('utf-8', errors='ignore')
                                            except Exception:
                                                xml_text = None
                                            if not xml_text:
                                                # try to parse as XML anyway
                                                try:
                                                    root = ET.fromstring(xmlbytes)
                                                except Exception:
                                                    continue
                                            else:
                                                try:
                                                    root = ET.fromstring(xml_text)
                                                except Exception:
                                                    # fall back to text-based regex extraction
                                                    root = None
                                        except Exception:
                                            continue
                                        fg_ref = None
                                        bg_ref = None
                                        # If we have an XML tree, scan attributes for references like @drawable/name or @mipmap/name
                                        if root is not None:
                                            for elem in root.iter():
                                                for attrname, val in list(elem.attrib.items()):
                                                    if not val or not isinstance(val, str):
                                                        continue
                                                    if val.startswith('@'):
                                                        lname = val.lower()
                                                        if 'foreground' in attrname.lower() or 'foreground' in lname:
                                                            fg_ref = val
                                                        elif 'background' in attrname.lower() or 'background' in lname:
                                                            bg_ref = val
                                                        else:
                                                            if not fg_ref:
                                                                fg_ref = val
                                        # If xml_text is available, also regex-scan for resource references as a fallback
                                        if ('xml_text' in locals()) and xml_text:
                                            import re
                                            for m in re.finditer(r"@(?:drawable|mipmap|raw)/([A-Za-z0-9_]+)", xml_text):
                                                name = m.group(1)
                                                # prefer to fill fg then bg
                                                if not fg_ref:
                                                    fg_ref = '@drawable/' + name
                                                elif not bg_ref:
                                                    bg_ref = '@drawable/' + name
                                        def resolve_ref(ref):
                                            if not ref:
                                                return None
                                            refname = ref.lstrip('@').split('/')[-1]
                                            # Search for exact filename matches first (res/.../refname.png)
                                            for p in z2.namelist():
                                                lp = p.lower()
                                                if lp.endswith(refname + '.png') or lp.endswith(refname + '.webp'):
                                                    return p
                                            # If not found, try looser match containing the name
                                            for p in z2.namelist():
                                                lp = p.lower()
                                                if refname in os.path.basename(lp):
                                                    if lp.endswith(('.png', '.webp')):
                                                        return p
                                            return None
                                        fg_path = resolve_ref(fg_ref)
                                        bg_path = resolve_ref(bg_ref)
                                        if fg_path or bg_path:
                                            print(f'[APK-ICON] adaptive xml {xmln} references fg={fg_path} bg={bg_path}')
                                            if _Image is None:
                                                print('[APK-ICON] Pillow not available; cannot compose adaptive icon, skipping')
                                            else:
                                                try:
                                                    # Load background and foreground images if available
                                                    bg_img = None
                                                    fg_img = None
                                                    if bg_path:
                                                        try:
                                                            bg_img = _Image.open(_BytesIO(z2.read(bg_path))).convert('RGBA')
                                                        except Exception:
                                                            bg_img = None
                                                    if fg_path:
                                                        try:
                                                            fg_img = _Image.open(_BytesIO(z2.read(fg_path))).convert('RGBA')
                                                        except Exception:
                                                            fg_img = None
                                                    if fg_img or bg_img:
                                                        # Ensure both images exist and are base_size x base_size
                                                        if not bg_img and fg_img:
                                                            bg_img = _Image.new('RGBA', fg_img.size, (0,0,0,0))
                                                        bg_img = bg_img.resize((base_size, base_size), _Image.LANCZOS)
                                                        if fg_img:
                                                            fg_img = fg_img.resize((base_size, base_size), _Image.LANCZOS)
                                                            bg_img.paste(fg_img, (0,0), fg_img)
                                                        outbuf = _BytesIO()
                                                        bg_img.save(outbuf, format='PNG')
                                                        png_bytes = outbuf.getvalue()
                                                        icon_pix = QPixmap()
                                                        if icon_pix.loadFromData(png_bytes):
                                                            loaded = True
                                                            print(f'[APK-ICON] Composed adaptive icon from {xmln} succeeded')
                                                            icon_pix = icon_pix.scaled(base_size*3//4, base_size*3//4, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                                                            x = (base_size - icon_pix.width()) // 2
                                                            y = (base_size - icon_pix.height()) // 2
                                                            painter_apk.drawPixmap(x, y, icon_pix)
                                                            found_adaptive = True
                                                            break
                                                except Exception as e_ad:
                                                    print(f'[APK-ICON] adaptive compose failed for {xmln}: {e_ad}')
                                        # end xmln loop
                                    if not found_adaptive:
                                        print(f'[APK-ICON] adaptive icon resolution found nothing for {full_path}')
                            except Exception as e_ad_outer:
                                print(f'[APK-ICON] adaptive icon parsing failed for {full_path}: {e_ad_outer}')
                        painter_apk.end()
                        painter.end()
                        # If no icon overlay was drawn, log that we're returning the base robot only
                        if not icon_data:
                            print(f'[APK-ICON] No overlay icon applied for {full_path}; returning base Android robot thumbnail')

                        # Cache the APK thumbnail if cache is available
                        try:
                            if getattr(self, 'thumbnail_cache', None):
                                from PyQt5.QtCore import QBuffer
                                buf = QBuffer()
                                buf.open(QBuffer.ReadWrite)
                                base_pixmap.save(buf, 'PNG')
                                png_bytes = buf.data().data()
                                self.thumbnail_cache.put(full_path, size, png_bytes)
                                thumbnail_info('[APK-ICON] Cached APK thumbnail for {} ({} bytes)', full_path, len(png_bytes))
                        except Exception as e_cache:
                            thumbnail_error('[APK-ICON] Caching APK thumbnail failed: {}', e_cache)
                        return base_pixmap
                    except Exception as e_apk:
                        print(f'[APK-ICON] APK overlay failed for {full_path}: {e_apk}')
                        # fall back to normal handling

                # Check for cached text/PDF/DOCX thumbnail
                text_exts = {'.txt', '.md', '.log', '.ini', '.csv', '.json', '.xml', '.py', '.c', '.cpp', '.h', '.java', '.js', '.html', '.css', '.qss', '.gsfmt', 'LICENSE'}
                pdf_exts = {'.pdf'}
                docx_exts = {'.docx', '.doc'}
                audio_exts = {'.wav', '.mp3', '.flac', '.ogg', '.oga', '.aac', '.m4a', '.wma', '.opus', '.aiff', '.alac'}
                filename = os.path.basename(full_path).upper()
                # Now include audio_exts in the cache lookup and drawing block
                if self.thumbnail_cache and (file_ext in text_exts or file_ext in pdf_exts or file_ext in docx_exts or file_ext in audio_exts or filename in ['LICENSE', 'LICENCE', 'COPYRIGHT', 'COPYING']):
                    thumbnail_debug('Entered text/pdf/docx/audio cache/painter block for {}', full_path)
                    cached_thumb = self.thumbnail_cache.get(full_path, size)
                    thumbnail_debug('After cache get for {}, cached_thumb type: {}', full_path, type(cached_thumb))
                    pixmap = None
                    if cached_thumb:
                        thumbnail_debug('Using cached text/pdf/docx/audio thumbnail for {}', full_path)
                        if isinstance(cached_thumb, bytes):
                            pixmap = QPixmap()
                            pixmap.loadFromData(cached_thumb, 'PNG')
                            thumbnail_debug('Loaded pixmap from bytes for {}, isNull={}', full_path, pixmap.isNull())
                        else:
                            pixmap = cached_thumb
                            thumbnail_debug('Loaded pixmap from QPixmap for {}, isNull={}', full_path, pixmap.isNull())
                    # If not cached and is a supported audio file, generate and cache on the fly
                    supported_audio_exts = ['.wav', '.flac', '.ogg', '.aiff', '.aif', '.aifc', '.au', '.snd', '.sf', '.caf', '.mp3', '.oga', '.aac', '.m4a', '.wma', '.opus', '.alac']
                    if not pixmap and file_ext in supported_audio_exts:
                        thumbnail_debug('No cached waveform for {}, generating on the fly', full_path)
                        try:
                            thumbnail_debug('Calling get_waveform_thumbnail for: {}', full_path)
                            pixmap = get_waveform_thumbnail(full_path, width=size, height=size, thumbnail_cache=self.thumbnail_cache)
                            if not pixmap.isNull():
                                # Save to cache as PNG bytes
                                from PyQt5.QtCore import QBuffer, QByteArray
                                buffer = QBuffer()
                                buffer.open(QBuffer.ReadWrite)
                                pixmap.save(buffer, 'PNG')
                                png_bytes = buffer.data().data()
                                self.thumbnail_cache.put(full_path, size, png_bytes)
                                thumbnail_debug('Cached waveform thumbnail for {} after on-the-fly gen', full_path)
                        except Exception as e:
                            thumbnail_error('Failed to generate waveform for {} in icon view: {}', full_path, e)
                    if pixmap and not pixmap.isNull() and pixmap.width() > 0 and pixmap.height() > 0:
                        painter.drawPixmap(0, 0, pixmap)
                        painter.end()
                        thumbnail_debug('Returning framed_pixmap for {} (valid cached pixmap or on-the-fly)', full_path)
                        return framed_pixmap
                    else:
                        thumbnail_debug('Cached pixmap for {} is invalid or not found, drawing default icon', full_path)
                        self.draw_default_file_icon(painter, full_path, size)
                        painter.end()
                        thumbnail_debug('Returning framed_pixmap for {} (default icon)', full_path)
                        return framed_pixmap
                if ArchiveManager.is_archive(full_path):
                    self.draw_archive_icon(painter, full_path, size)
                elif file_ext == '.exe' and not is_dir:
                    # Use real EXE icon
                    try:
                        icon = get_exe_icon_qicon(full_path, size)
                        if not icon.isNull():
                            pixmap = icon.pixmap(size, size)
                            painter.drawPixmap(0, 0, pixmap)
                        else:
                            self.draw_default_file_icon(painter, full_path, size)
                    except Exception as e:
                        thumbnail_error('[EXE-ICON] Error drawing icon for {}: {}', full_path, e)
                        self.draw_default_file_icon(painter, full_path, size)
                elif file_ext in image_extensions and self.is_safe_image_file(full_path):
                    try:
                        if file_ext == '.xcf':
                            try:
                                from PIL import Image
                                import tempfile
                                with Image.open(full_path) as img:
                                    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                                        img.save(tmp.name, 'PNG')
                                        png_path = tmp.name
                                original_pixmap = QPixmap(png_path)
                                # Optionally, clean up temp png if needed
                                # os.remove(png_path)
                            except Exception as e:
                                thumbnail_debug('XCF thumbnail error for {}: {}', full_path, e)
                                original_pixmap = QPixmap()
                        else:
                            original_pixmap = QPixmap(full_path)
                        if not original_pixmap.isNull() and original_pixmap.width() > 0 and original_pixmap.height() > 0:
                            thumbnail = original_pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            x = (size - thumbnail.width()) // 2
                            y = (size - thumbnail.height()) // 2
                            painter.drawPixmap(x, y, thumbnail)
                            pen = QPen(Qt.lightGray, 1)
                            painter.setPen(pen)
                            painter.drawRect(x, y, thumbnail.width() - 1, thumbnail.height() - 1)
                        else:
                            self.draw_default_file_icon(painter, full_path, size)
                    except Exception:
                        self.draw_default_file_icon(painter, full_path, size)
                elif file_ext in {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v'}:
                    thumbnail_debug('Entered video thumbnail code for {} (ext={})', full_path, file_ext)
                    import sys
                    if sys.platform == 'darwin':
                        # On macOS, use cache if available, else generate on demand (with robust display fallback)
                        cached_thumb = self.thumbnail_cache.get(full_path, size) if self.thumbnail_cache else None
                        if cached_thumb:
                            thumbnail_debug('Using cached video thumbnail for {}', full_path)
                            if isinstance(cached_thumb, bytes):
                                pixmap = QPixmap()
                                pixmap.loadFromData(cached_thumb, 'PNG')
                                thumbnail_debug('Loaded pixmap from bytes for {}, isNull={}', full_path, pixmap.isNull())
                            else:
                                pixmap = cached_thumb
                                thumbnail_debug('Loaded pixmap from QPixmap for {}, isNull={}', full_path, pixmap.isNull())
                            if not pixmap.isNull() and pixmap.width() > 0 and pixmap.height() > 0:
                                painter.drawPixmap(0, 0, pixmap)
                                painter.end()
                                thumbnail_debug('Returning framed_pixmap for {} (valid cached video pixmap)', full_path)
                                return framed_pixmap
                            else:
                                thumbnail_debug('Cached video pixmap for {} is invalid, drawing default icon', full_path)
                                self.draw_default_file_icon(painter, full_path, size)
                                painter.end()
                                thumbnail_debug('Returning framed_pixmap for {} (default icon)', full_path)
                                return framed_pixmap
                        # If not cached, generate on demand (like other platforms)
                        thumbnail_debug('No cached video thumbnail for {}, generating on demand', full_path)
                        try:
                            import shutil
                            ffmpeg_path = shutil.which('ffmpeg')
                            if not ffmpeg_path:
                                thumbnail_debug('ffmpeg not found in PATH for {}', full_path)
                                self.draw_default_file_icon(painter, full_path, size)
                                painter.end()
                                return framed_pixmap
                            import ffmpeg
                            from PIL import Image
                            import tempfile
                            import threading
                            import time
                            thumb_result = {'success': False, 'path': None, 'error': None}
                            def ffmpeg_thumb():
                                try:
                                    thumbnail_debug('Running ffmpeg.probe on {}', full_path)
                                    probe = ffmpeg.probe(full_path)
                                    duration = float(probe['format']['duration'])
                                    seek_time = max(duration * 0.1, 1.0)
                                    with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
                                        tmp_path = tmp.name
                                    thumbnail_debug('Extracting frame at {}s to {}', seek_time, tmp_path)
                                    (
                                        ffmpeg
                                        .input(full_path, ss=seek_time)
                                        .output(tmp_path, vframes=1, format='image2', vcodec='mjpeg')
                                        .overwrite_output()
                                        .run(quiet=True)
                                    )
                                    thumb_result['success'] = True
                                    thumb_result['path'] = tmp_path
                                except Exception as e:
                                    thumbnail_error('ffmpeg error: {}', e)
                                    thumb_result['error'] = str(e)
                            thread = threading.Thread(target=ffmpeg_thumb)
                            thread.start()
                            thread.join(timeout=5)
                            if thread.is_alive():
                                thumbnail_debug('ffmpeg thread timeout for {}', full_path)
                                thumb_result['error'] = 'timeout'
                            if thumb_result['success'] and thumb_result['path']:
                                try:
                                    thumbnail_debug('Opening image {}', thumb_result['path'])
                                    img = Image.open(thumb_result['path'])
                                    img = img.convert('RGBA').resize((size, size), Image.LANCZOS)
                                    img.save(thumb_result['path'], 'PNG')
                                    video_pixmap = QPixmap(thumb_result['path'])
                                    if video_pixmap.isNull():
                                        # Fallback: try QImage then convert to QPixmap
                                        from PyQt5.QtGui import QImage
                                        img_fallback = QImage(thumb_result['path'])
                                        if not img_fallback.isNull():
                                            video_pixmap = QPixmap.fromImage(img_fallback)
                                            thumbnail_debug('QImage fallback succeeded for {}', full_path)
                                        else:
                                            thumbnail_debug('QImage fallback also failed for {}', full_path)
                                    os.remove(thumb_result['path'])
                                    if not video_pixmap.isNull():
                                        thumbnail_debug('Successfully drew thumbnail for {}', full_path)
                                        painter.drawPixmap(0, 0, video_pixmap)
                                        # Store the generated video thumbnail in cache for future use
                                        if self.thumbnail_cache:
                                            try:
                                                self.thumbnail_cache.put(full_path, size, video_pixmap)
                                                thumbnail_debug('Stored video thumbnail in cache for {}', full_path)
                                            except Exception as cache_e:
                                                thumbnail_error('Failed to cache video thumbnail for {}: {}', full_path, cache_e)
                                    else:
                                        thumbnail_debug('QPixmap is null for {}', full_path)
                                        self.draw_default_file_icon(painter, full_path, size)
                                except Exception as e:
                                    thumbnail_error('PIL/QPixmap error: {}', e)
                                    self.draw_default_file_icon(painter, full_path, size)
                            else:
                                thumbnail_debug('Thumbnail extraction failed for {}: {}', full_path, thumb_result['error'])
                                self.draw_default_file_icon(painter, full_path, size)
                        except Exception as e:
                            thumbnail_error('Exception in macOS video thumbnail code for {}: {}', full_path, e)
                            self.draw_default_file_icon(painter, full_path, size)
                        painter.end()
                        return framed_pixmap
                    # All other platforms: use cache if available, else generate on demand
                    # ...existing code for Linux/Windows video thumbnail extraction...
                    try:
                        if sys.platform.startswith('linux'):
                            print(f'[THUMBNAIL-DEBUG] Platform is Linux, using PyAV for {full_path}')
                            try:
                                print(f'[THUMBNAIL-DEBUG] PyAV: Opening {full_path}')
                                import av
                                from PIL import Image
                                import numpy as np
                                import tempfile
                                container = av.open(full_path)
                                video_streams = [s for s in container.streams if s.type == 'video']
                                if not video_streams:
                                    print(f'[THUMBNAIL-DEBUG] PyAV: No video streams found in {full_path}')
                                    self.draw_default_file_icon(painter, full_path, size)
                                    return
                                stream = video_streams[0]
                                print(f'[THUMBNAIL-DEBUG] PyAV: Using stream {stream.index}, duration={stream.duration}, time_base={stream.time_base}')
                                seek_time = max(float(stream.duration * stream.time_base) * 0.1, 1.0) if stream.duration else 1.0
                                print(f'[THUMBNAIL-DEBUG] PyAV: Seeking to {seek_time}s')
                                container.seek(int(seek_time / stream.time_base), any_frame=False, backward=True, stream=stream)
                                frame = next(container.decode(stream), None)
                                if frame is None:
                                    print(f'[THUMBNAIL-DEBUG] PyAV: No frame decoded for {full_path}')
                                    self.draw_default_file_icon(painter, full_path, size)
                                    return
                                print(f'[THUMBNAIL-DEBUG] PyAV: Got frame for {full_path}')
                                img = frame.to_image().convert('RGBA').resize((size, size), Image.LANCZOS)
                                with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                                    img.save(tmp.name, 'PNG')
                                    video_pixmap = QPixmap(tmp.name)
                                if not video_pixmap.isNull():
                                    print(f'[THUMBNAIL-DEBUG] PyAV: Successfully drew thumbnail for {full_path}')
                                    painter.drawPixmap(0, 0, video_pixmap)
                                else:
                                    print(f'[THUMBNAIL-DEBUG] PyAV QPixmap is null for {full_path}')
                                    self.draw_default_file_icon(painter, full_path, size)
                            except Exception as e:
                                print(f'[THUMBNAIL-DEBUG] PyAV error: {e}')
                                self.draw_default_file_icon(painter, full_path, size)
                        else:
                            print(f'[THUMBNAIL-DEBUG] Platform is not Linux, using ffmpeg-python for {full_path}')
                            import shutil
                            ffmpeg_path = shutil.which('ffmpeg')
                            if not ffmpeg_path:
                                print(f'[THUMBNAIL-DEBUG] ffmpeg not found in PATH for {full_path}')
                                if 'painter' in locals() and painter is not None:
                                    self.draw_default_file_icon(painter, full_path, size)
                                # Ensure we do not proceed further to avoid segfaults
                                return
                            import ffmpeg
                            from PIL import Image
                            import tempfile
                            import threading
                            import time
                            thumb_result = {'success': False, 'path': None, 'error': None}
                            def ffmpeg_thumb():
                                try:
                                    print(f'[THUMBNAIL-DEBUG] Running ffmpeg.probe on {full_path}')
                                    probe = ffmpeg.probe(full_path)
                                    duration = float(probe['format']['duration'])
                                    seek_time = max(duration * 0.1, 1.0)
                                    with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
                                        tmp_path = tmp.name
                                    print(f'[THUMBNAIL-DEBUG] Extracting frame at {seek_time}s to {tmp_path}')
                                    (
                                        ffmpeg
                                        .input(full_path, ss=seek_time)
                                        .output(tmp_path, vframes=1, format='image2', vcodec='mjpeg')
                                        .overwrite_output()
                                        .run(quiet=True)
                                    )
                                    thumb_result['success'] = True
                                    thumb_result['path'] = tmp_path
                                except Exception as e:
                                    print(f'[THUMBNAIL-DEBUG] ffmpeg error: {e}')
                                    thumb_result['error'] = str(e)
                            thread = threading.Thread(target=ffmpeg_thumb)
                            thread.start()
                            thread.join(timeout=5)
                            if thread.is_alive():
                                print(f'[THUMBNAIL-DEBUG] ffmpeg thread timeout for {full_path}')
                                thumb_result['error'] = 'timeout'
                            if thumb_result['success'] and thumb_result['path']:
                                try:
                                    print(f'[THUMBNAIL-DEBUG] Opening image {thumb_result["path"]}')
                                    img = Image.open(thumb_result['path'])
                                    img = img.convert('RGBA').resize((size, size), Image.LANCZOS)
                                    img.save(thumb_result['path'], 'PNG')
                                    video_pixmap = QPixmap(thumb_result['path'])
                                    os.remove(thumb_result['path'])
                                    if not video_pixmap.isNull():
                                        print(f'[THUMBNAIL-DEBUG] Successfully drew thumbnail for {full_path}')
                                        painter.drawPixmap(0, 0, video_pixmap)
                                    else:
                                        print(f'[THUMBNAIL-DEBUG] QPixmap is null for {full_path}')
                                        self.draw_default_file_icon(painter, full_path, size)
                                except Exception as e:
                                    print(f'[THUMBNAIL-DEBUG] PIL/QPixmap error: {e}')
                                    self.draw_default_file_icon(painter, full_path, size)
                            else:
                                print(f'[THUMBNAIL-DEBUG] Thumbnail extraction failed for {full_path}: {thumb_result["error"]}')
                                self.draw_default_file_icon(painter, full_path, size)
                    except Exception as e:
                        print(f'[THUMBNAIL-DEBUG] Exception in thumbnail code for {full_path}: {e}')
                        self.draw_default_file_icon(painter, full_path, size)
                else:
                    self.draw_default_file_icon(painter, full_path, size)
        except Exception:
            self.draw_generic_file_icon(painter, size, is_dir)
        painter.end()
        # Only cache generic icons for file types that are not text, PDF, DOCX, or audio
        text_exts = {'.txt', '.md', '.log', '.ini', '.csv', '.json', '.xml', '.py', '.c', '.cpp', '.h', '.java', '.js', '.html', '.css', '.qss', '.gsfmt', 'LICENSE'}
        pdf_exts = {'.pdf'}
        docx_exts = {'.docx', '.doc'}
        audio_exts = {'.wav', '.mp3', '.flac', '.ogg', '.oga', '.aac', '.m4a', '.wma', '.opus', '.aiff', '.alac'}
        file_ext = os.path.splitext(full_path)[1].lower()
        filename = os.path.basename(full_path).upper()
        if self.thumbnail_cache and not is_dir and file_ext not in text_exts | pdf_exts | docx_exts | audio_exts and filename not in ['LICENSE', 'LICENCE', 'COPYRIGHT', 'COPYING']:
            self.thumbnail_cache.put(full_path, size, framed_pixmap)
        return framed_pixmap

    def is_safe_image_file(self, file_path):
        """Check if the file is safe to load as an image on the current platform"""
        try:
            # Check file size - avoid very large files that could cause memory issues
            if os.path.getsize(file_path) > 50 * 1024 * 1024:  # 50MB limit
                return False
            
            # Platform-specific safety checks
            if PlatformUtils.is_macos():
                # Skip files with resource forks or other macOS-specific attributes
                filename = os.path.basename(file_path)
                if (filename.startswith('._') or  # Resource forks
                    filename == '.DS_Store' or    # Finder metadata
                    filename == '.localized' or   # Localization files
                    filename.startswith('.fseventsd') or  # File system events
                    filename.startswith('.Spotlight-') or  # Spotlight index
                    filename.startswith('.Trashes') or     # Trash metadata
                    filename == '.com.apple.timemachine.donotpresent' or  # Time Machine
                    filename.endswith('.apdisk')):  # AirPort Disk metadata
                    return False
                
                # Check if file is readable
                if not os.access(file_path, os.R_OK):
                    return False
            elif PlatformUtils.is_windows():
                # Windows-specific checks
                # Skip system files and thumbnails
                filename = os.path.basename(file_path).lower()
                if filename in ('thumbs.db', 'desktop.ini'):
                    return False
            else:  # Linux/Unix
                # Unix-specific checks
                if not os.access(file_path, os.R_OK):
                    return False
            
            return True
        except Exception:
            return False

    def draw_default_file_icon(self, painter, full_path, size):
        """Draw only the default system file icon, with no overlays or Windows logo, for all drives and files."""
        try:
            if PlatformUtils.is_windows():
                icon_provider = QFileIconProvider()
                file_info = QFileInfo(full_path)
                icon = icon_provider.icon(file_info)
                preferred_sizes = [256, 128, 64, 48, 32, 16]
                best_pixmap = None
                for icon_size in preferred_sizes:
                    file_pixmap = icon.pixmap(icon_size, icon_size)
                    if not file_pixmap.isNull() and file_pixmap.width() > 0 and file_pixmap.height() > 0:
                        best_pixmap = file_pixmap
                        break
                if best_pixmap:
                    if best_pixmap.width() != size or best_pixmap.height() != size:
                        best_pixmap = best_pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    x = (size - best_pixmap.width()) // 2
                    y = (size - best_pixmap.height()) // 2
                    painter.drawPixmap(x, y, best_pixmap)
                    return
            else:
                icon_provider = QFileIconProvider()
                icon = icon_provider.icon(QFileInfo(full_path))
                if not icon.isNull():
                    preferred_sizes = [size * 2, size, 128, 64, 48, 32, 16]
                    for icon_size in preferred_sizes:
                        file_pixmap = icon.pixmap(icon_size, icon_size)
                        if not file_pixmap.isNull() and file_pixmap.width() > 0 and file_pixmap.height() > 0:
                            if file_pixmap.width() != size or file_pixmap.height() != size:
                                file_pixmap = file_pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            x = (size - file_pixmap.width()) // 2
                            y = (size - file_pixmap.height()) // 2
                            painter.drawPixmap(x, y, file_pixmap)
                            return
        except Exception as e:
            print(f"Error getting system icon for {full_path}: {e}")
        self.draw_generic_file_icon(painter, size, False)
    
    def try_windows_icon_extraction(self, painter, full_path, size):
        """Try to extract Windows shell icons using various methods"""
        if not PlatformUtils.is_windows():
            return False
        
        try:
            # Method 1: Try using file extension-based icon lookup
            import os.path
            file_ext = os.path.splitext(full_path)[1].lower()
            
            if file_ext:
                try:
                    # Get the icon based on file extension with better size handling
                    icon_provider = QFileIconProvider()
                    
                    # Create a temporary file info with the same extension
                    temp_info = QFileInfo(f"temp{file_ext}")
                    type_icon = icon_provider.icon(temp_info)
                    
                    if not type_icon.isNull():
                        # Try multiple sizes to get the best quality
                        preferred_sizes = [256, 128, 64, 48, 32, 16]
                        best_pixmap = None
                        
                        for icon_size in preferred_sizes:
                            icon_pixmap = type_icon.pixmap(icon_size, icon_size)
                            if not icon_pixmap.isNull() and icon_pixmap.width() > 0:
                                best_pixmap = icon_pixmap
                                break
                        
                        if best_pixmap:
                            # Always scale to the exact requested size
                            if best_pixmap.width() != size or best_pixmap.height() != size:
                                best_pixmap = best_pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            
                            x = (size - best_pixmap.width()) // 2
                            y = (size - best_pixmap.height()) // 2
                            painter.drawPixmap(x, y, best_pixmap)
                            return True
                except Exception as e:
                    print(f"Extension-based icon extraction failed for {file_ext}: {e}")
            
            # Method 2: Try using Windows registry/system associations
            try:
                # Alternative approach: try to get system icon through different means
                icon_provider = QFileIconProvider()
                
                # Try getting icon for the actual file if it exists
                if os.path.exists(full_path):
                    file_info = QFileInfo(full_path)
                    system_icon = icon_provider.icon(file_info)
                    
                    if not system_icon.isNull():
                        # Use the same multi-size approach
                        preferred_sizes = [256, 128, 64, 48, 32, 16]
                        
                        for icon_size in preferred_sizes:
                            sys_pixmap = system_icon.pixmap(icon_size, icon_size)
                            if not sys_pixmap.isNull() and sys_pixmap.width() > 0:
                                # Scale to exact requested size
                                if sys_pixmap.width() != size or sys_pixmap.height() != size:
                                    sys_pixmap = sys_pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                                
                                x = (size - sys_pixmap.width()) // 2
                                y = (size - sys_pixmap.height()) // 2
                                painter.drawPixmap(x, y, sys_pixmap)
                                return True
            except Exception as e:
                print(f"System icon extraction failed: {e}")
            
            return False
            
        except Exception as e:
            print(f"Windows icon extraction failed: {e}")
            return False
    
    def draw_archive_icon(self, painter, archive_path, size):
        """Draw a custom icon for archive files"""
        try:
            # Backwards-compatible: allow callers to force the enhanced/custom archive
            # rendering (useful for thumbnail mode where we prefer richer ISO thumbnails)
            force_custom = False
            try:
                # If caller passed a 4th arg, it'll be available in locals(); tolerate absence
                force_custom = locals().get('force_custom', False)
            except Exception:
                force_custom = False
            archive_type = ArchiveManager.get_archive_type(archive_path)
            if force_custom and archive_type == '.iso':
                try:
                    self.draw_custom_archive_icon(painter, archive_path, size)
                    return
                except Exception:
                    # Fall through to normal handling on error
                    pass
            # Try to get system icon first
            icon_provider = QFileIconProvider()
            file_info = QFileInfo(archive_path)
            icon = icon_provider.icon(file_info)
            
            if not icon.isNull():
                file_pixmap = icon.pixmap(size, size)
                if not file_pixmap.isNull():
                    painter.drawPixmap(0, 0, file_pixmap)
                    # Only add archive overlay if not a drive root (e.g., not C:/)
                    import os
                    # Heuristic: skip overlay for drive roots
                    if not (os.name == 'nt' and len(archive_path) >= 2 and archive_path[1] == ':' and (archive_path.endswith('/') or archive_path.endswith('\\')) and os.path.ismount(archive_path)):
                        self.draw_archive_overlay(painter, size)
                    return
            
            # Fallback: draw custom archive icon
            self.draw_custom_archive_icon(painter, archive_path, size)
            
        except Exception:
            # Ultimate fallback
            self.draw_custom_archive_icon(painter, archive_path, size)
    
    def draw_archive_overlay(self, painter, size):
        """Draw a small overlay to indicate this is an archive"""
        overlay_size = size // 4
        x = size - overlay_size - 2
        y = size - overlay_size - 2
        
        # Draw small archive symbol (like a box with lines)
        painter.setPen(QPen(Qt.darkBlue, 2))
        painter.setBrush(Qt.lightGray)
        painter.drawRect(x, y, overlay_size, overlay_size)
        
        # Draw horizontal lines to represent files
        line_y = y + overlay_size // 4
        for i in range(3):
            painter.drawLine(x + 2, line_y, x + overlay_size - 2, line_y)
            line_y += overlay_size // 4
    
    def draw_custom_archive_icon(self, painter, archive_path, size):
        """Draw a custom archive icon when system icon is not available"""
        archive_type = ArchiveManager.get_archive_type(archive_path)
        
        # Set colors based on archive type
        if archive_type == '.zip':
            fill_color = QColor(255, 215, 0)  # Gold
            border_color = QColor(184, 134, 11)  # Dark gold
        elif archive_type in ['.tar', '.tar.gz', '.tgz']:
            fill_color = QColor(139, 69, 19)  # Saddle brown
            border_color = QColor(101, 51, 14)  # Dark brown
        elif archive_type == '.rar':
            fill_color = QColor(128, 0, 128)  # Purple
            border_color = QColor(75, 0, 130)  # Indigo
        elif archive_type == '.iso':
            # Try to extract EXE icon from ISO for thumbnail
            # First, check if the ISO contains any EXE candidates so we can decide
            # whether to show a default EXE icon when extraction fails.
            had_exe = False
            try:
                s, entries_or_err = ArchiveManager.list_archive_contents(archive_path)
                if s:
                    exe_candidates = [e for e in entries_or_err if (not e.get('is_dir')) and e['name'].lower().endswith('.exe')]
                    if exe_candidates:
                        had_exe = True
            except Exception:
                had_exe = False

            # Prefer to find an image (png/jpg) inside the ISO to overlay on the disc
            img_pix = None
            try:
                cache = get_global_thumbnail_cache()
                # Look for image entries inside the ISO listing
                success, entries_or_err = ArchiveManager.list_archive_contents(archive_path)
                image_entry = None
                if success and entries_or_err:
                    # Improved selection heuristics:
                    # - prefer names containing 'cover' or 'front' or 'folder'
                    # - prefer shallower (root-level) paths
                    # - prefer larger file size when available
                    IMAGE_EXTS = ('.png', '.jpg', '.jpeg', '.webp', '.bmp', '.gif')
                    candidates = []
                    for ent in entries_or_err:
                        if ent.get('is_dir'):
                            continue
                        ext = os.path.splitext(ent['name'])[1].lower()
                        if ext in IMAGE_EXTS:
                            candidates.append(ent)
                    if candidates:
                        def _score(ent):
                            name = (ent.get('name') or '').lower()
                            # base score from presence of desirable keywords
                            score = 0
                            if 'cover' in name or 'front' in name or 'folder' in name:
                                score += 2000
                            # prefer root-level (fewer '/')
                            depth = name.count('/')
                            score += max(0, 500 - depth * 50)
                            # prefer larger sizes (if available)
                            try:
                                sz = int(ent.get('size') or 0)
                            except Exception:
                                sz = 0
                            # scale size contribution modestly
                            score += min(sz, 5_000_000) // 1024
                            return score

                        best = max(candidates, key=_score)
                        image_entry = best['name']
                if image_entry:
                    # Prepare cache key based on ISO path + entry + size
                    cache_key_path = f"{archive_path}::{image_entry}"
                    if cache and cache.is_cached(cache_key_path, size):
                        img_pix = cache.get(cache_key_path, size)
                    else:
                        # Extract the image to a temp file then load and cache it
                        import tempfile
                        import pycdlib
                        iso = pycdlib.PyCdlib()
                        try:
                            iso.open(archive_path)
                            tmpf = tempfile.NamedTemporaryFile(delete=False, suffix=os.path.splitext(image_entry)[1])
                            tmpf.close()
                            extracted = False
                            # Build a set of candidate paths for pycdlib to try. pycdlib
                            # can require different forms (leading slash, uppercase,
                            # or ISO version suffix like ';1'), so try variants.
                            candidates = []
                            base = image_entry
                            candidates.append(base)
                            candidates.append(base.lstrip('/'))
                            candidates.append(base.lstrip('/').upper())
                            # Add ';1' version on final segment (with/without leading slash)
                            try:
                                stripped = base.lstrip('/')
                                parts = stripped.split('/')
                                parts_semiv = parts[:-1] + [parts[-1] + ';1']
                                candidates.append('/' + '/'.join(parts_semiv))
                                candidates.append('/' + '/'.join(parts_semiv).upper())
                                candidates.append('/'.join(parts_semiv))
                                candidates.append('/'.join(parts_semiv).upper())
                            except Exception:
                                pass

                            for kw in ('iso_path', 'joliet_path', 'rr_path'):
                                for candidate in candidates:
                                    try:
                                        with open(tmpf.name, 'wb') as out_f:
                                            iso.get_file_from_iso_fp(out_f, **{kw: candidate})
                                        extracted = True
                                        break
                                    except Exception as ex_get:
                                        # If we get a pycdlib parsing error, continue trying
                                        # other candidate forms/namespace keywords.
                                        msg = str(ex_get).lower()
                                        # If the error looks fatal for this candidate, continue
                                        try:
                                            if os.path.exists(tmpf.name):
                                                os.remove(tmpf.name)
                                        except Exception:
                                            pass
                                        continue
                                if extracted:
                                    break
                            iso.close()
                            if extracted and os.path.exists(tmpf.name):
                                try:
                                    from PIL import Image
                                except Exception:
                                    Image = None
                                if Image is None:
                                    img_pix = None
                                else:
                                    img = Image.open(tmpf.name).convert('RGBA')
                                    img = img.resize((size, size), Image.LANCZOS)
                                    # Save to a cache temp PNG and load into QPixmap
                                    cache_tmp = tempfile.NamedTemporaryFile(delete=False, suffix='.png')
                                    img.save(cache_tmp.name, 'PNG')
                                    cache_tmp.close()
                                    img_pix = QPixmap(cache_tmp.name)
                                    try:
                                        os.remove(cache_tmp.name)
                                    except Exception:
                                        pass
                                    try:
                                        os.remove(tmpf.name)
                                    except Exception:
                                        pass
                                    if cache and img_pix and not img_pix.isNull():
                                        try:
                                            cache.put(cache_key_path, size, img_pix)
                                        except Exception:
                                            pass
                        except Exception:
                            try:
                                iso.close()
                            except Exception:
                                pass
                            img_pix = None
            except Exception:
                img_pix = None

            # If we obtained an image pixmap, draw disc then overlay
            if img_pix and not getattr(img_pix, 'isNull', lambda: False)():
                try:
                    from PyQt5.QtGui import QRadialGradient
                    center = QPoint(size // 2, size // 2)
                    radius = size // 2 - 4
                    grad = QRadialGradient(center, radius)
                    grad.setColorAt(0.0, QColor(230, 230, 230))
                    grad.setColorAt(0.6, QColor(200, 200, 220))
                    grad.setColorAt(1.0, QColor(160, 160, 200))
                    painter.setBrush(grad)
                    painter.setPen(QPen(QColor(90, 90, 120), 2))
                    painter.drawEllipse(center, radius, radius)
                    # Overlay the image centered with padding
                    padding = max(4, size // 10)
                    target = QRect(padding, padding, size - padding * 2, size - padding * 2)
                    painter.drawPixmap(target, img_pix)
                    return
                except Exception:
                    pass

            # If we didn't find an image inside the ISO, try EXE icon extraction as fallback
            try:
                pixmap = ArchiveManager.extract_exe_icon_from_iso(archive_path, size=size)
                if pixmap and not pixmap.isNull():
                    painter.drawPixmap(0, 0, pixmap)
                    return
            except Exception:
                pass

            # If no image was used, and an EXE exists, draw a default EXE icon
            if had_exe:
                try:
                    default_pix = QPixmap(size, size)
                    default_pix.fill(Qt.transparent)
                    p2 = QPainter(default_pix)
                    p2.setRenderHint(QPainter.Antialiasing)
                    # Background box
                    p2.setBrush(QColor(240, 240, 240))
                    p2.setPen(QPen(QColor(60, 60, 60), 2))
                    rect = QRect(4, 4, size - 8, size - 8)
                    p2.drawRoundedRect(rect, 6, 6)
                    # EXE label
                    font = p2.font()
                    font.setBold(True)
                    font.setPointSize(max(8, size // 6))
                    p2.setFont(font)
                    p2.setPen(QColor(30, 30, 30))
                    p2.drawText(rect, Qt.AlignCenter, 'EXE')
                    p2.end()
                    painter.drawPixmap(0, 0, default_pix)
                    return
                except Exception:
                    # If even this fails, continue to disc fallback
                    pass
            # (Duplicate image-extraction block removed: images are attempted above first.)
            # Fallback: draw disc-style icon
            try:
                from PyQt5.QtGui import QRadialGradient
                center = QPoint(size // 2, size // 2)
                radius = size // 2 - 4
                grad = QRadialGradient(center, radius)
                grad.setColorAt(0.0, QColor(230, 230, 230))
                grad.setColorAt(0.6, QColor(200, 200, 220))
                grad.setColorAt(1.0, QColor(160, 160, 200))
                painter.setBrush(grad)
                painter.setPen(QPen(QColor(90, 90, 120), 2))
                painter.drawEllipse(center, radius, radius)
                # Inner shiny ring
                inner_radius = max(6, size // 6)
                painter.setBrush(QColor(240, 240, 255, 200))
                painter.setPen(QPen(QColor(120, 120, 140), 1))
                painter.drawEllipse(center, inner_radius, inner_radius)
                # Small central hole
                hole_radius = max(3, size // 14)
                painter.setBrush(QColor(20, 20, 20))
                painter.drawEllipse(center, hole_radius, hole_radius)
                # Draw 'ISO' label at bottom
                font = painter.font()
                font.setPointSize(max(6, size // 10))
                font.setBold(True)
                painter.setFont(font)
                painter.setPen(QColor(40, 40, 60))
                painter.drawText(QRect(0, size - size//4, size, size//4), Qt.AlignCenter, 'ISO')
                return
            except Exception:
                # Fallback to generic archive rendering below
                fill_color = QColor(169, 169, 169)  # Dark gray
                border_color = QColor(105, 105, 105)  # Dim gray
        else:
            fill_color = QColor(169, 169, 169)  # Dark gray
            border_color = QColor(105, 105, 105)  # Dim gray
        
        # Draw main archive box
        margin = size // 8
        box_rect = QRect(margin, margin, size - 2 * margin, size - 2 * margin)
        
        painter.setBrush(fill_color)
        painter.setPen(QPen(border_color, 2))
        painter.drawRoundedRect(box_rect, 4, 4)
        
        # Draw "zip" lines pattern
        painter.setPen(QPen(border_color, 1))
        line_spacing = size // 6
        start_y = margin + line_spacing
        
        for i in range(3):
            y = start_y + i * line_spacing
            if y < size - margin:
                painter.drawLine(margin + 4, y, size - margin - 4, y)
        
        # Draw file type label
        if archive_type:
            label = archive_type[1:].upper()  # Remove the dot
            painter.setPen(Qt.white)
            font = painter.font()
            font.setPointSize(max(6, size // 10))
            font.setBold(True)
            painter.setFont(font)
            
            text_rect = QRect(margin, size - margin - size//4, size - 2*margin, size//4)
            painter.drawText(text_rect, Qt.AlignCenter, label)

    def draw_generic_file_icon(self, painter, size, is_dir):
        """Draw a simple generic icon when system icons fail"""
        try:
            # Set colors based on current theme
            if self.dark_mode:
                border_color = Qt.white
                fill_color = Qt.darkGray
            else:
                border_color = Qt.black
                fill_color = Qt.lightGray
            
            pen = QPen(border_color, 2)
            painter.setPen(pen)
            painter.setBrush(fill_color)
            
            if is_dir:
                # Draw a simple folder shape
                rect_height = size * 0.6
                rect_width = size * 0.8
                x = (size - rect_width) // 2
                y = (size - rect_height) // 2 + size * 0.1
                
                # Draw folder tab
                tab_width = rect_width * 0.3
                tab_height = rect_height * 0.2
                painter.drawRect(int(x), int(y - tab_height), int(tab_width), int(tab_height))
                
                # Draw folder body
                painter.drawRect(int(x), int(y), int(rect_width), int(rect_height))
            else:
                # Draw a simple file shape
                rect_height = size * 0.7
                rect_width = size * 0.6
                x = (size - rect_width) // 2
                y = (size - rect_height) // 2
                
                # Draw file rectangle
                painter.drawRect(int(x), int(y), int(rect_width), int(rect_height))
                
                # Draw corner fold
                fold_size = rect_width * 0.2
                painter.drawLine(int(x + rect_width - fold_size), int(y),
                               int(x + rect_width), int(y + fold_size))
        except Exception:
            # Ultimate fallback: just draw a simple rectangle
            painter.setPen(QPen(Qt.gray, 1))
            painter.drawRect(size//4, size//4, size//2, size//2)

    def create_folder_preview(self, folder_path, size):
        """Create a folder icon with preview thumbnails of images inside"""
        preview_pixmap = QPixmap(size, size)
        preview_pixmap.fill(Qt.transparent)
        
        painter = QPainter(preview_pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Start with the default folder icon as background
        try:
            icon_provider = QFileIconProvider()
            
            if PlatformUtils.is_windows():
                # On Windows, try to get the actual folder icon for the specific path
                try:
                    folder_info = QFileInfo(folder_path)
                    folder_icon = icon_provider.icon(folder_info)
                except:
                    folder_icon = icon_provider.icon(QFileIconProvider.Folder)
            else:
                folder_icon = icon_provider.icon(QFileIconProvider.Folder)
            
            if not folder_icon.isNull():
                # Try different sizes for better quality at all thumbnail sizes
                preferred_sizes = [256, 128, 64, 48, 32, 16]
                folder_pixmap = None
                
                for icon_size in preferred_sizes:
                    temp_pixmap = folder_icon.pixmap(icon_size, icon_size)
                    if not temp_pixmap.isNull() and temp_pixmap.width() > 0 and temp_pixmap.height() > 0:
                        folder_pixmap = temp_pixmap
                        break
                
                if folder_pixmap:
                    # Always scale to the exact requested size for consistency
                    if folder_pixmap.width() != size or folder_pixmap.height() != size:
                        folder_pixmap = folder_pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    
                    # Center and draw the folder icon
                    x = (size - folder_pixmap.width()) // 2
                    y = (size - folder_pixmap.height()) // 2
                    painter.drawPixmap(x, y, folder_pixmap)
                else:
                    # Draw generic folder if system icon fails
                    self.draw_generic_file_icon(painter, size, True)
            else:
                self.draw_generic_file_icon(painter, size, True)
        except Exception as e:
            print(f"Error getting folder icon for {folder_path}: {e}")
            self.draw_generic_file_icon(painter, size, True)
        
        # Try to find previewable files in the folder (image, video, exe)
        try:
            # Supported extensions for previews
            image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp', '.ico'}
            video_extensions = {'.mp4', '.avi', '.mov', '.mkv', '.webm', '.wmv', '.flv', '.mpg', '.mpeg', '.3gp'}
            audio_extensions = {'.wav', '.mp3', '.flac', '.ogg', '.oga', '.aac', '.m4a', '.wma', '.opus', '.aiff', '.alac'}
            pdf_extensions = {'.pdf'}
            text_extensions = {'.txt', '.md', '.log', '.ini', '.csv', '.json', '.xml', '.py', '.c', '.cpp', '.h', '.java', '.js', '.html', '.css', '.qss', '.gsfmt', 'LICENSE'}
            docx_extensions = {'.docx', '.doc'}
            exe_extensions = {'.exe'}
            preview_files = []
            files = os.listdir(folder_path)
            # Platform-specific file filtering
            if PlatformUtils.is_macos():
                files = [f for f in files if not f.startswith('.') and not f.startswith('._')]
            elif PlatformUtils.is_windows():
                files = [f for f in files if f.lower() not in ('thumbs.db', 'desktop.ini')]
            else:  # Linux/Unix
                files = [f for f in files if not f.startswith('.')]
            # Limit the number of files scanned for previews to the first 20 for performance
            files = files[:20]
            only_folders = True
            only_isos = True
            only_archives = True
            folder_paths = []
            iso_paths = []
            archive_paths = []
            for file_name in files:
                file_ext = os.path.splitext(file_name)[1].lower()
                file_path = os.path.join(folder_path, file_name)
                if os.path.isfile(file_path):
                    only_folders = False
                    if file_ext == '.iso':
                        iso_paths.append(file_path)
                        # Add ISO as a preview type (after other thumbnails)
                        preview_files.append(('iso', file_path))
                    else:
                        only_isos = False
                    if file_ext in {'.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz', '.tgz', '.tbz2', '.lz', '.lzma', '.z', '.cab', '.arj', '.ace', '.jar'}:
                        archive_paths.append(file_path)
                        preview_files.append(('archive', file_path))
                    else:
                        only_archives = False
                    if file_ext in image_extensions and self.is_safe_image_file(file_path):
                        preview_files.append(('image', file_path))
                    elif file_ext in video_extensions:
                        preview_files.append(('video', file_path))
                    elif file_ext in audio_extensions:
                        preview_files.append(('audio', file_path))
                    elif file_ext in pdf_extensions:
                        preview_files.append(('pdf', file_path))
                    elif file_ext in text_extensions or os.path.basename(file_path).upper() in ['LICENSE', 'LICENCE', 'COPYRIGHT', 'COPYING']:
                        preview_files.append(('text', file_path))
                    elif file_ext in docx_extensions:
                        preview_files.append(('docx', file_path))
                    elif file_ext in exe_extensions:
                        preview_files.append(('exe', file_path))
                elif os.path.isdir(file_path):
                    only_isos = False
                    only_archives = False
                    folder_paths.append(file_path)
            if only_archives and archive_paths:
                # Composite up to 4 small archive icons
                preview_size = max(8, size // 4)
                positions = [
                    (size - preview_size - 2, 2),
                    (size - preview_size - 2, preview_size + 4),
                    (size - preview_size * 2 - 4, 2),
                    (size - preview_size * 2 - 4, preview_size + 4)
                ]
                icon_provider = QFileIconProvider()
                for i, archive in enumerate(archive_paths[:4]):
                    archive_icon = icon_provider.icon(QFileInfo(archive))
                    if archive_icon.isNull():
                        archive_icon = icon_provider.icon(QFileIconProvider.File)
                    archive_pixmap = archive_icon.pixmap(preview_size, preview_size)
                    pos_x, pos_y = positions[i]
                    painter.drawPixmap(pos_x, pos_y, archive_pixmap)
            elif only_isos and iso_paths:
                # Composite up to 4 small ISO icons
                preview_size = max(8, size // 4)
                positions = [
                    (size - preview_size - 2, 2),
                    (size - preview_size - 2, preview_size + 4),
                    (size - preview_size * 2 - 4, 2),
                    (size - preview_size * 2 - 4, preview_size + 4)
                ]
                # Use a generic CD/DVD icon for ISO, or fallback to exe icon if not available
                icon_provider = QFileIconProvider()
                for i, iso in enumerate(iso_paths[:4]):
                    iso_icon = icon_provider.icon(QFileInfo(iso))
                    if iso_icon.isNull():
                        iso_icon = icon_provider.icon(QFileIconProvider.File)
                    iso_pixmap = iso_icon.pixmap(preview_size, preview_size)
                    pos_x, pos_y = positions[i]
                    painter.drawPixmap(pos_x, pos_y, iso_pixmap)
            elif only_folders and folder_paths:
                # Composite up to 4 small folder icons
                preview_size = max(8, size // 4)
                positions = [
                    (size - preview_size - 2, 2),
                    (size - preview_size - 2, preview_size + 4),
                    (size - preview_size * 2 - 4, 2),
                    (size - preview_size * 2 - 4, preview_size + 4)
                ]
                icon_provider = QFileIconProvider()
                for i, subfolder in enumerate(folder_paths[:4]):
                    try:
                        folder_icon = icon_provider.icon(QFileIconProvider.Folder)
                        folder_pixmap = folder_icon.pixmap(preview_size, preview_size)
                        pos_x, pos_y = positions[i]
                        painter.drawPixmap(pos_x, pos_y, folder_pixmap)
                    except Exception:
                        continue
            elif preview_files:
                preview_size = max(8, size // 4)
                positions = [
                    (size - preview_size - 2, 2),
                    (size - preview_size - 2, preview_size + 4),
                    (size - preview_size * 2 - 4, 2),
                    (size - preview_size * 2 - 4, preview_size + 4)
                ]
                # Compose up to 4: prefer thumbnails, fill with icons if needed
                composited = 0
                used_files = set()
                # 1. Try to composite all available thumbnails first
                for ftype, fpath in preview_files:
                    if composited >= 4:
                        break
                    try:
                        thumbnail = None
                        if ftype == 'image':
                            img_pixmap = QPixmap(fpath)
                            if not img_pixmap.isNull() and img_pixmap.width() > 0 and img_pixmap.height() > 0:
                                thumbnail = img_pixmap.scaled(preview_size, preview_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                        elif ftype == 'video':
                            thumb = None
                            if hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                                thumb = self.thumbnail_cache.get(fpath, preview_size)
                            if not thumb:
                                try:
                                    from PyQt5.QtMultimedia import QMediaPlayer, QVideoWidget
                                except Exception:
                                    pass
                            if thumb:
                                if isinstance(thumb, (bytes, bytearray)):
                                    img_pixmap = QPixmap()
                                    img_pixmap.loadFromData(thumb, 'PNG')
                                    if not img_pixmap.isNull():
                                        thumbnail = img_pixmap.scaled(preview_size, preview_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                                elif isinstance(thumb, QPixmap):
                                    thumbnail = thumb.scaled(preview_size, preview_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            if thumbnail is None:
                                thumbnail = self.create_icon_or_thumbnail(fpath, False)
                        elif ftype == 'audio':
                            thumb = None
                            if hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                                thumb = self.thumbnail_cache.get(fpath, preview_size)
                            if not thumb:
                                try:
                                    thumbnail = get_waveform_thumbnail(fpath, width=preview_size, height=preview_size)
                                except Exception:
                                    thumbnail = None
                            if thumb and thumbnail is None:
                                if isinstance(thumb, (bytes, bytearray)):
                                    img_pixmap = QPixmap()
                                    img_pixmap.loadFromData(thumb, 'PNG')
                                    if not img_pixmap.isNull():
                                        thumbnail = img_pixmap.scaled(preview_size, preview_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                                elif isinstance(thumb, QPixmap):
                                    thumbnail = thumb.scaled(preview_size, preview_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            if thumbnail is None:
                                thumbnail = self.create_icon_or_thumbnail(fpath, False)
                        elif ftype == 'pdf' or ftype == 'text' or ftype == 'docx':
                            thumb = None
                            if hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                                thumb = self.thumbnail_cache.get(fpath, preview_size)
                            if not thumb:
                                try:
                                    thumbnail = self.create_icon_or_thumbnail(fpath, False)
                                except Exception:
                                    thumbnail = None
                            if thumb and thumbnail is None:
                                if isinstance(thumb, (bytes, bytearray)):
                                    img_pixmap = QPixmap()
                                    img_pixmap.loadFromData(thumb, 'PNG')
                                    if not img_pixmap.isNull():
                                        thumbnail = img_pixmap.scaled(preview_size, preview_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                                elif isinstance(thumb, QPixmap):
                                    thumbnail = thumb.scaled(preview_size, preview_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            if thumbnail is None:
                                thumbnail = self.create_icon_or_thumbnail(fpath, False)
                        elif ftype == 'exe':
                            icon = get_exe_icon_qicon(fpath, size=preview_size)
                            thumbnail = icon.pixmap(preview_size, preview_size)
                        elif ftype == 'archive':
                            # Use the file type icon for the archive as a thumbnail
                            icon = icon_provider.icon(QFileInfo(fpath))
                            if icon.isNull():
                                icon = icon_provider.icon(QFileIconProvider.File)
                            thumbnail = icon.pixmap(preview_size, preview_size)
                        elif ftype == 'iso':
                            # Try to extract EXE icon from ISO for thumbnail
                            try:
                                thumbnail = ArchiveManager.extract_exe_icon_from_iso(fpath, size=preview_size)
                            except Exception:
                                thumbnail = None
                            if not thumbnail or thumbnail.isNull():
                                icon = icon_provider.icon(QFileInfo(fpath))
                                if icon.isNull():
                                    icon = icon_provider.icon(QFileIconProvider.File)
                                thumbnail = icon.pixmap(preview_size, preview_size)
                        else:
                            continue
                        if thumbnail is not None:
                            preview_frame = QPixmap(preview_size, preview_size)
                            preview_frame.fill(Qt.white)
                            frame_painter = QPainter(preview_frame)
                            frame_painter.setRenderHint(QPainter.Antialiasing)
                            thumb_x = (preview_size - thumbnail.width()) // 2
                            thumb_y = (preview_size - thumbnail.height()) // 2
                            frame_painter.drawPixmap(thumb_x, thumb_y, thumbnail)
                            pen = QPen(Qt.darkGray, 1)
                            frame_painter.setPen(pen)
                            frame_painter.drawRect(0, 0, preview_size - 1, preview_size - 1)
                            frame_painter.end()
                            pos_x, pos_y = positions[composited]
                            painter.drawPixmap(pos_x, pos_y, preview_frame)
                            used_files.add(fpath)
                            composited += 1
                    except Exception:
                        continue
                # 2. Fill remaining slots with icons for other files
                if composited < 4:
                    for file_name in files:
                        if composited >= 4:
                            break
                        file_path = os.path.join(folder_path, file_name)
                        if os.path.isfile(file_path) and file_path not in used_files:
                            icon = icon_provider.icon(QFileInfo(file_path))
                            if icon.isNull():
                                icon = icon_provider.icon(QFileIconProvider.File)
                            icon_pixmap = icon.pixmap(preview_size, preview_size)
                            pos_x, pos_y = positions[composited]
                            painter.drawPixmap(pos_x, pos_y, icon_pixmap)
                            composited += 1
        except Exception:
            pass
        
        painter.end()
        return preview_pixmap

    def mousePressEvent(self, event):
        try:
            icon_container_debug('mousePressEvent button={} pos={} global={} modifiers={}', getattr(event, 'button', lambda: None)(), getattr(event, 'pos', lambda: '<no-pos>')(), getattr(event, 'globalPos', lambda: '<no-global>')(), getattr(event, 'modifiers', lambda: 0)())
        except Exception:
            pass
        if event.button() == Qt.LeftButton:
            self.clicked.emit(self.full_path, event.modifiers())
        elif event.button() == Qt.RightButton:
            self.rightClicked.emit(self.full_path, event.globalPos())

    def mouseDoubleClickEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.doubleClicked.emit(self.full_path)
            event.accept()  # Explicitly accept to prevent propagation issues on Linux

    def mousePressEvent(self, event):
        # Record position for potential drag start and emit click signals
        if event.button() == Qt.LeftButton:
            self._press_pos = event.pos()
            self._press_global_pos = event.globalPos()
            # Emit clicked signal for single-click handling
            self.clicked.emit(self.full_path, event.modifiers())
            event.accept()
            return
        elif event.button() == Qt.RightButton:
            self.rightClicked.emit(self.full_path, event.globalPos())
            event.accept()
            return
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        # Start drag if moved beyond threshold
        try:
            from PyQt5.QtCore import QUrl, QMimeData
            from PyQt5.QtWidgets import QApplication
            from PyQt5.QtGui import QDrag
        except Exception:
            # If imports fail for any reason, fall back to default handling
            super().mouseMoveEvent(event)
            return

        if hasattr(self, '_press_pos') and event.buttons() & Qt.LeftButton:
            dist = (event.pos() - self._press_pos).manhattanLength()
            start_dist = QApplication.startDragDistance()
            print(f"[DRAG-DEBUG] mouseMoveEvent: pos={event.pos()}, press_pos={self._press_pos}, dist={dist}, threshold={start_dist}")
            if dist >= start_dist:
                # Determine selected items (support multi-select)
                container = self.parent()
                while container is not None and not isinstance(container, IconContainer):
                    container = container.parent()
                if container and getattr(container, 'selected_widgets', None):
                    paths = [w.full_path for w in container.selected_widgets]
                else:
                    paths = [self.full_path]

                mime = QMimeData()
                urls = [QUrl.fromLocalFile(p) for p in paths]
                mime.setUrls(urls)
                drag = QDrag(self)
                drag.setMimeData(mime)
                # Set a drag pixmap from the icon for visual feedback
                try:
                    pix = self.icon_label.pixmap()
                    if pix and not pix.isNull():
                        drag_pix = pix.scaled(64, 64, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                        drag.setPixmap(drag_pix)
                except Exception as e:
                    print(f"[DRAG-DEBUG] failed to set drag pixmap: {e}")


                print(f"[DRAG-DEBUG] Starting drag for paths: {paths}")

                # If dragging to browser, use CopyAction. If dragging to a directory in-app, ask user.
                drop_action = Qt.CopyAction
                # Try to detect if the drag is internal (to another directory in the app)
                # If so, ask user whether to Move or Copy
                # This is a heuristic: if QApplication.widgetAt(QCursor.pos()) is an IconContainer, treat as internal
                try:
                    from PyQt5.QtWidgets import QApplication, QMessageBox
                    from PyQt5.QtGui import QCursor
                    widget = QApplication.widgetAt(QCursor.pos())
                    if widget is not None:
                        # Check if it's a directory drop target (IconContainer or similar)
                        # You may need to adjust this type check for your app
                        if widget.__class__.__name__ == "IconContainer":
                            reply = QMessageBox.question(self, "Move or Copy?", "Do you want to Move or Copy the file(s)?", QMessageBox.Move | QMessageBox.Copy, QMessageBox.Move)
                            if reply == QMessageBox.Move:
                                drop_action = Qt.MoveAction
                            else:
                                drop_action = Qt.CopyAction
                except Exception as e:
                    print(f"[DRAG-DEBUG] Could not determine drop target: {e}")

                drag.exec_(drop_action)
                # Clear press pos so we don't restart drag
                try:
                    del self._press_pos
                except Exception:
                    pass
                return

        super().mouseMoveEvent(event)

class IconContainer(QWidget):
    emptySpaceClicked = pyqtSignal()
    emptySpaceRightClicked = pyqtSignal(QPoint)
    selectionChanged = pyqtSignal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        layout = QGridLayout()
        layout.setSpacing(6)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSizeConstraint(QGridLayout.SetMinAndMaxSize)
        layout.setAlignment(Qt.AlignHCenter | Qt.AlignTop)
        self.setLayout(layout)

        # Selection / drag state
        self.drag_start = None
        self.drag_end = None
        self.selection_rect = QRect()
        self.is_dragging = False
        self.selected_widgets = set()
        self.last_width = 0

        # Enable mouse tracking and expandability
        self.setMouseTracking(True)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setMinimumSize(100, 100)

        # Visual background
        self.setAutoFillBackground(True)
        palette = self.palette()
        palette.setColor(self.backgroundRole(), Qt.transparent)
        self.setPalette(palette)

        # Auto-scroll timer for selection drag
        self.auto_scroll_timer = QTimer(self)
        self.auto_scroll_timer.setInterval(30)
        self.auto_scroll_timer.timeout.connect(self._auto_scroll_during_drag)
        self._auto_scroll_direction = None
        self._auto_scroll_margin = 30
        self._auto_scroll_speed = 20

        # Track press for fallback container-level drags
        self._press_pos = None
        self._press_widget = None

        # Accept drops
        super().setAcceptDrops(True)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
            # Add visual feedback
            self.setStyleSheet(self.styleSheet() + "QWidget { border: 2px dashed #4CAF50; }")
            try:
                self._handle_drag_position(event.pos())
            except Exception:
                pass
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
            try:
                self._handle_drag_position(event.pos())
                # Highlight potential drop targets
                self._highlight_drop_target(event.pos())
            except Exception:
                pass
        else:
            event.ignore()

    def dragLeaveEvent(self, event):
        self._auto_scroll_direction = None
        # Remove visual feedback
        current_style = self.styleSheet()
        new_style = current_style.replace("QWidget { border: 2px dashed #4CAF50; }", "")
        self.setStyleSheet(new_style)
        self._clear_drop_target_highlight()
        try:
            if self.auto_scroll_timer.isActive():
                self.auto_scroll_timer.stop()
        except Exception:
            pass
        event.accept()

    def _handle_drag_position(self, pos):
        parent_scroll = self._get_parent_scroll_area()
        if parent_scroll:
            view_rect = parent_scroll.viewport().rect()
            mapped_pos = self.mapToParent(pos)
            direction = None
            if mapped_pos.y() < self._auto_scroll_margin:
                direction = 'up'
            elif mapped_pos.y() > view_rect.height() - self._auto_scroll_margin:
                direction = 'down'
            elif mapped_pos.x() < self._auto_scroll_margin:
                direction = 'left'
            elif mapped_pos.x() > view_rect.width() - self._auto_scroll_margin:
                direction = 'right'

            if direction:
                self._auto_scroll_direction = direction
                if not self.auto_scroll_timer.isActive():
                    self.auto_scroll_timer.start()
            else:
                self._auto_scroll_direction = None
                if self.auto_scroll_timer.isActive():
                    self.auto_scroll_timer.stop()
        else:
            self._auto_scroll_direction = None
            if self.auto_scroll_timer.isActive():
                self.auto_scroll_timer.stop()

    def dropEvent(self, event):
        import os
        # Clear visual feedback
        current_style = self.styleSheet()
        new_style = current_style.replace("QWidget { border: 2px dashed #4CAF50; }", "")
        self.setStyleSheet(new_style)
        self._clear_drop_target_highlight()
        
        if event.mimeData().hasUrls():
            drop_pos = event.pos()
            candidate = self.childAt(drop_pos)
            target_widget = candidate
            while target_widget is not None and not hasattr(target_widget, 'full_path'):
                if target_widget is self:
                    target_widget = None
                    break
                target_widget = target_widget.parent()

            paths = [url.toLocalFile() for url in event.mimeData().urls()]
            print(f"[DROP-DEBUG] dropEvent: pos={drop_pos}, candidate={getattr(candidate, '__class__', None)}, resolved_target={getattr(target_widget, 'full_path', None)}, paths={paths}")

            # Determine target directory
            target_dir = None
            if target_widget is not None and os.path.isdir(getattr(target_widget, 'full_path', '')):
                target_dir = target_widget.full_path
                print(f"[DROP-DEBUG] Dropping into target folder: {target_dir}")
            else:
                # Try to get current directory from parent FileManagerTab
                ancestor = self.parent()
                while ancestor is not None and not hasattr(ancestor, 'get_current_path'):
                    ancestor = ancestor.parent()
                if ancestor is not None and hasattr(ancestor, 'get_current_path'):
                    try:
                        target_dir = ancestor.get_current_path()
                        print(f"[DROP-DEBUG] Dropping into current directory: {target_dir}")
                    except Exception as e:
                        print(f"[DROP-ERROR] Failed to get current path: {e}")

            if target_dir and os.path.isdir(target_dir):
                for src_path in paths:
                    try:
                        if not src_path:
                            continue
                        if not os.path.exists(src_path):
                            print(f"[DROP-DEBUG] source does not exist: {src_path}")
                            continue
                        dest_path = os.path.join(target_dir, os.path.basename(src_path))
                        if os.path.exists(dest_path):
                            base, ext = os.path.splitext(dest_path)
                            i = 1
                            new_dest = f"{base} ({i}){ext}"
                            while os.path.exists(new_dest):
                                i += 1
                                new_dest = f"{base} ({i}){ext}"
                            dest_path = new_dest
                        # If moving a folder into itself or its subfolder, block and warn
                        if os.path.isdir(src_path):
                            abs_src = os.path.abspath(src_path)
                            abs_dest = os.path.abspath(dest_path)
                            if abs_dest.startswith(abs_src + os.sep):
                                print(f"[DROP-ERROR] Cannot move folder into itself or subfolder: {src_path} -> {dest_path}")
                                continue
                        fast_move(src_path, dest_path)
                        print(f"[DROP-DEBUG] moved {src_path} -> {dest_path}")
                    except Exception as e:
                        print(f"[DROP-ERROR] Failed to move {src_path} to {dest_path}: {e}")

                # Refresh view (FileManagerTab)
                ancestor = self.parent()
                while ancestor is not None and not hasattr(ancestor, 'refresh_current_view'):
                    ancestor = ancestor.parent()
                if ancestor is not None and hasattr(ancestor, 'refresh_current_view'):
                    try:
                        ancestor.refresh_current_view()
                        print(f"[DROP-DEBUG] refresh_current_view called on {ancestor}")
                    except Exception as e:
                        print(f"[DROP-ERROR] refresh_current_view failed: {e}")
                event.acceptProposedAction()
            else:
                print("[DROP-DEBUG] no valid folder target under drop")
                event.ignore()
        else:
            event.ignore()

    def startDrag(self, supportedActions):
        from PyQt5.QtCore import QMimeData
        from PyQt5.QtGui import QDrag
        mime_data = QMimeData()
        selected_paths = [w.full_path for w in self.selected_widgets]
        urls = [QUrl.fromLocalFile(p) for p in selected_paths]
        mime_data.setUrls(urls)
        drag = QDrag(self)
        drag.setMimeData(mime_data)
        try:
            first_widget = next(iter(self.selected_widgets)) if self.selected_widgets else None
            if first_widget and hasattr(first_widget, 'icon_label'):
                pix = first_widget.icon_label.pixmap()
                if pix and not pix.isNull():
                    drag_pix = pix.scaled(64, 64, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    drag.setPixmap(drag_pix)
        except Exception:
            pass
        drag.exec_(supportedActions)

    def mouseMoveEvent(self, event):
        if self.is_dragging and self.drag_start:
            if (event.pos() - self.drag_start).manhattanLength() > QApplication.startDragDistance():
                self.is_dragging = False
                self.startDrag(Qt.MoveAction)
        else:
            try:
                if self._press_pos and (event.buttons() & Qt.LeftButton):
                    dist = (event.pos() - self._press_pos).manhattanLength()
                    if dist > QApplication.startDragDistance():
                        if self._press_widget and hasattr(self._press_widget, 'full_path'):
                            if self._press_widget in self.selected_widgets or getattr(self, 'selected_widgets_paths', None) and self._press_widget.full_path in self.selected_widgets_paths:
                                self._press_pos = None
                                self._press_widget = None
                                self.startDrag(Qt.MoveAction)
                                return
            except Exception:
                pass
        super().mouseMoveEvent(event)

    def _highlight_drop_target(self, pos):
        """Highlight potential drop target widget under cursor."""
        try:
            candidate = self.childAt(pos)
            # Remove previous highlights
            self._clear_drop_target_highlight()
            
            # Find target widget that has full_path (directory)
            target_widget = candidate
            while target_widget is not None and not hasattr(target_widget, 'full_path'):
                if target_widget is self:
                    target_widget = None
                    break
                target_widget = target_widget.parent()
            
            # Highlight if it's a directory
            if target_widget and hasattr(target_widget, 'full_path') and os.path.isdir(target_widget.full_path):
                original_style = getattr(target_widget, '_original_style', target_widget.styleSheet())
                target_widget._original_style = original_style
                target_widget.setStyleSheet(original_style + "QWidget { background-color: rgba(76, 175, 80, 0.3); }")
                self._highlighted_widget = target_widget
        except Exception:
            pass

    def _clear_drop_target_highlight(self):
        """Remove highlighting from previously highlighted drop target."""
        try:
            if hasattr(self, '_highlighted_widget') and self._highlighted_widget:
                if hasattr(self._highlighted_widget, '_original_style'):
                    self._highlighted_widget.setStyleSheet(self._highlighted_widget._original_style)
                self._highlighted_widget = None
        except Exception:
            pass

    def setAcceptDrops(self, accept):
        super().setAcceptDrops(accept)

    def _get_parent_scroll_area(self):
        parent = self.parent()
        while parent and not isinstance(parent, QScrollArea):
            parent = parent.parent()
        return parent if isinstance(parent, QScrollArea) else None

    def _auto_scroll_during_drag(self):
        parent_scroll = self._get_parent_scroll_area()
        if not parent_scroll or not self._auto_scroll_direction:
            self.auto_scroll_timer.stop()
            return
        vbar = parent_scroll.verticalScrollBar()
        hbar = parent_scroll.horizontalScrollBar()
        if self._auto_scroll_direction == 'up':
            vbar.setValue(vbar.value() - self._auto_scroll_speed)
        elif self._auto_scroll_direction == 'down':
            vbar.setValue(vbar.value() + self._auto_scroll_speed)
        elif self._auto_scroll_direction == 'left':
            hbar.setValue(hbar.value() - self._auto_scroll_speed)
        elif self._auto_scroll_direction == 'right':
            hbar.setValue(hbar.value() + self._auto_scroll_speed)

    # ... keep the rest of methods like sizeHint, resizeEvent, mousePressEvent, selection helpers unchanged
    
    def sizeHint(self):
        """Provide size hint to ensure proper expansion"""
        # Get the size needed for all widgets
        layout = self.layout()
        if layout.count() == 0:
            return QSize(400, 300)  # Default minimum size
        
        # Calculate minimum size based on content and parent
        min_width = 400
        min_height = 300
        
        # Get the parent scroll area size if available
        parent_widget = self.parent()
        while parent_widget and not isinstance(parent_widget, QScrollArea):
            parent_widget = parent_widget.parent()
            
        if parent_widget and isinstance(parent_widget, QScrollArea):
            viewport_size = parent_widget.viewport().size()
            min_width = max(min_width, viewport_size.width())
            min_height = max(min_height, viewport_size.height())
        
        return QSize(min_width, min_height)
    
    def resizeEvent(self, event):
        """Handle resize events to ensure proper layout"""
        super().resizeEvent(event)
        # Force layout update when resized
        self.layout().activate()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            # Determine if click is on empty space or on an icon.
            # childAt may return a QLabel or internal child inside an IconWidget.
            # Walk up the parent chain to find a widget that has 'full_path'.
            raw_clicked = self.childAt(event.pos())
            clicked_widget = None
            candidate = raw_clicked
            while candidate is not None and candidate is not self:
                if hasattr(candidate, 'full_path'):
                    clicked_widget = candidate
                    break
                candidate = candidate.parent()

            is_empty_space = (clicked_widget is None or 
                              clicked_widget == self or 
                              clicked_widget == self.layout() or
                              isinstance(clicked_widget, QLayout))

            # If clicking empty space, start selection drag (rubber-band)
            if is_empty_space:
                # Start drag-selection
                self.drag_start = event.pos()
                self.is_dragging = True
                # If not holding Ctrl, clear previous selection
                if not (event.modifiers() & Qt.ControlModifier):
                    self.clear_selection()

                # Special logic: allow single click to the right of the furthest right icon to only register for drag selection
                layout = self.layout()
                if layout.count() > 0:
                    # Find the bottom-most, right-most widget
                    max_right = 0
                    max_bottom = 0
                    for i in range(layout.count()):
                        item = layout.itemAt(i)
                        if item and item.widget():
                            rect = item.widget().geometry()
                            max_right = max(max_right, rect.right())
                            max_bottom = max(max_bottom, rect.bottom())
                    # If click is to the right of the right-most icon (and within the vertical bounds of icons)
                    if event.pos().x() > max_right and event.pos().y() <= max_bottom:
                        # Treat as empty space: clear selection handled above, and allow drag selection to start
                        self.emptySpaceClicked.emit()
                        event.accept()
                        return

                # Default empty-space click behavior
                self.emptySpaceClicked.emit()
                event.accept()
                return
            else:
                # Click landed on a widget (icon) — record press so container can start a drag fallback if needed
                # clicked_widget already resolved to the IconWidget (or None)
                clicked_widget = clicked_widget if clicked_widget is not None else self.childAt(event.pos())
                try:
                    # Record press position and widget for fallback
                    self._press_pos = event.pos()
                    self._press_widget = clicked_widget
                except Exception:
                    self._press_pos = None
                    self._press_widget = None

                # Let the child handle click/selection as before
                super().mousePressEvent(event)
                return
        elif event.button() == Qt.RightButton:
            # Determine if right-click hit an icon by walking up parent chain similar to left-click
            raw_clicked = self.childAt(event.pos())
            clicked_widget = None
            candidate = raw_clicked
            while candidate is not None and candidate is not self:
                if hasattr(candidate, 'full_path'):
                    clicked_widget = candidate
                    break
                candidate = candidate.parent()

            is_empty_space = (clicked_widget is None or 
                              clicked_widget == self or 
                              clicked_widget == self.layout() or
                              isinstance(clicked_widget, QLayout))
            if is_empty_space:
                try:
                    icon_container_debug('Right click in container empty space at pos={} global={}', event.pos(), event.globalPos())
                except Exception:
                    pass
                self.emptySpaceRightClicked.emit(event.globalPos())
                event.accept()
                return
            else:
                super().mousePressEvent(event)
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self.is_dragging and self.drag_start:
            self.drag_end = event.pos()
            self.selection_rect = QRect(self.drag_start, self.drag_end).normalized()
            self.update_selection()
            self.update()  # Trigger repaint

            # --- Auto-scroll logic ---
            parent_scroll = self._get_parent_scroll_area()
            if parent_scroll:
                view_rect = parent_scroll.viewport().rect()
                mapped_pos = self.mapToParent(event.pos())
                # Determine scroll direction
                direction = None
                if mapped_pos.y() < self._auto_scroll_margin:
                    direction = 'up'
                elif mapped_pos.y() > view_rect.height() - self._auto_scroll_margin:
                    direction = 'down'
                elif mapped_pos.x() < self._auto_scroll_margin:
                    direction = 'left'
                elif mapped_pos.x() > view_rect.width() - self._auto_scroll_margin:
                    direction = 'right'
                if direction:
                    self._auto_scroll_direction = direction
                    if not self.auto_scroll_timer.isActive():
                        self.auto_scroll_timer.start()
                else:
                    self._auto_scroll_direction = None
                    self.auto_scroll_timer.stop()
            else:
                self._auto_scroll_direction = None
                self.auto_scroll_timer.stop()
        else:
            # Fallback: if user pressed on an icon (not empty space) and moved beyond drag threshold, start drag of selected items
            try:
                if self._press_pos and (event.buttons() & Qt.LeftButton):
                    dist = (event.pos() - self._press_pos).manhattanLength()
                    if dist > QApplication.startDragDistance():
                        # Only start container drag if the pressed widget is part of the selection
                        if self._press_widget and hasattr(self._press_widget, 'full_path'):
                            if self._press_widget in self.selected_widgets or self._press_widget.full_path in getattr(self, 'selected_widgets_paths', []):
                                # Reset press tracking to avoid re-entrancy
                                self._press_pos = None
                                self._press_widget = None
                                # Start drag using container's selected widgets
                                self.startDrag(Qt.MoveAction)
                                return
            except Exception:
                pass
            self._auto_scroll_direction = None
            self.auto_scroll_timer.stop()

    def _get_parent_scroll_area(self):
        parent = self.parent()
        while parent and not isinstance(parent, QScrollArea):
            parent = parent.parent()
        return parent if isinstance(parent, QScrollArea) else None

    def _auto_scroll_during_drag(self):
        parent_scroll = self._get_parent_scroll_area()
        if not parent_scroll or not self._auto_scroll_direction:
            self.auto_scroll_timer.stop()
            return
        vbar = parent_scroll.verticalScrollBar()
        hbar = parent_scroll.horizontalScrollBar()
        if self._auto_scroll_direction == 'up':
            vbar.setValue(vbar.value() - self._auto_scroll_speed)
        elif self._auto_scroll_direction == 'down':
            vbar.setValue(vbar.value() + self._auto_scroll_speed)
        elif self._auto_scroll_direction == 'left':
            hbar.setValue(hbar.value() - self._auto_scroll_speed)
        elif self._auto_scroll_direction == 'right':
            hbar.setValue(hbar.value() + self._auto_scroll_speed)

    def mouseReleaseEvent(self, event):
        try:
            icon_container_debug('mouseReleaseEvent button={} pos={} global={}', getattr(event, 'button', lambda: None)(), getattr(event, 'pos', lambda: '<no-pos>')(), getattr(event, 'globalPos', lambda: '<no-global>')())
        except Exception:
            pass
        if event.button() == Qt.LeftButton and self.is_dragging:
            self.is_dragging = False
            self.drag_start = None
            self.drag_end = None
            self.update()  # Clear selection rectangle
            self._auto_scroll_direction = None
            self.auto_scroll_timer.stop()

    def paintEvent(self, event):
        super().paintEvent(event)
        if self.is_dragging and self.selection_rect.isValid():
            painter = QPainter(self)
            pen = QPen(Qt.blue, 1, Qt.DashLine)
            painter.setPen(pen)
            painter.drawRect(self.selection_rect)

    def update_selection(self):
        layout = self.layout()
        newly_selected = set()
        
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                widget_rect = widget.geometry()
                
                if self.selection_rect.intersects(widget_rect):
                    newly_selected.add(widget)
                    widget.setStyleSheet("QWidget { border: 2px solid #0078d7; background-color: rgba(0, 120, 215, 0.2); }")
                elif widget not in self.selected_widgets:
                    widget.setStyleSheet("QWidget { border: 2px solid transparent; }")
        
        # Update selected widgets
        self.selected_widgets = newly_selected
        
        # Emit selection changed signal
        selected_paths = [w.full_path for w in self.selected_widgets]
        self.selectionChanged.emit(selected_paths)

    def clear_selection(self):
        layout = self.layout()
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                widget.setStyleSheet("QWidget { border: 2px solid transparent; }")
                # Update IconWidget selection state for truncation
                if hasattr(widget, 'set_selected'):
                    widget.set_selected(False)
        self.selected_widgets.clear()
        self.selectionChanged.emit([])

    def add_to_selection(self, widget):
        self.selected_widgets.add(widget)
        widget.setStyleSheet("QWidget { border: 2px solid #0078d7; background-color: rgba(0, 120, 215, 0.2); }")
        # Update IconWidget selection state for truncation
        if hasattr(widget, 'set_selected'):
            widget.set_selected(True)
        selected_paths = [w.full_path for w in self.selected_widgets]
        self.selectionChanged.emit(selected_paths)

    def remove_from_selection(self, widget):
        if widget in self.selected_widgets:
            self.selected_widgets.remove(widget)
            widget.setStyleSheet("QWidget { border: 2px solid transparent; }")
            # Update IconWidget selection state for truncation
            if hasattr(widget, 'set_selected'):
                widget.set_selected(False)
            selected_paths = [w.full_path for w in self.selected_widgets]
            self.selectionChanged.emit(selected_paths)

    def add_to_selection_by_path(self, path):
        """Add widget to selection by file path"""
        layout = self.layout()
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                if hasattr(widget, 'full_path') and widget.full_path == path:
                    self.add_to_selection(widget)
                    break

    def remove_from_selection_by_path(self, path):
        """Remove widget from selection by file path"""
        layout = self.layout()
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                if hasattr(widget, 'full_path') and widget.full_path == path:
                    self.remove_from_selection(widget)
                    break

    def add_widget_optimized(self, widget, thumbnail_size, icons_wide=0):
        """Add widget to grid layout with optimized positioning for icons per row"""
        # Prevent recursive calls during relayout
        if hasattr(self, '_in_add_widget') and self._in_add_widget:
            return
        self._in_add_widget = True
        
        try:
            layout = self.layout()
            
            # Calculate approximate widget width (thumbnail + padding + margins)
            # Include space for text label underneath
            widget_width = thumbnail_size + 10  # thumbnail + margins/padding
            widget_height = thumbnail_size + 30  # thumbnail + text height + margins
            
            # Add spacing between widgets to the width calculation
            spacing = layout.spacing()  # Get the layout spacing (10 pixels)
            effective_widget_width = widget_width + spacing
            
            # Determine icons per row
            if icons_wide > 0:
                # Fixed number of icons per row
                icons_per_row = icons_wide
            else:
                # Auto-calculate based on available space
                # Get the actual available width from the scroll area viewport
                parent = self.parent()
                scroll_area = None
                while parent:
                    if hasattr(parent, 'viewport'):
                        scroll_area = parent
                        break
                    parent = parent.parent()
                if scroll_area:
                    viewport_width = scroll_area.viewport().width()
                else:
                    viewport_width = self.width()
                # Get layout margins
                layout_margins = self.layout().contentsMargins()
                left_margin = layout_margins.left()
                right_margin = layout_margins.right()
                spacing = layout.spacing()
                # Calculate available width for icons (viewport minus margins)
                available_width = viewport_width - left_margin - right_margin
                # Calculate max icons per row that fit without scrolling
                if available_width < effective_widget_width:
                    icons_per_row = 1
                else:
                    # n*W + (n-1)*S <= available_width  =>  n = floor((available_width + S) / (W + S))
                    icons_per_row = max(1, (available_width + spacing) // (effective_widget_width))
            
            # Calculate current position
            current_count = layout.count()
            row = current_count // icons_per_row
            col = current_count % icons_per_row
            
            # Force widget size BEFORE adding to layout to ensure proper grid display
            widget.setMinimumSize(widget_width, widget_height)
            widget.setMaximumWidth(widget_width + 20)  # Allow some flexibility
            widget.setFixedSize(widget_width, widget_height)  # Force exact size for grid layout
            
            # Add widget at calculated position
            layout.addWidget(widget, row, col)
            
        finally:
            self._in_add_widget = False

    def resizeEvent(self, event):
        """Handle resize events to re-layout icons in auto-width mode"""
        super().resizeEvent(event)
        
        # Prevent recursive resize events
        if hasattr(self, '_in_resize') and self._in_resize:
            return
        self._in_resize = True
        
        try:
            # Check scroll area viewport width instead of container width for better auto-width calculation
            scroll_area = None
            parent = self.parent()
            while parent:
                if hasattr(parent, 'viewport'):
                    scroll_area = parent
                    break
                parent = parent.parent()
            
            # Get current available width
            if scroll_area:
                current_width = scroll_area.viewport().width()
            else:
                current_width = self.width()
            
            if not hasattr(self, 'last_available_width'):
                self.last_available_width = current_width
            
            # Only re-layout if width changed significantly and we're in auto-width mode
            if abs(current_width - self.last_available_width) > 50:  # Significant width change
                self.last_available_width = current_width
                
                # Check if we're in auto-width mode by trying to get the setting from parent
                main_window = None
                parent = self.parent()
                while parent:
                    if hasattr(parent, 'main_window'):
                        main_window = parent.main_window
                        break
                    elif hasattr(parent, 'icons_wide'):
                        main_window = parent
                        break
                    parent = parent.parent()
                
                # Re-layout icons if in auto-width mode (icons_wide == 0)
                if main_window and getattr(main_window, 'icons_wide', 0) == 0:
                    # Use a timer to prevent excessive calls
                    if not hasattr(self, '_resize_timer'):
                        from PyQt5.QtCore import QTimer
                        self._resize_timer = QTimer()
                        self._resize_timer.setSingleShot(True)
                        self._resize_timer.timeout.connect(self.relayout_icons)
                    
                    self._resize_timer.stop()
                    self._resize_timer.start(100)  # Delay 100ms before relayout
        finally:
            self._in_resize = False
    
    def relayout_icons(self):
        """Re-layout existing icons to adjust to new container width"""
        layout = self.layout()
        widgets = []
        
        # Collect all existing widgets
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.widget():
                widgets.append(item.widget())
        
        # Clear the layout
        for i in reversed(range(layout.count())):
            item = layout.itemAt(i)
            if item:
                layout.removeItem(item)
        
        # Re-add widgets with new layout calculation
        if widgets:
            # Get current settings
            main_window = None
            parent = self.parent()
            while parent and not main_window:
                if hasattr(parent, 'thumbnail_size'):
                    main_window = parent
                    break
                parent = parent.parent()
            
            thumbnail_size = getattr(main_window, 'thumbnail_size', 64) if main_window else 64
            icons_wide = getattr(main_window, 'icons_wide', 0) if main_window else 0
            
            for widget in widgets:
                self.add_widget_optimized(widget, thumbnail_size, icons_wide)

class BreadcrumbWidget(QWidget):
    def show_address_bar(self, current_path):
        from PyQt5.QtWidgets import QLineEdit
        # Remove all widgets
        while self.layout.count():
            item = self.layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.spacerItem():
                del item
        # Add address bar
        address_bar = QLineEdit(current_path)
        address_bar.setStyleSheet("font-size: 18px; padding: 2px 8px;")
        address_bar.returnPressed.connect(lambda: self.pathClicked.emit(address_bar.text()))
        self.layout.addWidget(address_bar)
        address_bar.setFocus()
    def set_text_color(self, color):
        """Set the text color of all breadcrumb buttons and separators."""
        for i in range(self.layout.count()):
            item = self.layout.itemAt(i)
            widget = item.widget() if item else None
            if isinstance(widget, QPushButton):
                # Update only color, keep other styles
                style = widget.styleSheet()
                # Replace color property or add it
                import re
                if 'color:' in style:
                    style = re.sub(r'color:\s*[^;]+;', f'color: {color};', style)
                else:
                    style += f'color: {color};'
                widget.setStyleSheet(style)
            elif isinstance(widget, QLabel):
                # For separators
                widget.setStyleSheet(f"color: {color}; font-weight: bold; font-size: 13px;")
    """Breadcrumb navigation widget"""
    pathClicked = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QHBoxLayout()
        self.layout.setContentsMargins(5, 0, 5, 0)  # Reduced vertical margins for less spacing
        self.layout.setSpacing(0)
        self.layout.setAlignment(Qt.AlignLeft)  # Explicitly set left alignment
        self.setLayout(self.layout)
        
        # Make breadcrumb bar more compact to reduce vertical space
        self.setFixedHeight(24)  # Reduced from 40 to 24
        self.setMinimumHeight(24)
        self.setMaximumHeight(24)
        
        # Use normal font size instead of enlarged
        font = self.font()
        font.setPointSize(font.pointSize())  # Keep original size, don't multiply by 2
        self.setFont(font)
        
    def set_path(self, path):
        """Set the current path and update breadcrumb buttons"""
        # Clear existing widgets and layout items (including stretch)
        while self.layout.count():
            item = self.layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.spacerItem():
                # Remove spacer items (stretch)
                del item
        
        if not path:
            # Even with no path, add stretch to maintain left alignment
            self.layout.addStretch()
            return
            
        # Split path into parts
        parts = []
        current = path
        is_windows = os.name == 'nt'
        while current and current != os.path.dirname(current):
            # On Windows, show C:\ for drive root (not C:\\)
            if is_windows and os.path.dirname(current) == current and len(current) == 2 and current[1] == ':':
                parts.append((current + '\\', current + '\\'))
                break
            parts.append((os.path.basename(current) or current, current))
            current = os.path.dirname(current)
        # Fix: convert C:\\ to C:\ for display
        for idx, (name, full_path) in enumerate(parts):
            # On Windows, show 'C:\\' for root (not 'C:' or 'C')
            if is_windows and ((name.endswith('\\') and len(name) == 3 and name[1] == ':' and name[2] == '\\') or (name.endswith(':') and len(name) == 2 and name[1] == ':')):
                parts[idx] = (name[0:2] + '\\', full_path)  # C:\\ or C: -> C:\
        # Add root if not already included
        if current and current not in [p[1] for p in parts]:
            if is_windows and len(current) == 2 and current[1] == ':':
                parts.append((current + '\\', current + '\\'))
            else:
                parts.append((current, current))
        parts.reverse()
        
        # Choose separator based on OS
        sep = ' \\ ' if os.name == 'nt' else ' / '
        # Create breadcrumb buttons
        for i, (name, full_path) in enumerate(parts):
            if i > 0:
                # Add separator with appropriately sized font
                separator = QLabel(sep)
                separator.setStyleSheet("color: gray; font-weight: bold; font-size: 13px;")
                self.layout.addWidget(separator)
            # Create clickable button for path part with underscore wrapping
            formatted_name = format_filename_with_underscore_wrap(name)
            button = QPushButton(formatted_name)
            button.setFlat(True)
            button.setStyleSheet("""
                QPushButton {
                    border: none;
                    padding: 2px 8px 6px 8px;
                    text-decoration: underline;
                    text-align: left;
                    font-size: 13px;
                }
                QPushButton:hover {
                    background-color: rgba(0, 102, 204, 0.1);
                }
                QPushButton:pressed {
                    background-color: rgba(0, 102, 204, 0.2);
                }
            """)
            if i == len(parts) - 1:
                button.clicked.connect(lambda checked, path=full_path: self.show_address_bar(path))
            else:
                button.clicked.connect(lambda checked, path=full_path: self.pathClicked.emit(path))
            self.layout.addWidget(button)
        # Add stretch to left-align breadcrumbs
        self.layout.addStretch()

# ========================================================================================
# CLOUD STORAGE AND SYNCHRONIZATION SYSTEM
# ========================================================================================

# =========================
# Authentication Manager for Cloud Storage
# =========================

import json
import base64
try:
    from cryptography.fernet import Fernet
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

class AuthenticationManager:
    """Secure authentication manager for cloud storage credentials"""
    
    def __init__(self):
        self.credentials_file = os.path.join(os.path.expanduser("~"), ".garysfm_auth.enc")
        self.key = self._get_or_create_key()
        self.credentials = self._load_credentials()
    
    def _get_or_create_key(self):
        """Get or create encryption key based on machine-specific data"""
        if not CRYPTO_AVAILABLE:
            return None
            
        try:
            # Use machine-specific information to generate a consistent key
            import platform
            machine_info = f"{platform.node()}{platform.system()}{platform.processor()}"
            password = machine_info.encode()
            
            # Create a consistent salt based on machine info
            salt = hashlib.sha256(machine_info.encode()).digest()[:16]
            
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=salt,
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(password))
            return Fernet(key)
        except Exception:
            # Fallback to simple encoding if cryptography is not available
            return None
    
    def _load_credentials(self):
        """Load encrypted credentials from file"""
        if not os.path.exists(self.credentials_file):
            return {}
        
        try:
            with open(self.credentials_file, 'rb') as f:
                encrypted_data = f.read()
            
            if self.key and encrypted_data:
                decrypted_data = self.key.decrypt(encrypted_data)
                return json.loads(decrypted_data.decode())
            else:
                # Fallback for unencrypted storage (less secure)
                return {}
        except Exception:
            return {}
    
    def _save_credentials(self):
        """Save encrypted credentials to file"""
        try:
            if self.key:
                data = json.dumps(self.credentials).encode()
                encrypted_data = self.key.encrypt(data)
                
                with open(self.credentials_file, 'wb') as f:
                    f.write(encrypted_data)
        except Exception as e:
            print(f"Failed to save credentials: {e}")
    
    def store_credentials(self, provider, credentials):
        """Store credentials for a cloud provider"""
        self.credentials[provider] = credentials
        self._save_credentials()
    
    def get_credentials(self, provider):
        """Get credentials for a cloud provider"""
        return self.credentials.get(provider, {})
    
    def remove_credentials(self, provider):
        """Remove credentials for a cloud provider"""
        if provider in self.credentials:
            del self.credentials[provider]
            self._save_credentials()
    
    def list_providers(self):
        """List all providers with stored credentials"""
        return list(self.credentials.keys())

# =========================
# Cloud Authentication Dialog
# =========================

class CloudAuthDialog(QDialog):
    """Dialog for cloud provider authentication"""
    
    def __init__(self, provider, auth_manager, parent=None):
        super().__init__(parent)
        self.provider = provider
        self.auth_manager = auth_manager
        self.credentials = None
        self.setup_ui()
    
    def setup_ui(self):
        self.setWindowTitle(f"Authenticate with {self.provider}")
        self.setModal(True)
        self.resize(400, 300)
        
        layout = QVBoxLayout(self)
        
        # Provider-specific instructions
        instructions = self.get_provider_instructions()
        layout.addWidget(QLabel(instructions))
        
        # Credential fields
        self.create_credential_fields(layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        self.test_btn = QPushButton("Test Connection")
        self.test_btn.clicked.connect(self.test_connection)
        button_layout.addWidget(self.test_btn)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.save_credentials)
        button_layout.addWidget(self.save_btn)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
    
    def get_provider_instructions(self):
        """Get provider-specific authentication instructions"""
        instructions = {
            'Google Drive': (
                "To connect to Google Drive:\n"
                "1. Go to Google Cloud Console\n"
                "2. Create credentials for a desktop application\n"
                "3. Download the JSON file and paste its contents below"
            ),
            'Dropbox': (
                "To connect to Dropbox:\n"
                "1. Go to Dropbox App Console\n"
                "2. Create a new app\n"
                "3. Generate an access token and paste it below"
            ),
            'OneDrive': (
                "To connect to OneDrive:\n"
                "1. Register your app in Azure Active Directory\n"
                "2. Get the application ID and secret\n"
                "3. Enter them below"
            )
        }
        return instructions.get(self.provider, "Enter your credentials below:")
    
    def create_credential_fields(self, layout):
        """Create provider-specific credential input fields"""
        if self.provider == 'Google Drive':
            layout.addWidget(QLabel("Service Account JSON:"))
            self.json_field = QTextEdit()
            self.json_field.setMaximumHeight(150)
            layout.addWidget(self.json_field)
        
        elif self.provider == 'Dropbox':
            layout.addWidget(QLabel("Access Token:"))
            self.token_field = QLineEdit()
            self.token_field.setEchoMode(QLineEdit.Password)
            layout.addWidget(self.token_field)
        
        elif self.provider == 'OneDrive':
            layout.addWidget(QLabel("Application ID:"))
            self.app_id_field = QLineEdit()
            layout.addWidget(self.app_id_field)
            
            layout.addWidget(QLabel("Client Secret:"))
            self.client_secret_field = QLineEdit()
            self.client_secret_field.setEchoMode(QLineEdit.Password)
            layout.addWidget(self.client_secret_field)
            
            layout.addWidget(QLabel("Tenant ID (optional):"))
            self.tenant_id_field = QLineEdit()
            layout.addWidget(self.tenant_id_field)
    
    def test_connection(self):
        """Test the connection with entered credentials"""
        credentials = self.get_entered_credentials()
        if not credentials:
            QMessageBox.warning(self, "Warning", "Please enter all required credentials.")
            return
        
        # Create a temporary provider instance to test
        try:
            from threading import Thread
            
            def test_auth():
                try:
                    if self.provider == 'Google Drive':
                        provider = GoogleDriveProvider()
                    elif self.provider == 'Dropbox':
                        provider = DropboxProvider()
                    elif self.provider == 'OneDrive':
                        provider = OneDriveProvider()
                    else:
                        return False
                    
                    result = provider.authenticate(credentials)
                    return result.get('status') == 'success'
                except Exception:
                    return False
            
            # Test in background thread
            test_thread = Thread(target=test_auth)
            test_thread.daemon = True
            test_thread.start()
            
            # Simple progress indicator
            QMessageBox.information(self, "Testing", "Testing connection... (this may take a moment)")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to test connection: {str(e)}")
    
    def get_entered_credentials(self):
        """Get credentials from input fields"""
        if self.provider == 'Google Drive':
            json_text = self.json_field.toPlainText().strip()
            if json_text:
                try:
                    json.loads(json_text)  # Validate JSON
                    return {'service_account_json': json_text}
                except json.JSONDecodeError:
                    return None
        
        elif self.provider == 'Dropbox':
            token = self.token_field.text().strip()
            if token:
                return {'access_token': token}
        
        elif self.provider == 'OneDrive':
            app_id = self.app_id_field.text().strip()
            client_secret = self.client_secret_field.text().strip()
            if app_id and client_secret:
                credentials = {
                    'client_id': app_id,
                    'client_secret': client_secret
                }
                tenant_id = self.tenant_id_field.text().strip()
                if tenant_id:
                    credentials['tenant_id'] = tenant_id
                return credentials
        
        return None
    
    def save_credentials(self):
        """Save the entered credentials"""
        credentials = self.get_entered_credentials()
        if not credentials:
            QMessageBox.warning(self, "Warning", "Please enter all required credentials.")
            return
        
        self.auth_manager.store_credentials(self.provider, credentials)
        self.credentials = credentials
        QMessageBox.information(self, "Success", f"Credentials saved for {self.provider}")
        self.accept()

class CloudStorageProvider:
    """Abstract base class for cloud storage providers"""
    
    def __init__(self, name, config=None):
        self.name = name
        self.config = config or {}
        self.authenticated = False
        self.auth_token = None
    
    def authenticate(self, credentials):
        """Authenticate with the cloud provider"""
        raise NotImplementedError("Subclasses must implement authenticate")
    
    def upload_file(self, local_path, remote_path, progress_callback=None):
        """Upload a file to cloud storage"""
        raise NotImplementedError("Subclasses must implement upload_file")
    
    def download_file(self, remote_path, local_path, progress_callback=None):
        """Download a file from cloud storage"""
        raise NotImplementedError("Subclasses must implement download_file")
    
    def list_files(self, remote_path=""):
        """List files in a remote directory"""
        raise NotImplementedError("Subclasses must implement list_files")
    
    def delete_file(self, remote_path):
        """Delete a file from cloud storage"""
        raise NotImplementedError("Subclasses must implement delete_file")
    
    def get_file_info(self, remote_path):
        """Get metadata about a remote file"""
        raise NotImplementedError("Subclasses must implement get_file_info")
    
    def create_folder(self, remote_path):
        """Create a folder in cloud storage"""
        raise NotImplementedError("Subclasses must implement create_folder")


class GoogleDriveProvider(CloudStorageProvider):
    """Google Drive cloud storage provider"""
    
    def __init__(self, config=None):
        super().__init__("Google Drive", config)
        self.service = None
    
    def authenticate(self, credentials):
        """Authenticate with Google Drive using OAuth2"""
        try:
            # Try using Google Drive API
            from googleapiclient.discovery import build
            from google.auth.transport.requests import Request
            from google.oauth2.credentials import Credentials
            from google_auth_oauthlib.flow import InstalledAppFlow
            
            SCOPES = ['https://www.googleapis.com/auth/drive']
            
            creds = None
            # Check for existing token
            if 'token_file' in credentials and os.path.exists(credentials['token_file']):
                creds = Credentials.from_authorized_user_file(credentials['token_file'], SCOPES)
            
            # If there are no (valid) credentials available, let the user log in
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    creds.refresh(Request())
                else:
                    if 'credentials_file' not in credentials:
                        raise Exception("Google Drive credentials file not provided")
                    
                    flow = InstalledAppFlow.from_client_secrets_file(
                        credentials['credentials_file'], SCOPES)
                    creds = flow.run_local_server(port=0)
                
                # Save the credentials for the next run
                if 'token_file' in credentials:
                    with open(credentials['token_file'], 'w') as token:
                        token.write(creds.to_json())
            
            self.service = build('drive', 'v3', credentials=creds)
            self.authenticated = True
            self.auth_token = creds
            return True
            
        except ImportError:
            raise Exception("Google Drive API libraries not installed. Install: pip install google-api-python-client google-auth-httplib2 google-auth-oauthlib")
        except Exception as e:
            raise Exception(f"Google Drive authentication failed: {str(e)}")
    
    def upload_file(self, local_path, remote_path, progress_callback=None):
        """Upload file to Google Drive"""
        if not self.authenticated:
            raise Exception("Not authenticated with Google Drive")
        
        try:
            from googleapiclient.http import MediaFileUpload
            import mimetypes
            
            # Determine MIME type
            mime_type, _ = mimetypes.guess_type(local_path)
            if mime_type is None:
                mime_type = 'application/octet-stream'
            
            # Prepare file metadata
            file_metadata = {
                'name': os.path.basename(remote_path)
            }
            
            # Handle folder structure
            folder_path = os.path.dirname(remote_path)
            if folder_path:
                parent_id = self._get_or_create_folder(folder_path)
                file_metadata['parents'] = [parent_id]
            
            # Upload file
            media = MediaFileUpload(local_path, mimetype=mime_type, resumable=True)
            request = self.service.files().create(body=file_metadata, media_body=media, fields='id')
            
            response = None
            while response is None:
                status, response = request.next_chunk()
                if progress_callback and status:
                    progress_callback(status.progress() * 100)
            
            return response.get('id')
            
        except Exception as e:
            raise Exception(f"Google Drive upload failed: {str(e)}")
    
    def download_file(self, remote_path, local_path, progress_callback=None):
        """Download file from Google Drive"""
        if not self.authenticated:
            raise Exception("Not authenticated with Google Drive")
        
        try:
            from googleapiclient.http import MediaIoBaseDownload
            import io
            
            # Find file by path
            file_id = self._find_file_by_path(remote_path)
            if not file_id:
                raise Exception(f"File not found: {remote_path}")
            
            # Download file
            request = self.service.files().get_media(fileId=file_id)
            file_handle = io.BytesIO()
            downloader = MediaIoBaseDownload(file_handle, request)
            
            done = False
            while done is False:
                status, done = downloader.next_chunk()
                if progress_callback:
                    progress_callback(status.progress() * 100)
            
            # Write to local file
            with open(local_path, 'wb') as f:
                f.write(file_handle.getvalue())
            
            return True
            
        except Exception as e:
            raise Exception(f"Google Drive download failed: {str(e)}")
    
    def list_files(self, remote_path=""):
        """List files in Google Drive folder"""
        if not self.authenticated:
            raise Exception("Not authenticated with Google Drive")
        
        try:
            query = "trashed=false"
            if remote_path:
                folder_id = self._find_file_by_path(remote_path)
                if folder_id:
                    query += f" and '{folder_id}' in parents"
            
            results = self.service.files().list(q=query, fields="files(id,name,mimeType,size,modifiedTime)").execute()
            files = results.get('files', [])
            
            file_list = []
            for file in files:
                file_info = {
                    'name': file['name'],
                    'id': file['id'],
                    'type': 'folder' if file['mimeType'] == 'application/vnd.google-apps.folder' else 'file',
                    'size': int(file.get('size', 0)) if file.get('size') else 0,
                    'modified': file.get('modifiedTime')
                }
                file_list.append(file_info)
            
            return file_list
            
        except Exception as e:
            raise Exception(f"Google Drive list failed: {str(e)}")
    
    def _find_file_by_path(self, path):
        """Find file ID by path"""
        # Simplified implementation - in production, this would need to handle nested paths
        query = f"name='{os.path.basename(path)}' and trashed=false"
        results = self.service.files().list(q=query, fields="files(id)").execute()
        files = results.get('files', [])
        return files[0]['id'] if files else None
    
    def _get_or_create_folder(self, folder_path):
        """Get or create folder and return its ID"""
        # Simplified implementation
        folder_name = os.path.basename(folder_path)
        query = f"name='{folder_name}' and mimeType='application/vnd.google-apps.folder' and trashed=false"
        results = self.service.files().list(q=query, fields="files(id)").execute()
        folders = results.get('files', [])
        
        if folders:
            return folders[0]['id']
        else:
            # Create folder
            folder_metadata = {
                'name': folder_name,
                'mimeType': 'application/vnd.google-apps.folder'
            }
            folder = self.service.files().create(body=folder_metadata, fields='id').execute()
            return folder.get('id')


class DropboxProvider(CloudStorageProvider):
    """Dropbox cloud storage provider"""
    
    def __init__(self, config=None):
        super().__init__("Dropbox", config)
        self.client = None
    
    def authenticate(self, credentials):
        """Authenticate with Dropbox"""
        try:
            import dropbox
            
            if 'access_token' not in credentials:
                raise Exception("Dropbox access token not provided")
            
            self.client = dropbox.Dropbox(credentials['access_token'])
            
            # Test authentication
            self.client.users_get_current_account()
            self.authenticated = True
            self.auth_token = credentials['access_token']
            return True
            
        except ImportError:
            raise Exception("Dropbox API library not installed. Install: pip install dropbox")
        except Exception as e:
            raise Exception(f"Dropbox authentication failed: {str(e)}")
    
    def upload_file(self, local_path, remote_path, progress_callback=None):
        """Upload file to Dropbox"""
        if not self.authenticated:
            raise Exception("Not authenticated with Dropbox")
        
        try:
            with open(local_path, 'rb') as f:
                file_size = os.path.getsize(local_path)
                
                if file_size <= 150 * 1024 * 1024:  # 150MB - simple upload
                    result = self.client.files_upload(f.read(), remote_path, mode=dropbox.files.WriteMode('overwrite'))
                    if progress_callback:
                        progress_callback(100)
                    return result.id
                else:
                    # Large file upload with progress
                    upload_session_start_result = self.client.files_upload_session_start(f.read(8388608))  # 8MB chunks
                    cursor = dropbox.files.UploadSessionCursor(
                        session_id=upload_session_start_result.session_id,
                        offset=f.tell()
                    )
                    
                    while f.tell() < file_size:
                        chunk_size = min(8388608, file_size - f.tell())
                        chunk = f.read(chunk_size)
                        
                        if len(chunk) == 0:
                            break
                        
                        if f.tell() == file_size:
                            # Final chunk
                            commit = dropbox.files.CommitInfo(path=remote_path, mode=dropbox.files.WriteMode('overwrite'))
                            result = self.client.files_upload_session_finish(chunk, cursor, commit)
                            if progress_callback:
                                progress_callback(100)
                            return result.id
                        else:
                            self.client.files_upload_session_append_v2(chunk, cursor)
                            cursor.offset = f.tell()
                            
                            if progress_callback:
                                progress = (f.tell() / file_size) * 100
                                progress_callback(progress)
            
        except Exception as e:
            raise Exception(f"Dropbox upload failed: {str(e)}")
    
    def download_file(self, remote_path, local_path, progress_callback=None):
        """Download file from Dropbox"""
        if not self.authenticated:
            raise Exception("Not authenticated with Dropbox")
        
        try:
            metadata, response = self.client.files_download(remote_path)
            
            with open(local_path, 'wb') as f:
                f.write(response.content)
            
            if progress_callback:
                progress_callback(100)
            
            return True
            
        except Exception as e:
            raise Exception(f"Dropbox download failed: {str(e)}")
    
    def list_files(self, remote_path=""):
        """List files in Dropbox folder"""
        if not self.authenticated:
            raise Exception("Not authenticated with Dropbox")
        
        try:
            if not remote_path:
                remote_path = ""
            
            result = self.client.files_list_folder(remote_path)
            files = []
            
            for entry in result.entries:
                if isinstance(entry, dropbox.files.FileMetadata):
                    file_info = {
                        'name': entry.name,
                        'type': 'file',
                        'size': entry.size,
                        'modified': entry.server_modified.isoformat() if entry.server_modified else None
                    }
                elif isinstance(entry, dropbox.files.FolderMetadata):
                    file_info = {
                        'name': entry.name,
                        'type': 'folder',
                        'size': 0,
                        'modified': None
                    }
                files.append(file_info)
            
            return files
            
        except Exception as e:
            raise Exception(f"Dropbox list failed: {str(e)}")


class OneDriveProvider(CloudStorageProvider):
    """OneDrive cloud storage provider"""
    
    def __init__(self, config=None):
        super().__init__("OneDrive", config)
        self.client = None
    
    def authenticate(self, credentials):
        """Authenticate with OneDrive using Microsoft Graph API"""
        try:
            # This is a simplified implementation
            # In production, you would use the Microsoft Graph SDK
            if 'access_token' not in credentials:
                raise Exception("OneDrive access token not provided")
            
            self.auth_token = credentials['access_token']
            self.authenticated = True
            return True
            
        except Exception as e:
            raise Exception(f"OneDrive authentication failed: {str(e)}")
    
    def upload_file(self, local_path, remote_path, progress_callback=None):
        """Upload file to OneDrive"""
        # Simplified implementation - would use Microsoft Graph API
        raise NotImplementedError("OneDrive provider not fully implemented yet")
    
    def download_file(self, remote_path, local_path, progress_callback=None):
        """Download file from OneDrive"""
        # Simplified implementation - would use Microsoft Graph API
        raise NotImplementedError("OneDrive provider not fully implemented yet")
    
    def list_files(self, remote_path=""):
        """List files in OneDrive folder"""
        # Simplified implementation - would use Microsoft Graph API
        raise NotImplementedError("OneDrive provider not fully implemented yet")


class CloudSyncManager:
    """Manages cloud storage synchronization"""
    
    def __init__(self):
        self.providers = {}
        self.active_provider = None
        self.sync_config = {
            'auto_sync': False,
            'sync_interval': 300,  # 5 minutes
            'conflict_resolution': 'ask',  # 'local', 'remote', 'ask'
            'selective_sync': True,
            'excluded_patterns': ['.tmp', '.temp', '~*', '.DS_Store']
        }
        self.sync_queue = []
        self.is_syncing = False
    
    def add_provider(self, provider):
        """Add a cloud storage provider"""
        self.providers[provider.name] = provider
    
    def set_active_provider(self, provider_name):
        """Set the active cloud storage provider"""
        if provider_name in self.providers:
            self.active_provider = self.providers[provider_name]
            return True
        return False
    
    def sync_folder(self, local_folder, remote_folder, direction='both', progress_callback=None):
        """Synchronize a local folder with remote storage"""
        if not self.active_provider or not self.active_provider.authenticated:
            raise Exception("No authenticated cloud provider available")
        
        if self.is_syncing:
            raise Exception("Sync already in progress")
        
        self.is_syncing = True
        try:
            sync_plan = self._create_sync_plan(local_folder, remote_folder, direction)
            self._execute_sync_plan(sync_plan, progress_callback)
        finally:
            self.is_syncing = False
    
    def _create_sync_plan(self, local_folder, remote_folder, direction):
        """Create a synchronization plan"""
        # Get local files
        local_files = self._scan_local_folder(local_folder)
        
        # Get remote files
        try:
            remote_files = self.active_provider.list_files(remote_folder)
        except:
            remote_files = []
        
        sync_plan = {
            'upload': [],
            'download': [],
            'conflicts': []
        }
        
        # Compare files and create sync plan
        local_file_map = {f['relative_path']: f for f in local_files}
        remote_file_map = {f['name']: f for f in remote_files}
        
        # Files to upload (local only or newer)
        if direction in ['both', 'upload']:
            for rel_path, local_file in local_file_map.items():
                if rel_path not in remote_file_map:
                    sync_plan['upload'].append({
                        'local_path': local_file['full_path'],
                        'remote_path': os.path.join(remote_folder, rel_path).replace('\\', '/'),
                        'action': 'upload_new'
                    })
                else:
                    # Check if local file is newer
                    remote_file = remote_file_map[rel_path]
                    if self._is_local_newer(local_file, remote_file):
                        sync_plan['upload'].append({
                            'local_path': local_file['full_path'],
                            'remote_path': os.path.join(remote_folder, rel_path).replace('\\', '/'),
                            'action': 'upload_update'
                        })
        
        # Files to download (remote only or newer)
        if direction in ['both', 'download']:
            for remote_name, remote_file in remote_file_map.items():
                if remote_name not in local_file_map:
                    sync_plan['download'].append({
                        'remote_path': os.path.join(remote_folder, remote_name).replace('\\', '/'),
                        'local_path': os.path.join(local_folder, remote_name),
                        'action': 'download_new'
                    })
                else:
                    # Check if remote file is newer
                    local_file = local_file_map[remote_name]
                    if self._is_remote_newer(local_file, remote_file):
                        if self._is_local_newer(local_file, remote_file):
                            # Conflict - both files modified
                            sync_plan['conflicts'].append({
                                'local_path': local_file['full_path'],
                                'remote_path': os.path.join(remote_folder, remote_name).replace('\\', '/'),
                                'local_file': local_file,
                                'remote_file': remote_file
                            })
                        else:
                            sync_plan['download'].append({
                                'remote_path': os.path.join(remote_folder, remote_name).replace('\\', '/'),
                                'local_path': os.path.join(local_folder, remote_name),
                                'action': 'download_update'
                            })
        
        return sync_plan
    
    def _scan_local_folder(self, folder_path):
        """Scan local folder and return file information"""
        files = []
        for root, dirs, filenames in os.walk(folder_path):
            for filename in filenames:
                if self._should_exclude_file(filename):
                    continue
                
                full_path = os.path.join(root, filename)
                relative_path = os.path.relpath(full_path, folder_path)
                
                try:
                    stat = os.stat(full_path)
                    files.append({
                        'name': filename,
                        'full_path': full_path,
                        'relative_path': relative_path,
                        'size': stat.st_size,
                        'modified': stat.st_mtime
                    })
                except OSError:
                    continue
        
        return files
    
    def _should_exclude_file(self, filename):
        """Check if file should be excluded from sync"""
        for pattern in self.sync_config['excluded_patterns']:
            if pattern.startswith('*') and filename.endswith(pattern[1:]):
                return True
            elif pattern.endswith('*') and filename.startswith(pattern[:-1]):
                return True
            elif pattern == filename:
                return True
        return False
    
    def _is_local_newer(self, local_file, remote_file):
        """Check if local file is newer than remote file"""
        # Simplified comparison - in production, would handle timezone conversion
        try:
            if remote_file.get('modified'):
                from datetime import datetime
                remote_time = datetime.fromisoformat(remote_file['modified'].replace('Z', '+00:00'))
                local_time = datetime.fromtimestamp(local_file['modified'])
                return local_time > remote_time
        except:
            pass
        return False
    
    def _is_remote_newer(self, local_file, remote_file):
        """Check if remote file is newer than local file"""
        return not self._is_local_newer(local_file, remote_file)
    
    def _execute_sync_plan(self, sync_plan, progress_callback=None):
        """Execute the synchronization plan"""
        total_operations = len(sync_plan['upload']) + len(sync_plan['download']) + len(sync_plan['conflicts'])
        completed_operations = 0
        
        # Handle uploads
        for upload_item in sync_plan['upload']:
            try:
                self.active_provider.upload_file(
                    upload_item['local_path'], 
                    upload_item['remote_path']
                )
                completed_operations += 1
                if progress_callback:
                    progress_callback(completed_operations, total_operations, f"Uploaded {os.path.basename(upload_item['local_path'])}")
            except Exception as e:
                # Log error but continue
                print(f"Upload failed for {upload_item['local_path']}: {e}")
        
        # Handle downloads
        for download_item in sync_plan['download']:
            try:
                # Create local directory if needed
                os.makedirs(os.path.dirname(download_item['local_path']), exist_ok=True)
                
                self.active_provider.download_file(
                    download_item['remote_path'], 
                    download_item['local_path']
                )
                completed_operations += 1
                if progress_callback:
                    progress_callback(completed_operations, total_operations, f"Downloaded {os.path.basename(download_item['local_path'])}")
            except Exception as e:
                # Log error but continue
                print(f"Download failed for {download_item['remote_path']}: {e}")
        
        # Handle conflicts based on configuration
        for conflict in sync_plan['conflicts']:
            try:
                resolution = self.sync_config['conflict_resolution']
                if resolution == 'local':
                    # Upload local version
                    self.active_provider.upload_file(conflict['local_path'], conflict['remote_path'])
                elif resolution == 'remote':
                    # Download remote version
                    os.makedirs(os.path.dirname(conflict['local_path']), exist_ok=True)
                    self.active_provider.download_file(conflict['remote_path'], conflict['local_path'])
                elif resolution == 'ask':
                    # Would show conflict resolution dialog in UI
                    print(f"Conflict detected for {conflict['local_path']} - manual resolution required")
                
                completed_operations += 1
                if progress_callback:
                    progress_callback(completed_operations, total_operations, f"Resolved conflict for {os.path.basename(conflict['local_path'])}")
            except Exception as e:
                print(f"Conflict resolution failed for {conflict['local_path']}: {e}")


# ========================================================================================
# FILE TAGGING AND COLLECTIONS SYSTEM
# ========================================================================================

class TagManager:
    """Manages file tags and metadata"""
    
    def __init__(self, db_path=None):
        self.db_path = db_path or os.path.join(os.path.expanduser("~"), ".garysfm", "tags.db")
        self.db_connection = None
        self.init_database()
    
    def init_database(self):
        """Initialize the tags database"""
        try:
            import sqlite3
            
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
            
            self.db_connection = sqlite3.connect(self.db_path)
            cursor = self.db_connection.cursor()
            
            # Create tables
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS tags (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT UNIQUE NOT NULL,
                    color TEXT DEFAULT '#4CAF50',
                    description TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS file_tags (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    file_path TEXT NOT NULL,
                    file_hash TEXT,
                    tag_id INTEGER,
                    added_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (tag_id) REFERENCES tags (id),
                    UNIQUE(file_path, tag_id)
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS collections (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT UNIQUE NOT NULL,
                    description TEXT,
                    color TEXT DEFAULT '#2196F3',
                    type TEXT DEFAULT 'manual',
                    query TEXT,
                    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS collection_files (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    collection_id INTEGER,
                    file_path TEXT NOT NULL,
                    file_hash TEXT,
                    added_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (collection_id) REFERENCES collections (id),
                    UNIQUE(collection_id, file_path)
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS file_metadata (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    file_path TEXT UNIQUE NOT NULL,
                    file_hash TEXT,
                    rating INTEGER DEFAULT 0,
                    notes TEXT,
                    favorite BOOLEAN DEFAULT 0,
                    last_accessed TIMESTAMP,
                    modified_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Create indexes for performance
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_file_tags_path ON file_tags(file_path)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_file_tags_tag ON file_tags(tag_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_collection_files_collection ON collection_files(collection_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_collection_files_path ON collection_files(file_path)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_file_metadata_path ON file_metadata(file_path)')
            
            self.db_connection.commit()
            
        except Exception as e:
            print(f"Failed to initialize tags database: {e}")
    
    def create_tag(self, name, color='#4CAF50', description=''):
        """Create a new tag"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute(
                'INSERT INTO tags (name, color, description) VALUES (?, ?, ?)',
                (name, color, description)
            )
            self.db_connection.commit()
            return cursor.lastrowid
        except Exception as e:
            print(f"Failed to create tag: {e}")
            return None
    
    def get_all_tags(self):
        """Get all available tags"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('SELECT id, name, color, description FROM tags ORDER BY name')
            return cursor.fetchall()
        except Exception as e:
            print(f"Failed to get tags: {e}")
            return []
    
    def add_tag_to_file(self, file_path, tag_name):
        """Add a tag to a file"""
        try:
            # Get or create tag
            tag_id = self._get_or_create_tag(tag_name)
            if not tag_id:
                return False
            
            # Generate file hash for integrity
            file_hash = self._calculate_file_hash(file_path)
            
            cursor = self.db_connection.cursor()
            cursor.execute(
                'INSERT OR IGNORE INTO file_tags (file_path, file_hash, tag_id) VALUES (?, ?, ?)',
                (file_path, file_hash, tag_id)
            )
            self.db_connection.commit()
            return True
        except Exception as e:
            print(f"Failed to add tag to file: {e}")
            return False
    
    def remove_tag_from_file(self, file_path, tag_name):
        """Remove a tag from a file"""
        try:
            tag_id = self._get_tag_id(tag_name)
            if not tag_id:
                return False
            
            cursor = self.db_connection.cursor()
            cursor.execute(
                'DELETE FROM file_tags WHERE file_path = ? AND tag_id = ?',
                (file_path, tag_id)
            )
            self.db_connection.commit()
            return True
        except Exception as e:
            print(f"Failed to remove tag from file: {e}")
            return False
    
    def get_file_tags(self, file_path):
        """Get all tags for a specific file"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                SELECT t.name, t.color, t.description 
                FROM tags t 
                JOIN file_tags ft ON t.id = ft.tag_id 
                WHERE ft.file_path = ?
            ''', (file_path,))
            return cursor.fetchall()
        except Exception as e:
            print(f"Failed to get file tags: {e}")
            return []
    
    def search_files_by_tag(self, tag_name):
        """Search for files with a specific tag"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                SELECT ft.file_path, ft.added_date 
                FROM file_tags ft 
                JOIN tags t ON ft.tag_id = t.id 
                WHERE t.name = ?
                ORDER BY ft.added_date DESC
            ''', (tag_name,))
            return cursor.fetchall()
        except Exception as e:
            print(f"Failed to search files by tag: {e}")
            return []
    
    def get_tag_statistics(self):
        """Get statistics about tag usage"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                SELECT t.name, t.color, COUNT(ft.file_path) as file_count
                FROM tags t
                LEFT JOIN file_tags ft ON t.id = ft.tag_id
                GROUP BY t.id, t.name, t.color
                ORDER BY file_count DESC, t.name
            ''')
            return cursor.fetchall()
        except Exception as e:
            print(f"Failed to get tag statistics: {e}")
            return []
    
    def _get_or_create_tag(self, tag_name):
        """Get tag ID or create if doesn't exist"""
        tag_id = self._get_tag_id(tag_name)
        if tag_id:
            return tag_id
        return self.create_tag(tag_name)
    
    def _get_tag_id(self, tag_name):
        """Get tag ID by name"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('SELECT id FROM tags WHERE name = ?', (tag_name,))
            result = cursor.fetchone()
            return result[0] if result else None
        except Exception as e:
            print(f"Failed to get tag ID: {e}")
            return None
    
    def _calculate_file_hash(self, file_path):
        """Calculate MD5 hash of file for integrity checking"""
        try:
            import hashlib
            with open(file_path, 'rb') as f:
                # Read in chunks to handle large files
                md5_hash = hashlib.md5()
                for chunk in iter(lambda: f.read(4096), b""):
                    md5_hash.update(chunk)
                return md5_hash.hexdigest()
        except Exception as e:
            print(f"Failed to calculate file hash: {e}")
            return None
    
    def set_file_rating(self, file_path, rating):
        """Set rating for a file (0-5 stars)"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO file_metadata (file_path, file_hash, rating, modified_date)
                VALUES (?, ?, ?, CURRENT_TIMESTAMP)
            ''', (file_path, self._calculate_file_hash(file_path), rating))
            self.db_connection.commit()
            return True
        except Exception as e:
            print(f"Failed to set file rating: {e}")
            return False
    
    def set_file_favorite(self, file_path, is_favorite):
        """Set favorite status for a file"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO file_metadata (file_path, file_hash, favorite, modified_date)
                VALUES (?, ?, ?, CURRENT_TIMESTAMP)
            ''', (file_path, self._calculate_file_hash(file_path), is_favorite))
            self.db_connection.commit()
            return True
        except Exception as e:
            print(f"Failed to set file favorite: {e}")
            return False
    
    def get_file_metadata(self, file_path):
        """Get metadata for a file"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                SELECT rating, notes, favorite, last_accessed, modified_date
                FROM file_metadata WHERE file_path = ?
            ''', (file_path,))
            result = cursor.fetchone()
            if result:
                return {
                    'rating': result[0],
                    'notes': result[1],
                    'favorite': bool(result[2]),
                    'last_accessed': result[3],
                    'modified_date': result[4]
                }
            return None
        except Exception as e:
            print(f"Failed to get file metadata: {e}")
            return None


class CollectionManager:
    """Manages file collections and smart collections"""
    
    def __init__(self, tag_manager):
        self.tag_manager = tag_manager
        self.db_connection = tag_manager.db_connection
    
    def create_collection(self, name, description='', color='#2196F3', collection_type='manual', query=''):
        """Create a new collection"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                INSERT INTO collections (name, description, color, type, query)
                VALUES (?, ?, ?, ?, ?)
            ''', (name, description, color, collection_type, query))
            self.db_connection.commit()
            return cursor.lastrowid
        except Exception as e:
            print(f"Failed to create collection: {e}")
            return None
    
    def get_all_collections(self):
        """Get all collections"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                SELECT id, name, description, color, type, query, created_date
                FROM collections ORDER BY name
            ''')
            return cursor.fetchall()
        except Exception as e:
            print(f"Failed to get collections: {e}")
            return []
    
    def add_file_to_collection(self, collection_id, file_path):
        """Add a file to a collection"""
        try:
            file_hash = self.tag_manager._calculate_file_hash(file_path)
            cursor = self.db_connection.cursor()
            cursor.execute('''
                INSERT OR IGNORE INTO collection_files (collection_id, file_path, file_hash)
                VALUES (?, ?, ?)
            ''', (collection_id, file_path, file_hash))
            self.db_connection.commit()
            return True
        except Exception as e:
            print(f"Failed to add file to collection: {e}")
            return False
    
    def remove_file_from_collection(self, collection_id, file_path):
        """Remove a file from a collection"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                DELETE FROM collection_files 
                WHERE collection_id = ? AND file_path = ?
            ''', (collection_id, file_path))
            self.db_connection.commit()
            return True
        except Exception as e:
            print(f"Failed to remove file from collection: {e}")
            return False
    
    def get_collection_files(self, collection_id):
        """Get all files in a collection"""
        try:
            cursor = self.db_connection.cursor()
            
            # First check if it's a smart collection
            cursor.execute('SELECT type, query FROM collections WHERE id = ?', (collection_id,))
            collection_info = cursor.fetchone()
            
            if collection_info and collection_info[0] == 'smart':
                # Execute smart collection query
                return self._execute_smart_query(collection_info[1])
            else:
                # Regular collection
                cursor.execute('''
                    SELECT file_path, added_date 
                    FROM collection_files 
                    WHERE collection_id = ?
                    ORDER BY added_date DESC
                ''', (collection_id,))
                return cursor.fetchall()
        except Exception as e:
            print(f"Failed to get collection files: {e}")
            return []
    
    def create_smart_collection(self, name, query, description='', color='#FF9800'):
        """Create a smart collection based on a query"""
        return self.create_collection(name, description, color, 'smart', query)
    
    def _execute_smart_query(self, query):
        """Execute a smart collection query"""
        try:
            # Parse and execute smart collection queries
            # Examples:
            # - "tag:photos" - files with photos tag
            # - "rating:>=4" - files with rating 4 or higher
            # - "favorite:true" - favorite files
            # - "type:image" - image files
            # - "modified:last_week" - files modified in last week
            
            if query.startswith('tag:'):
                tag_name = query[4:]
                return self.tag_manager.search_files_by_tag(tag_name)
            
            elif query.startswith('rating:'):
                rating_criteria = query[7:]
                return self._search_by_rating(rating_criteria)
            
            elif query == 'favorite:true':
                return self._search_favorites()
            
            elif query.startswith('type:'):
                file_type = query[5:]
                return self._search_by_type(file_type)
            
            elif query.startswith('modified:'):
                time_criteria = query[9:]
                return self._search_by_modified_date(time_criteria)
            
            else:
                # Custom SQL query (advanced)
                cursor = self.db_connection.cursor()
                cursor.execute(query)
                return cursor.fetchall()
                
        except Exception as e:
            print(f"Failed to execute smart query: {e}")
            return []
    
    def _search_by_rating(self, criteria):
        """Search files by rating criteria"""
        try:
            cursor = self.db_connection.cursor()
            
            if criteria.startswith('>='):
                rating = int(criteria[2:])
                cursor.execute('SELECT file_path FROM file_metadata WHERE rating >= ?', (rating,))
            elif criteria.startswith('<='):
                rating = int(criteria[2:])
                cursor.execute('SELECT file_path FROM file_metadata WHERE rating <= ?', (rating,))
            elif criteria.startswith('='):
                rating = int(criteria[1:])
                cursor.execute('SELECT file_path FROM file_metadata WHERE rating = ?', (rating,))
            else:
                rating = int(criteria)
                cursor.execute('SELECT file_path FROM file_metadata WHERE rating = ?', (rating,))
            
            return cursor.fetchall()
        except Exception as e:
            print(f"Failed to search by rating: {e}")
            return []
    
    def _search_favorites(self):
        """Search favorite files"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('SELECT file_path FROM file_metadata WHERE favorite = 1')
            return cursor.fetchall()
        except Exception as e:
            print(f"Failed to search favorites: {e}")
            return []
    
    def _search_by_type(self, file_type):
        """Search files by type"""
        try:
            # This would integrate with file system scanning
            # For now, return empty list
            return []
        except Exception as e:
            print(f"Failed to search by type: {e}")
            return []
    
    def _search_by_modified_date(self, criteria):
        """Search files by modification date"""
        try:
            # This would integrate with file system scanning
            # For now, return empty list
            return []
        except Exception as e:
            print(f"Failed to search by modified date: {e}")
            return []
    
    def get_collection_statistics(self):
        """Get statistics about collections"""
        try:
            cursor = self.db_connection.cursor()
            cursor.execute('''
                SELECT c.name, c.type, c.color, COUNT(cf.file_path) as file_count
                FROM collections c
                LEFT JOIN collection_files cf ON c.id = cf.collection_id
                WHERE c.type = 'manual'
                GROUP BY c.id, c.name, c.type, c.color
                UNION
                SELECT name, type, color, 0 as file_count
                FROM collections
                WHERE type = 'smart'
                ORDER BY file_count DESC, name
            ''')
            return cursor.fetchall()
        except Exception as e:
            print(f"Failed to get collection statistics: {e}")
            return []


class SmartCollectionBuilder:
    """Helper class for building smart collection queries"""
    
    @staticmethod
    def build_tag_query(tag_name):
        """Build query for files with specific tag"""
        return f"tag:{tag_name}"
    
    @staticmethod
    def build_rating_query(operator, rating):
        """Build query for files with rating criteria"""
        return f"rating:{operator}{rating}"
    
    @staticmethod
    def build_favorite_query():
        """Build query for favorite files"""
        return "favorite:true"
    
    @staticmethod
    def build_type_query(file_type):
        """Build query for files of specific type"""
        return f"type:{file_type}"
    
    @staticmethod
    def build_date_query(date_criteria):
        """Build query for files by date"""
        return f"modified:{date_criteria}"
    
    @staticmethod
    def build_complex_query(conditions):
        """Build complex query with multiple conditions"""
        # This would support AND/OR operations
        # For now, return simple concatenation
        return " AND ".join(conditions)


# ========================================================================================
# CLOUD SYNC AND TAGGING UI COMPONENTS
# ========================================================================================

class CloudSyncWidget(QWidget):
    """Widget for managing cloud synchronization"""
    
    def __init__(self, sync_manager=None, auth_manager=None, parent=None):
        super().__init__(parent)
        self.sync_manager = sync_manager or CloudSyncManager()
        self.auth_manager = auth_manager or AuthenticationManager()
        self.setup_ui()
        self.setup_connections()
    
    def setup_ui(self):
        """Setup the cloud sync UI"""
        from PyQt5.QtWidgets import (QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
                                     QComboBox, QProgressBar, QTextEdit, QGroupBox,
                                     QCheckBox, QSpinBox, QListWidget, QSplitter)
        
        layout = QVBoxLayout()
        
        # Cloud Provider Selection
        provider_group = QGroupBox("Cloud Storage Provider")
        provider_layout = QVBoxLayout()
        
        self.provider_combo = QComboBox()
        self.provider_combo.addItems(["None", "Google Drive", "Dropbox", "OneDrive"])
        provider_layout.addWidget(QLabel("Select Provider:"))
        provider_layout.addWidget(self.provider_combo)
        
        # Authentication
        auth_layout = QHBoxLayout()
        self.auth_button = QPushButton("Authenticate")
        self.auth_button.clicked.connect(self.authenticate_provider)
        self.auth_status = QLabel("Not authenticated")
        auth_layout.addWidget(self.auth_button)
        auth_layout.addWidget(self.auth_status)
        provider_layout.addLayout(auth_layout)
        
        # Check authentication status
        self.provider_combo.currentTextChanged.connect(self.check_authentication_status)
        
        provider_group.setLayout(provider_layout)
        layout.addWidget(provider_group)
        
        # Sync Configuration
        config_group = QGroupBox("Sync Configuration")
        config_layout = QVBoxLayout()
        
        # Auto sync
        self.auto_sync_check = QCheckBox("Enable automatic synchronization")
        config_layout.addWidget(self.auto_sync_check)
        
        # Sync interval
        interval_layout = QHBoxLayout()
        interval_layout.addWidget(QLabel("Sync interval (minutes):"))
        self.sync_interval_spin = QSpinBox()
        self.sync_interval_spin.setRange(1, 1440)  # 1 minute to 24 hours
        self.sync_interval_spin.setValue(5)
        interval_layout.addWidget(self.sync_interval_spin)
        interval_layout.addStretch()
        config_layout.addLayout(interval_layout)
        
        # Conflict resolution
        conflict_layout = QHBoxLayout()
        conflict_layout.addWidget(QLabel("Conflict resolution:"))
        self.conflict_combo = QComboBox()
        self.conflict_combo.addItems(["Ask me", "Prefer local", "Prefer remote"])
        conflict_layout.addWidget(self.conflict_combo)
        conflict_layout.addStretch()
        config_layout.addLayout(conflict_layout)
        
        config_group.setLayout(config_layout)
        layout.addWidget(config_group)
        
        # Sync Controls
        controls_group = QGroupBox("Sync Controls")
        controls_layout = QVBoxLayout()
        
        buttons_layout = QHBoxLayout()
        self.sync_now_button = QPushButton("Sync Now")
        self.pause_sync_button = QPushButton("Pause Sync")
        self.sync_settings_button = QPushButton("Advanced Settings")
        
        buttons_layout.addWidget(self.sync_now_button)
        buttons_layout.addWidget(self.pause_sync_button)
        buttons_layout.addWidget(self.sync_settings_button)
        buttons_layout.addStretch()
        controls_layout.addLayout(buttons_layout)
        
        # Progress bar
        self.sync_progress = QProgressBar()
        self.sync_progress.setVisible(False)
        controls_layout.addWidget(self.sync_progress)
        
        # Status label
        self.sync_status_label = QLabel("Ready")
        controls_layout.addWidget(self.sync_status_label)
        
        controls_group.setLayout(controls_layout)
        layout.addWidget(controls_group)
        
        # Sync Log
        log_group = QGroupBox("Sync Activity")
        log_layout = QVBoxLayout()
        
        self.sync_log = QTextEdit()
        self.sync_log.setMaximumHeight(150)
        self.sync_log.setReadOnly(True)
        log_layout.addWidget(self.sync_log)
        
        log_group.setLayout(log_layout)
        layout.addWidget(log_group)
        
        layout.addStretch()
        self.setLayout(layout)
    
    def setup_connections(self):
        """Setup signal connections"""
        self.provider_combo.currentTextChanged.connect(self.check_authentication_status)
        self.sync_now_button.clicked.connect(self.start_sync)
        self.pause_sync_button.clicked.connect(self.pause_sync)
        self.auto_sync_check.toggled.connect(self.toggle_auto_sync)
        
        # Initial authentication check
        self.check_authentication_status()
    
    def authenticate_provider(self):
        """Open authentication dialog for selected provider"""
        provider = self.provider_combo.currentText()
        
        if provider == "None":
            return
            
        dialog = CloudAuthDialog(provider, self.auth_manager, self)
        if dialog.exec_() == QDialog.Accepted:
            self.check_authentication_status()
    
    def check_authentication_status(self):
        """Check if the current provider is authenticated"""
        provider = self.provider_combo.currentText()
        
        if provider == "None":
            self.auth_status.setText("No provider selected")
            self.auth_status.setStyleSheet("")
            self.sync_now_button.setEnabled(False)
            return
        
        credentials = self.auth_manager.get_credentials(provider)
        
        if credentials:
            self.auth_status.setText("Authenticated")
            self.auth_status.setStyleSheet("color: green")
            self.sync_now_button.setEnabled(True)
            self.log_message(f"Authenticated with {provider}")
        else:
            self.auth_status.setText("Not authenticated")
            self.auth_status.setStyleSheet("color: red")
            self.sync_now_button.setEnabled(False)
    
    def start_sync(self):
        """Start synchronization"""
        try:
            if not self.sync_manager.active_provider:
                self.log_message("No cloud provider authenticated")
                return
            
            from PyQt5.QtWidgets import QFileDialog
            
            # Get local folder to sync
            local_folder = QFileDialog.getExistingDirectory(self, "Select folder to sync")
            if not local_folder:
                return
            
            # For simplicity, use root remote folder
            remote_folder = ""
            
            self.sync_progress.setVisible(True)
            self.sync_progress.setValue(0)
            self.sync_status_label.setText("Synchronizing...")
            self.log_message(f"Starting sync of {local_folder}")
            
            # Start sync in background (in real implementation, use QThread)
            def progress_callback(completed, total, message):
                progress = int((completed / total) * 100) if total > 0 else 0
                self.sync_progress.setValue(progress)
                self.log_message(message)
            
            self.sync_manager.sync_folder(local_folder, remote_folder, 'both', progress_callback)
            
            self.sync_progress.setVisible(False)
            self.sync_status_label.setText("Sync completed")
            self.log_message("Synchronization completed successfully")
            
        except Exception as e:
            self.sync_progress.setVisible(False)
            self.sync_status_label.setText("Sync failed")
            self.log_message(f"Sync error: {str(e)}")
    
    def pause_sync(self):
        """Pause synchronization"""
        self.log_message("Sync paused")
        self.sync_status_label.setText("Paused")
    
    def toggle_auto_sync(self, enabled):
        """Toggle automatic synchronization"""
        self.sync_manager.sync_config['auto_sync'] = enabled
        self.log_message(f"Auto-sync {'enabled' if enabled else 'disabled'}")
    
    def log_message(self, message):
        """Add message to sync log"""
        from datetime import datetime
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.sync_log.append(f"[{timestamp}] {message}")


class TagsWidget(QWidget):
    """Widget for managing file tags"""
    
    def __init__(self, tag_manager=None, parent=None):
        super().__init__(parent)
        self.tag_manager = tag_manager or TagManager()
        self.setup_ui()
        self.setup_connections()
        self.refresh_tags()
    
    def setup_ui(self):
        """Setup the tags UI"""
        from PyQt5.QtWidgets import (QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
                                     QLineEdit, QListWidget, QColorDialog, QInputDialog,
                                     QGroupBox, QListWidgetItem, QWidget)
        from PyQt5.QtCore import Qt
        from PyQt5.QtGui import QColor
        
        layout = QVBoxLayout()
        
        # Tag Management
        management_group = QGroupBox("Tag Management")
        management_layout = QVBoxLayout()
        
        # Create new tag
        create_layout = QHBoxLayout()
        self.new_tag_input = QLineEdit()
        self.new_tag_input.setPlaceholderText("Enter new tag name...")
        self.create_tag_button = QPushButton("Create Tag")
        self.tag_color_button = QPushButton("Color")
        self.tag_color_button.setStyleSheet("background-color: #4CAF50; color: white;")
        self.selected_color = "#4CAF50"
        
        create_layout.addWidget(self.new_tag_input)
        create_layout.addWidget(self.tag_color_button)
        create_layout.addWidget(self.create_tag_button)
        management_layout.addLayout(create_layout)
        
        management_group.setLayout(management_layout)
        layout.addWidget(management_group)
        
        # Tags List
        tags_group = QGroupBox("Available Tags")
        tags_layout = QVBoxLayout()
        
        self.tags_list = QListWidget()
        self.tags_list.setDragDropMode(QListWidget.DragOnly)
        tags_layout.addWidget(self.tags_list)
        
        # Tag actions
        actions_layout = QHBoxLayout()
        self.edit_tag_button = QPushButton("Edit")
        self.delete_tag_button = QPushButton("Delete")
        self.search_tag_button = QPushButton("Find Files")
        
        actions_layout.addWidget(self.edit_tag_button)
        actions_layout.addWidget(self.delete_tag_button)
        actions_layout.addWidget(self.search_tag_button)
        actions_layout.addStretch()
        tags_layout.addLayout(actions_layout)
        
        tags_group.setLayout(tags_layout)
        layout.addWidget(tags_group)
        
        # Quick Tag Panel
        quick_group = QGroupBox("Quick Tag")
        quick_layout = QVBoxLayout()
        
        self.quick_tag_input = QLineEdit()
        self.quick_tag_input.setPlaceholderText("Type tag name and press Enter to quick-tag selected files...")
        quick_layout.addWidget(self.quick_tag_input)
        
        quick_group.setLayout(quick_layout)
        layout.addWidget(quick_group)
        
        # Tag Statistics
        stats_group = QGroupBox("Tag Statistics")
        stats_layout = QVBoxLayout()
        
        self.stats_list = QListWidget()
        stats_layout.addWidget(self.stats_list)
        
        stats_group.setLayout(stats_layout)
        layout.addWidget(stats_group)
        
        self.setLayout(layout)
    
    def setup_connections(self):
        """Setup signal connections"""
        self.create_tag_button.clicked.connect(self.create_tag)
        self.tag_color_button.clicked.connect(self.select_tag_color)
        self.new_tag_input.returnPressed.connect(self.create_tag)
        self.quick_tag_input.returnPressed.connect(self.quick_tag_files)
        self.edit_tag_button.clicked.connect(self.edit_selected_tag)
        self.delete_tag_button.clicked.connect(self.delete_selected_tag)
        self.search_tag_button.clicked.connect(self.search_tag_files)
    
    def select_tag_color(self):
        """Select color for new tag"""
        from PyQt5.QtWidgets import QColorDialog
        from PyQt5.QtGui import QColor
        
        color = QColorDialog.getColor(QColor(self.selected_color), self, "Select Tag Color")
        if color.isValid():
            self.selected_color = color.name()
            self.tag_color_button.setStyleSheet(f"background-color: {self.selected_color}; color: white;")
    
    def create_tag(self):
        """Create a new tag"""
        tag_name = self.new_tag_input.text().strip()
        if tag_name:
            tag_id = self.tag_manager.create_tag(tag_name, self.selected_color)
            if tag_id:
                self.new_tag_input.clear()
                self.refresh_tags()
                self.refresh_statistics()
            else:
                # Show error message
                pass
    
    def refresh_tags(self):
        """Refresh the tags list"""
        self.tags_list.clear()
        tags = self.tag_manager.get_all_tags()
        
        for tag_id, name, color, description in tags:
            item = QListWidgetItem(name)
            item.setData(Qt.UserRole, tag_id)
            item.setToolTip(description or name)
            
            # Set tag color
            from PyQt5.QtGui import QColor
            item.setBackground(QColor(color))
            
            self.tags_list.addItem(item)
    
    def refresh_statistics(self):
        """Refresh tag statistics"""
        self.stats_list.clear()
        stats = self.tag_manager.get_tag_statistics()
        
        for tag_name, color, file_count in stats:
            item = QListWidgetItem(f"{tag_name} ({file_count} files)")
            from PyQt5.QtGui import QColor
            item.setBackground(QColor(color))
            self.stats_list.addItem(item)
    
    def quick_tag_files(self):
        """Quick tag selected files"""
        tag_name = self.quick_tag_input.text().strip()
        if tag_name:
            # This would integrate with the main file manager to tag selected files
            self.quick_tag_input.clear()
            # Emit signal or call parent method to tag selected files
            print(f"Quick tagging with: {tag_name}")
    
    def edit_selected_tag(self):
        """Edit the selected tag"""
        current_item = self.tags_list.currentItem()
        if current_item:
            from PyQt5.QtWidgets import QInputDialog
            
            old_name = current_item.text()
            new_name, ok = QInputDialog.getText(self, "Edit Tag", "Tag name:", text=old_name)
            
            if ok and new_name.strip():
                # Update tag in database
                self.refresh_tags()
    
    def delete_selected_tag(self):
        """Delete the selected tag"""
        current_item = self.tags_list.currentItem()
        if current_item:
            from PyQt5.QtWidgets import QMessageBox
            
            reply = QMessageBox.question(
                self, "Delete Tag", 
                f"Are you sure you want to delete the tag '{current_item.text()}'?",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                # Delete tag from database
                self.refresh_tags()
                self.refresh_statistics()
    
    def search_tag_files(self):
        """Search for files with selected tag"""
        current_item = self.tags_list.currentItem()
        if current_item:
            tag_name = current_item.text()
            files = self.tag_manager.search_files_by_tag(tag_name)
            
            # Show files in a dialog or emit signal to main window
            print(f"Files with tag '{tag_name}': {len(files)}")


class CollectionsWidget(QWidget):
    """Widget for managing file collections"""
    
    def __init__(self, collection_manager=None, parent=None):
        super().__init__(parent)
        if collection_manager:
            self.collection_manager = collection_manager
            self.tag_manager = collection_manager.tag_manager
        else:
            self.tag_manager = TagManager()
            self.collection_manager = CollectionManager(self.tag_manager)
        self.setup_ui()
        self.setup_connections()
        self.refresh_collections()
    
    def setup_ui(self):
        """Setup the collections UI"""
        from PyQt5.QtWidgets import (QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
                                     QLineEdit, QListWidget, QTextEdit, QGroupBox,
                                     QComboBox, QSplitter, QListWidgetItem)
        from PyQt5.QtCore import Qt
        
        layout = QVBoxLayout()
        
        # Collection Management
        management_group = QGroupBox("Collection Management")
        management_layout = QVBoxLayout()
        
        # Create new collection
        create_layout = QHBoxLayout()
        self.new_collection_input = QLineEdit()
        self.new_collection_input.setPlaceholderText("Enter collection name...")
        self.collection_type_combo = QComboBox()
        self.collection_type_combo.addItems(["Manual", "Smart"])
        self.create_collection_button = QPushButton("Create Collection")
        
        create_layout.addWidget(self.new_collection_input)
        create_layout.addWidget(self.collection_type_combo)
        create_layout.addWidget(self.create_collection_button)
        management_layout.addLayout(create_layout)
        
        # Smart collection query
        self.smart_query_input = QLineEdit()
        self.smart_query_input.setPlaceholderText("Smart collection query (e.g., tag:photos, rating:>=4)...")
        self.smart_query_input.setVisible(False)
        management_layout.addWidget(self.smart_query_input)
        
        management_group.setLayout(management_layout)
        layout.addWidget(management_group)
        
        # Collections List
        collections_group = QGroupBox("Collections")
        collections_layout = QVBoxLayout()
        
        self.collections_list = QListWidget()
        self.collections_list.setDragDropMode(QListWidget.DropOnly)
        collections_layout.addWidget(self.collections_list)
        
        # Collection actions
        actions_layout = QHBoxLayout()
        self.view_collection_button = QPushButton("View Files")
        self.edit_collection_button = QPushButton("Edit")
        self.delete_collection_button = QPushButton("Delete")
        
        actions_layout.addWidget(self.view_collection_button)
        actions_layout.addWidget(self.edit_collection_button)
        actions_layout.addWidget(self.delete_collection_button)
        actions_layout.addStretch()
        collections_layout.addLayout(actions_layout)
        
        collections_group.setLayout(collections_layout)
        layout.addWidget(collections_group)
        
        # Smart Collection Builder
        smart_group = QGroupBox("Smart Collection Builder")
        smart_layout = QVBoxLayout()
        
        builder_layout = QHBoxLayout()
        self.smart_type_combo = QComboBox()
        self.smart_type_combo.addItems(["Tag", "Rating", "Type", "Date", "Favorite"])
        self.smart_value_input = QLineEdit()
        self.add_criteria_button = QPushButton("Add Criteria")
        
        builder_layout.addWidget(QLabel("Type:"))
        builder_layout.addWidget(self.smart_type_combo)
        builder_layout.addWidget(QLabel("Value:"))
        builder_layout.addWidget(self.smart_value_input)
        builder_layout.addWidget(self.add_criteria_button)
        smart_layout.addLayout(builder_layout)
        
        self.criteria_list = QTextEdit()
        self.criteria_list.setMaximumHeight(80)
        self.criteria_list.setPlaceholderText("Smart collection criteria will appear here...")
        smart_layout.addWidget(self.criteria_list)
        
        smart_group.setLayout(smart_layout)
        layout.addWidget(smart_group)
        
        self.setLayout(layout)
    
    def setup_connections(self):
        """Setup signal connections"""
        self.create_collection_button.clicked.connect(self.create_collection)
        self.collection_type_combo.currentTextChanged.connect(self.on_collection_type_changed)
        self.new_collection_input.returnPressed.connect(self.create_collection)
        self.view_collection_button.clicked.connect(self.view_collection_files)
        self.add_criteria_button.clicked.connect(self.add_smart_criteria)
    
    def on_collection_type_changed(self, collection_type):
        """Handle collection type change"""
        is_smart = collection_type == "Smart"
        self.smart_query_input.setVisible(is_smart)
    
    def create_collection(self):
        """Create a new collection"""
        name = self.new_collection_input.text().strip()
        if not name:
            return
        
        collection_type = self.collection_type_combo.currentText().lower()
        
        if collection_type == "smart":
            query = self.smart_query_input.text().strip()
            if not query:
                query = self.criteria_list.toPlainText().strip()
            
            collection_id = self.collection_manager.create_smart_collection(name, query)
        else:
            collection_id = self.collection_manager.create_collection(name)
        
        if collection_id:
            self.new_collection_input.clear()
            self.smart_query_input.clear()
            self.refresh_collections()
    
    def refresh_collections(self):
        """Refresh the collections list"""
        self.collections_list.clear()
        collections = self.collection_manager.get_all_collections()
        
        for collection_id, name, description, color, coll_type, query, created_date in collections:
            display_text = f"{name}"
            if coll_type == "smart":
                display_text += " (Smart)"
            
            item = QListWidgetItem(display_text)
            item.setData(Qt.UserRole, collection_id)
            item.setToolTip(description or query or name)
            
            # Set collection color
            from PyQt5.QtGui import QColor
            item.setBackground(QColor(color))
            
            self.collections_list.addItem(item)
    
    def view_collection_files(self):
        """View files in selected collection"""
        current_item = self.collections_list.currentItem()
        if current_item:
            collection_id = current_item.data(Qt.UserRole)
            files = self.collection_manager.get_collection_files(collection_id)
            
            # Show files in a dialog or emit signal to main window
            print(f"Collection '{current_item.text()}' has {len(files)} files")
    
    def add_smart_criteria(self):
        """Add criteria to smart collection builder"""
        criteria_type = self.smart_type_combo.currentText().lower()
        value = self.smart_value_input.text().strip()
        
        if not value:
            return
        
        if criteria_type == "tag":
            query = SmartCollectionBuilder.build_tag_query(value)
        elif criteria_type == "rating":
            query = SmartCollectionBuilder.build_rating_query(">=", int(value))
        elif criteria_type == "type":
            query = SmartCollectionBuilder.build_type_query(value)
        elif criteria_type == "favorite":
            query = SmartCollectionBuilder.build_favorite_query()
        else:
            query = f"{criteria_type}:{value}"
        
        current_text = self.criteria_list.toPlainText()
        if current_text:
            self.criteria_list.setText(f"{current_text} AND {query}")
        else:
            self.criteria_list.setText(query)
        
        self.smart_value_input.clear()


class FileManagerTab(QWidget):
    def prompt_credentials(self, url, default_user='', default_pass=''):
        from PyQt5.QtCore import Qt
        from PyQt5.QtGui import QPalette
        class CredDialog(QDialog):
            def __init__(self, parent=None):
                super().__init__(parent)
                self.setWindowTitle('Enter Credentials')
                self.setWindowFlags(self.windowFlags() & ~Qt.WindowContextHelpButtonHint)
                self.setAttribute(Qt.WA_StyledBackground, True)
                self.setAttribute(Qt.WA_DontShowOnScreen, False)
                self.setAttribute(Qt.WA_NativeWindow, False)
                layout = QFormLayout(self)
                self.user = QLineEdit(default_user)
                self.pw = QLineEdit(default_pass)
                self.pw.setEchoMode(QLineEdit.Password)
                layout.addRow('Username:', self.user)
                layout.addRow('Password:', self.pw)
                buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
                buttons.accepted.connect(self.accept)
                buttons.rejected.connect(self.reject)
                layout.addWidget(buttons)

                # Always use PyQt dialog and apply dark mode if parent has it enabled
                dark_mode = False
                if parent and hasattr(parent, 'dark_mode'):
                    dark_mode = parent.dark_mode
                if dark_mode:
                    dark_palette = QPalette()
                    dark_palette.setColor(QPalette.Window, Qt.black)
                    dark_palette.setColor(QPalette.WindowText, Qt.white)
                    dark_palette.setColor(QPalette.Base, Qt.black)
                    dark_palette.setColor(QPalette.AlternateBase, Qt.black)
                    dark_palette.setColor(QPalette.ToolTipBase, Qt.white)
                    dark_palette.setColor(QPalette.ToolTipText, Qt.white)
                    dark_palette.setColor(QPalette.Text, Qt.white)
                    dark_palette.setColor(QPalette.Button, Qt.black)
                    dark_palette.setColor(QPalette.ButtonText, Qt.white)
                    dark_palette.setColor(QPalette.BrightText, Qt.red)
                    dark_palette.setColor(QPalette.Highlight, Qt.darkGray)
                    dark_palette.setColor(QPalette.HighlightedText, Qt.white)
                    self.setPalette(dark_palette)
                    dark_style = """
                    QDialog {
                        background-color: #232323;
                        color: #ffffff;
                    }
                    QLabel {
                        color: #ffffff;
                        background-color: transparent;
                    }
                    QLineEdit {
                        background-color: #2b2b2b;
                        color: #ffffff;
                        border: 1px solid #555555;
                    }
                    QDialogButtonBox QPushButton {
                        background-color: #404040;
                        color: #ffffff;
                        border: 1px solid #555555;
                        border-radius: 3px;
                        padding: 5px 15px;
                    }
                    QDialogButtonBox QPushButton:hover {
                        background-color: #4a4a4a;
                    }
                    QDialogButtonBox QPushButton:pressed {
                        background-color: #0078d7;
                    }
                    QDialogButtonBox QPushButton:default {
                        border: 2px solid #0078d7;
                    }
                    """
                    self.setStyleSheet(dark_style)
                else:
                    self.setStyleSheet("")
        dlg = CredDialog(self)
        if dlg.exec_() == QDialog.Accepted:
            return dlg.user.text(), dlg.pw.text()
        return None, None
    """Individual file manager tab"""
    
    def __init__(self, initial_path, tab_manager):
        super().__init__()
    # FileManagerTab.__init__ called
        # Preserve the initial path/sentinel for setup_tab_ui
        self.initial_dir = initial_path
        self.current_folder = initial_path
        self.tab_manager = tab_manager

        # Navigation history
        self.navigation_history = [initial_path]
        self.history_index = 0
        
        # Sorting options (per tab) - set defaults first
        self.sort_by = "name"  # name, size, date, type, extension
        self.sort_order = "ascending"  # ascending, descending
        self.directories_first = True
        self.case_sensitive = False
        self.group_by_type = False
        self.natural_sort = True  # Natural sorting for numbers in names
        
        # Load saved sort settings BEFORE setting up UI
        if self.tab_manager and self.tab_manager.main_window:
            self.tab_manager.main_window.load_tab_sort_settings(self)
        
        self.setup_tab_ui()
        
    def setup_tab_ui(self):
        """Setup the UI for this tab"""
        layout = QVBoxLayout()

    # Address bar removed: now only shown when clicking current folder in breadcrumb

        # Breadcrumb for this tab
        self.breadcrumb = BreadcrumbWidget()
        self.breadcrumb.pathClicked.connect(self.navigate_to)
        layout.addWidget(self.breadcrumb)

        # File view area
        self.view_stack = QStackedWidget()

        # Thumbnail view (was Icon view)
        self.setup_thumbnail_view()

        # List view
        self.setup_list_view()

        # Detail view
        self.setup_detail_view()

        layout.addWidget(self.view_stack)
        self.setLayout(layout)

        # Initialize with current folder, remote location, or My Computer drive list
        self.is_drive_list = False
        if isinstance(self.current_folder, str):
            if self.current_folder.startswith('ftp://'):
                self.browse_ftp(self.current_folder)
            elif self.current_folder.startswith('sftp://'):
                self.browse_sftp(self.current_folder)
            elif self.current_folder == "__MY_COMPUTER__":
                # Configure models to show connected drives only
                try:
                    self.is_drive_list = True
                    drives_filter = QDir.Drives | QDir.Dirs | QDir.NoDotAndDotDot

                    # Configure list model to show drives
                    self.list_model = FormattedFileSystemModel()
                    self.list_model.setFilter(drives_filter)
                    # Use empty rootPath so QFileSystemModel enumerates drives on Windows
                    try:
                        self.list_model.setRootPath("")
                        self.list_view.setModel(self.list_model)
                        self.list_view.setRootIndex(self.list_model.index(""))
                    except Exception:
                        # Fallback to QDir.rootPath()
                        self.list_model.setRootPath(QDir.rootPath())
                        self.list_view.setModel(self.list_model)
                        self.list_view.setRootIndex(self.list_model.index(QDir.rootPath()))

                    # Configure detail model similarly
                    self.detail_model = FormattedFileSystemModel()
                    self.detail_model.setFilter(drives_filter)
                    try:
                        self.detail_model.setRootPath("")
                        self.detail_view.setModel(self.detail_model)
                        self.detail_view.setRootIndex(self.detail_model.index(""))
                    except Exception:
                        self.detail_model.setRootPath(QDir.rootPath())
                        self.detail_view.setModel(self.detail_model)
                        self.detail_view.setRootIndex(self.detail_model.index(QDir.rootPath()))

                    # Update UI elements
                    if hasattr(self, 'address_bar'):
                        self.address_bar.setText("My Computer")
                    if hasattr(self, 'breadcrumb'):
                        try:
                            self.breadcrumb.set_path("My Computer")
                        except Exception:
                            pass
                    # Sync visible widget to the main window's current view mode so My Computer follows other tabs
                    try:
                        main_window = self.tab_manager.main_window if self.tab_manager else None
                        mode = None
                        if main_window and hasattr(main_window, 'view_mode_manager'):
                            mode = main_window.view_mode_manager.get_mode()
                        if mode == ViewModeManager.THUMBNAIL_VIEW:
                            # Thumbnail view - use thumbnail widget
                            try:
                                self.view_stack.setCurrentWidget(self.thumbnail_view_widget)
                            except Exception:
                                self.view_stack.setCurrentWidget(self.list_view)
                            try:
                                self.refresh_thumbnail_view()
                            except Exception:
                                pass
                        elif mode == ViewModeManager.ICON_VIEW:
                            # Icon view uses same widget as thumbnail but mark icon flag
                            try:
                                self.view_stack.setCurrentWidget(self.thumbnail_view_widget)
                                setattr(self, 'icon_view_active', True)
                            except Exception:
                                self.view_stack.setCurrentWidget(self.list_view)
                            try:
                                self.refresh_current_view()
                            except Exception:
                                pass
                        elif mode == ViewModeManager.LIST_VIEW:
                            try:
                                self.view_stack.setCurrentWidget(self.list_view)
                                self.refresh_list_view()
                            except Exception:
                                pass
                        elif mode == ViewModeManager.DETAIL_VIEW:
                            try:
                                self.view_stack.setCurrentWidget(self.detail_view)
                                self.refresh_detail_view()
                            except Exception:
                                pass
                        else:
                            # Default to list view
                            try:
                                self.view_stack.setCurrentWidget(self.list_view)
                                self.refresh_list_view()
                            except Exception:
                                pass

                    except Exception:
                        try:
                            self.view_stack.setCurrentWidget(self.list_view)
                        except Exception:
                            pass

                    # Update tab title
                    try:
                        if self.tab_manager:
                            self.tab_manager.update_tab_title(self, " My Computer ")
                    except Exception:
                        pass
                except Exception:
                    # Fall back to home if something goes wrong
                    self.navigate_to(os.path.expanduser("~"))
            else:
                self.navigate_to(self.current_folder)

    def show_my_computer(self):
        """Configure this tab to show connected drives (My Computer)"""
        try:
            self.is_drive_list = True
            # Mark current_folder as sentinel so navigation state is clear
            try:
                self.current_folder = "__MY_COMPUTER__"
            except Exception:
                pass
            drives_filter = QDir.Drives | QDir.Dirs | QDir.NoDotAndDotDot

            # List model
            self.list_model = FormattedFileSystemModel()
            self.list_model.setFilter(drives_filter)
            try:
                self.list_model.setRootPath("")
                self.list_view.setModel(self.list_model)
                self.list_view.setRootIndex(self.list_model.index(""))
            except Exception:
                self.list_model.setRootPath(QDir.rootPath())
                self.list_view.setModel(self.list_model)
                self.list_view.setRootIndex(self.list_model.index(QDir.rootPath()))

            # Detail model
            self.detail_model = FormattedFileSystemModel()
            self.detail_model.setFilter(drives_filter)
            try:
                self.detail_model.setRootPath("")
                self.detail_view.setModel(self.detail_model)
                self.detail_view.setRootIndex(self.detail_model.index(""))
            except Exception:
                self.detail_model.setRootPath(QDir.rootPath())
                self.detail_view.setModel(self.detail_model)
                self.detail_view.setRootIndex(self.detail_model.index(QDir.rootPath()))

            if hasattr(self, 'address_bar'):
                self.address_bar.setText("My Computer")
            if hasattr(self, 'breadcrumb'):
                try:
                    self.breadcrumb.set_path("My Computer")
                except Exception:
                    pass

            # Sync view mode
            try:
                main_window = self.tab_manager.main_window if self.tab_manager else None
                mode = None
                if main_window and hasattr(main_window, 'view_mode_manager'):
                    mode = main_window.view_mode_manager.get_mode()
                if mode == ViewModeManager.THUMBNAIL_VIEW:
                    try:
                        self.view_stack.setCurrentWidget(self.thumbnail_view_widget)
                    except Exception:
                        self.view_stack.setCurrentWidget(self.list_view)
                    try:
                        self.refresh_thumbnail_view()
                    except Exception:
                        pass
                elif mode == ViewModeManager.ICON_VIEW:
                    try:
                        self.view_stack.setCurrentWidget(self.thumbnail_view_widget)
                        setattr(self, 'icon_view_active', True)
                    except Exception:
                        self.view_stack.setCurrentWidget(self.list_view)
                    try:
                        self.refresh_current_view()
                    except Exception:
                        pass
                elif mode == ViewModeManager.LIST_VIEW:
                    try:
                        self.view_stack.setCurrentWidget(self.list_view)
                        self.refresh_list_view()
                    except Exception:
                        pass
                elif mode == ViewModeManager.DETAIL_VIEW:
                    try:
                        self.view_stack.setCurrentWidget(self.detail_view)
                        self.refresh_detail_view()
                    except Exception:
                        pass
                else:
                    try:
                        self.view_stack.setCurrentWidget(self.list_view)
                        self.refresh_list_view()
                    except Exception:
                        pass
            except Exception:
                try:
                    self.view_stack.setCurrentWidget(self.list_view)
                except Exception:
                    pass

            try:
                if self.tab_manager:
                    self.tab_manager.update_tab_title(self, " My Computer ")
            except Exception:
                pass
        except Exception:
            # As a safe fallback, navigate to user's home
            try:
                self.navigate_to(os.path.expanduser('~'))
            except Exception:
                pass

    def on_address_entered(self):
        path = self.address_bar.text().strip()
        if path.startswith('ftp://'):
            # Open FTP in a new tab
            if self.tab_manager:
                self.tab_manager.new_tab(path)
            return
        elif path.startswith('sftp://'):
            # Optionally, do the same for SFTP if desired
            if self.tab_manager:
                self.tab_manager.new_tab(path)
            return
        if os.path.isdir(path):
            self.navigate_to(path)
            self.address_bar.setStyleSheet("")
            self.address_bar.setToolTip("")
        else:
            self.address_bar.setStyleSheet("background-color: #ffcccc;")
            self.address_bar.setToolTip("Invalid directory path")

    def browse_ftp(self, url):
        # Parse ftp://[user[:pass]@]host[:port]/path
        match = re.match(r'ftp://(?:(?P<user>[^:@/]+)(?::(?P<passwd>[^@/]*))?@)?(?P<host>[^:/]+)(?::(?P<port>\\d+))?(?P<path>/.*)?', url)
        if not match:
            self.address_bar.setStyleSheet("background-color: #ffcccc;")
            self.address_bar.setToolTip("Invalid FTP address")
            return
        user = match.group('user') or ''
        passwd = match.group('passwd') or ''
        host = match.group('host')
        port = int(match.group('port')) if match.group('port') else 21
        path = match.group('path') or '/'
        if not user or not passwd:
            u, p = self.prompt_credentials(url, user, passwd)
            if u is None:
                return
            user, passwd = u, p
        try:
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=10)
            ftp.login(user, passwd)
            ftp.cwd(path)
            files = []
            ftp.retrlines('LIST', files.append)
            self.ftp_conn = ftp
            self.ftp_conn_url = url
            self.ftp_conn_path = path
            self.show_remote_listing(files, url, protocol='ftp')
            self.address_bar.setStyleSheet("")
            self.address_bar.setToolTip("")
        except Exception as e:
            self.address_bar.setStyleSheet("background-color: #ffcccc;")
            self.address_bar.setToolTip(f"FTP error: {e}")

    def browse_sftp(self, url):
        # Parse sftp://[user[:pass]@]host[:port]/path
        match = re.match(r'sftp://(?:(?P<user>[^:@/]+)(?::(?P<passwd>[^@/]*))?@)?(?P<host>[^:/]+)(?::(?P<port>\\d+))?(?P<path>/.*)?', url)
        if not match:
            self.address_bar.setStyleSheet("background-color: #ffcccc;")
            self.address_bar.setToolTip("Invalid SFTP address")
            return
        user = match.group('user') or ''
        passwd = match.group('passwd') or ''
        host = match.group('host')
        port = int(match.group('port')) if match.group('port') else 22
        path = match.group('path') or '/'
        if not user or not passwd:
            u, p = self.prompt_credentials(url, user, passwd)
            if u is None:
                return
            user, passwd = u, p
        try:
            transport = paramiko.Transport((host, port))
            transport.connect(username=user, password=passwd)
            sftp = paramiko.SFTPClient.from_transport(transport)
            files = sftp.listdir(path)
            self.sftp_conn = sftp
            self.sftp_conn_transport = transport
            self.sftp_conn_url = url
            self.sftp_conn_path = path
            self.show_remote_listing(files, url, protocol='sftp')
            self.address_bar.setStyleSheet("")
            self.address_bar.setToolTip("")
        except Exception as e:
            self.address_bar.setStyleSheet("background-color: #ffcccc;")
            self.address_bar.setToolTip(f"SFTP error: {e}")

    def show_remote_listing(self, files, url, protocol=None):
        # Replace file view with a simple list for remote files, with upload/download
        from PyQt5.QtWidgets import QListWidget, QVBoxLayout, QWidget, QLabel, QHBoxLayout
        remote_widget = QWidget()
        layout = QVBoxLayout()
        layout.addWidget(QLabel(f"Remote listing: {url}"))
        list_widget = QListWidget()
        for f in files:
            list_widget.addItem(str(f))
        layout.addWidget(list_widget)
        btn_layout = QHBoxLayout()
        download_btn = QPushButton('Download Selected')
        upload_btn = QPushButton('Upload File...')
        btn_layout.addWidget(download_btn)
        btn_layout.addWidget(upload_btn)
        layout.addLayout(btn_layout)
        remote_widget.setLayout(layout)
        self.view_stack.addWidget(remote_widget)
        self.view_stack.setCurrentWidget(remote_widget)

        def do_download():
            selected = list_widget.currentItem()
            if not selected:
                QMessageBox.warning(self, 'No selection', 'Select a file to download.')
                return
            fname = selected.text().split()[-1]  # crude, works for FTP LIST output or SFTP name
            file_dialog = QFileDialog(self, 'Save As')
            file_dialog.setAcceptMode(QFileDialog.AcceptSave)
            file_dialog.selectFile(fname)
            file_dialog.setOption(QFileDialog.DontUseNativeDialog, True)
            if file_dialog.exec_() == QFileDialog.Accepted:
                save_path = file_dialog.selectedFiles()[0]
            else:
                return
            try:
                if protocol == 'ftp':
                    with open(save_path, 'wb') as f:
                        self.ftp_conn.retrbinary(f'RETR {fname}', f.write)
                elif protocol == 'sftp':
                    self.sftp_conn.get(self.sftp_conn_path.rstrip('/') + '/' + fname, save_path)
                QMessageBox.information(self, 'Download', f'Downloaded {fname} to {save_path}')
            except Exception as e:
                QMessageBox.critical(self, 'Download Error', str(e))

        def do_upload():
            file_path, _ = QFileDialog.getOpenFileName(self, 'Select file to upload')
            if not file_path:
                return
            fname = os.path.basename(file_path)
            try:
                if protocol == 'ftp':
                    with open(file_path, 'rb') as f:
                        self.ftp_conn.storbinary(f'STOR {fname}', f)
                elif protocol == 'sftp':
                    self.sftp_conn.put(file_path, self.sftp_conn_path.rstrip('/') + '/' + fname)
                QMessageBox.information(self, 'Upload', f'Uploaded {fname} to remote folder')
            except Exception as e:
                QMessageBox.critical(self, 'Upload Error', str(e))

        download_btn.clicked.connect(do_download)
        upload_btn.clicked.connect(do_upload)

    def navigate_to(self, path, add_to_history=True):
        """Navigate to the specified path"""
        # Only save sort settings if we're actually changing folders
        if hasattr(self, 'current_folder') and self.current_folder != path:
            if hasattr(self, 'tab_manager') and self.tab_manager and hasattr(self.tab_manager, 'main_window'):
                self.tab_manager.main_window.save_tab_sort_settings(self)

        # Ensure path is a string
        if not isinstance(path, str):
            return

        # Special sentinel: show My Computer (drive list)
        if path == "__MY_COMPUTER__":
            try:
                self.show_my_computer()
                # Optionally add sentinel to navigation history so forward/back
                # navigation will work across My Computer entries.
                if add_to_history:
                    try:
                        # Trim any forward history when navigating to a new location
                        self.navigation_history = self.navigation_history[:self.history_index + 1]
                    except Exception:
                        self.navigation_history = getattr(self, 'navigation_history', [])
                        self.history_index = getattr(self, 'history_index', -1)
                    if not self.navigation_history or self.navigation_history[-1] != path:
                        self.navigation_history.append(path)
                        self.history_index = len(self.navigation_history) - 1
                return
            except Exception:
                # If show_my_computer fails, fall back to home
                try:
                    self.navigate_to(os.path.expanduser("~"))
                except Exception:
                    pass
                return

        if os.path.exists(path) and os.path.isdir(path):
            # If we were showing the drive list (My Computer), switch back to normal
            # filesystem models so the directory loads correctly in this tab.
            try:
                if getattr(self, 'is_drive_list', False):
                    self.is_drive_list = False
                    # Recreate normal filesystem models for listing and details
                    self.list_model = FormattedFileSystemModel()
                    self.list_view.setModel(self.list_model)
                    self.detail_model = FormattedFileSystemModel()
                    self.detail_view.setModel(self.detail_model)
            except Exception:
                pass
            self.current_folder = path
            self.breadcrumb.set_path(path)
            if hasattr(self, 'address_bar'):
                self.address_bar.setText(path)
                self.address_bar.setStyleSheet("")
                self.address_bar.setToolTip("")

            # Load sort settings for the new folder
            if hasattr(self, 'tab_manager') and self.tab_manager and hasattr(self.tab_manager, 'main_window'):
                self.tab_manager.main_window.load_tab_sort_settings(self)

            self.refresh_current_view()

            # Register directory with background monitor to auto-refresh on changes
            try:
                if hasattr(self, 'tab_manager') and self.tab_manager and hasattr(self.tab_manager, 'main_window'):
                    main = self.tab_manager.main_window
                    if hasattr(main, 'background_monitor') and main.background_monitor:
                        # Remove previous directory if any
                        try:
                            prev = getattr(self, '_monitored_directory', None)
                            if prev and prev != path:
                                main.background_monitor.remove_directory(prev)
                        except Exception:
                            pass
                        # Add new directory monitor and refresh tab when change detected
                        def _on_dir_changed(d):
                            try:
                                self.refresh_current_view()
                            except Exception:
                                pass
                        main.background_monitor.add_directory(path, _on_dir_changed)
                        self._monitored_directory = path
            except Exception:
                pass

            # Add to navigation history if this is a new navigation (not back/forward)
            if add_to_history:
                # Remove any forward history if we're navigating to a new location
                self.navigation_history = self.navigation_history[:self.history_index + 1]
                # Add new path if it's different from current
                if not self.navigation_history or self.navigation_history[-1] != path:
                    self.navigation_history.append(path)
                    self.history_index = len(self.navigation_history) - 1

            # Update tab title with underscore wrapping and padding
            title = os.path.basename(path) or os.path.dirname(path) or "Home"
            # Handle drive letters properly (e.g., "C:" instead of empty string)
            if not title and path and len(path) >= 2 and path[1] == ':':
                title = path[:2]  # Use drive letter like "C:"
            elif not title:
                title = "Home"
            formatted_title = format_filename_with_underscore_wrap(title)
            padded_title = f" {formatted_title} "  # Add padding spaces
            if hasattr(self, 'tab_manager') and self.tab_manager:
                self.tab_manager.update_tab_title(self, padded_title)
        else:
            if hasattr(self, 'address_bar'):
                self.address_bar.setStyleSheet("background-color: #ffcccc;")
                self.address_bar.setToolTip("Invalid directory path")
        
    def setup_thumbnail_view(self):
        """Setup thumbnail view for this tab (replaces icon view)"""
        self.thumbnail_view_widget = QWidget()
        icon_layout = QVBoxLayout()
        icon_layout.setContentsMargins(0, 0, 0, 0)

        # Scroll area to contain the thumbnail grid
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Icon container (grid of IconWidget instances) - keep class name for compatibility
        self.icon_container = IconContainer()
        self.icon_container.setAcceptDrops(True)
        self.icon_container.setMouseTracking(True)
        self.scroll_area.setWidget(self.icon_container)

        # Optionally the main window can install an event filter on the viewport
        # self.scroll_area.viewport().installEventFilter(self)

        icon_layout.addWidget(self.scroll_area)
        self.thumbnail_view_widget.setLayout(icon_layout)
        self.view_stack.addWidget(self.thumbnail_view_widget)

        # Set thumbnail view as default
        self.view_stack.setCurrentWidget(self.thumbnail_view_widget)
    
    def setup_list_view(self):
        """Setup list view for this tab"""
        self.list_view = QListView()
        self.list_model = FormattedFileSystemModel()
        self.list_view.setModel(self.list_model)
        # Enable word wrapping for long names with underscores
        self.list_view.setWordWrap(True)
        # Set custom delegate for proper word wrapping with zero-width spaces
        self.list_view.setItemDelegate(WordWrapDelegate())

        # Connect list view events
        self.list_view.clicked.connect(self.on_list_item_clicked)
        self.list_view.doubleClicked.connect(self.on_list_item_double_clicked)

        self.view_stack.addWidget(self.list_view)
    
    def setup_detail_view(self):
        """Setup detail view for this tab"""
        self.detail_view = QTableView()
        self.detail_model = FormattedFileSystemModel()
        self.detail_view.setModel(self.detail_model)
        # Enable word wrapping for long names with underscores
        self.detail_view.setWordWrap(True)
        # Set custom delegate for proper word wrapping with zero-width spaces
        self.detail_view.setItemDelegate(WordWrapDelegate())
        # Connect detail view events
        self.detail_view.clicked.connect(self.on_detail_item_clicked)
        self.detail_view.doubleClicked.connect(self.on_detail_item_double_clicked)
        
        self.view_stack.addWidget(self.detail_view)
    
    def on_list_item_clicked(self, index):
        """Handle list view item clicks"""
        if index.isValid():
            file_path = self.list_model.filePath(index)
            # If this tab is a My Computer drive-list and a drive was clicked, open it immediately
            try:
                if getattr(self, 'is_drive_list', False):
                    # Reset drive-list flag so tab behaves like a normal folder tab
                    self.is_drive_list = False
                    # Recreate models for normal listing
                    self.list_model = FormattedFileSystemModel()
                    self.list_view.setModel(self.list_model)
                    self.detail_model = FormattedFileSystemModel()
                    self.detail_view.setModel(self.detail_model)
                    # Navigate into the clicked drive
                    if os.path.isdir(file_path):
                        self.navigate_to(file_path)
                        return
            except Exception:
                pass
            # Update preview pane if main window has one
            if hasattr(self.tab_manager, 'main_window') and hasattr(self.tab_manager.main_window, 'preview_pane'):
                self.tab_manager.main_window.preview_pane.preview_file(file_path)
            # Update selection
            if hasattr(self.tab_manager, 'main_window'):
                self.tab_manager.main_window.selected_items = [file_path]
                if hasattr(self.tab_manager.main_window, 'safe_update_status_bar'):
                    self.tab_manager.main_window.safe_update_status_bar()

    def on_list_item_double_clicked(self, index):
        """Handle list view double clicks"""
        if index.isValid():
            try:
                file_path = self.list_model.filePath(index)
            except Exception:
                file_path = '<error>'
            try:
                # placeholder - on_list_item_double_clicked
                _ = None
            except Exception:
                pass
            # If we are in My Computer drive-list mode and a drive was double-clicked, open it
            try:
                if getattr(self, 'is_drive_list', False):
                    self.is_drive_list = False
                    self.list_model = FormattedFileSystemModel()
                    self.list_view.setModel(self.list_model)
                    self.detail_model = FormattedFileSystemModel()
                    self.detail_view.setModel(self.detail_model)
                    if os.path.isdir(file_path):
                        self.navigate_to(file_path)
                        return
            except Exception:
                pass
            self.handle_double_click(file_path)

    def on_detail_item_clicked(self, index):
        """Handle detail view item clicks"""
        if index.isValid():
            file_path = self.detail_model.filePath(index)
            # Similar behavior for detail view when in My Computer drive-list
            try:
                if getattr(self, 'is_drive_list', False):
                    self.is_drive_list = False
                    self.list_model = FormattedFileSystemModel()
                    self.list_view.setModel(self.list_model)
                    self.detail_model = FormattedFileSystemModel()
                    self.detail_view.setModel(self.detail_model)
                    if os.path.isdir(file_path):
                        self.navigate_to(file_path)
                        return
            except Exception:
                pass
            # Update preview pane if main window has one
            if hasattr(self.tab_manager, 'main_window') and hasattr(self.tab_manager.main_window, 'preview_pane'):
                self.tab_manager.main_window.preview_pane.preview_file(file_path)
            # Update selection
            if hasattr(self.tab_manager, 'main_window'):
                self.tab_manager.main_window.selected_items = [file_path]
                if hasattr(self.tab_manager.main_window, 'safe_update_status_bar'):
                    self.tab_manager.main_window.safe_update_status_bar()

    def on_detail_item_double_clicked(self, index):
        """Handle detail view double clicks"""
        if index.isValid():
            try:
                file_path = self.detail_model.filePath(index)
                if not file_path:
                    try:
                        root = self.detail_model.rootPath() or ""
                        name = index.data(Qt.DisplayRole) or index.data()
                        file_path = os.path.join(root, name) if root else name
                    except Exception:
                        file_path = '<error>'
            except Exception:
                file_path = '<error>'
            try:
                # placeholder - on_detail_item_double_clicked
                _ = None
            except Exception:
                pass
            # If in My Computer drive-list mode, open drive on double click
            try:
                if getattr(self, 'is_drive_list', False):
                    self.is_drive_list = False
                    self.list_model = FormattedFileSystemModel()
                    self.list_view.setModel(self.list_model)
                    self.detail_model = FormattedFileSystemModel()
                    self.detail_view.setModel(self.detail_model)
                    if isinstance(file_path, str) and os.path.isdir(file_path):
                        self.navigate_to(file_path)
                        return
            except Exception:
                pass
            self.handle_double_click(file_path)
    
    # Removed duplicate/old navigate_to method to ensure only the correct one is used
    
    def can_go_back(self):
        """Check if we can go back in history"""
        return self.history_index > 0
    
    def can_go_forward(self):
        """Check if we can go forward in history"""
        return self.history_index < len(self.navigation_history) - 1
    
    def go_back(self):
        """Navigate back in history"""
        if self.can_go_back():
            self.history_index -= 1
            path = self.navigation_history[self.history_index]
            # If the history entry is the My Computer sentinel, show drives
            if isinstance(path, str) and path == "__MY_COMPUTER__":
                try:
                    self.show_my_computer()
                    try:
                        self.current_folder = "__MY_COMPUTER__"
                    except Exception:
                        pass
                    # Do not add the sentinel to normal history when restoring
                except Exception:
                    # fallback to normal navigate behavior
                    self.navigate_to(path, add_to_history=False)
                if hasattr(self, 'address_bar'):
                    # Show a friendly label for the sentinel in the address bar
                    try:
                        self.address_bar.setText('My Computer')
                    except Exception:
                        pass
                return

            # Default behavior for filesystem paths
            self.navigate_to(path, add_to_history=False)
            if hasattr(self, 'address_bar'):
                self.address_bar.setText(path)
    
    def go_forward(self):
        """Navigate forward in history"""
        if self.can_go_forward():
            self.history_index += 1
            path = self.navigation_history[self.history_index]
            # If the forward entry is the My Computer sentinel, show drives
            if isinstance(path, str) and path == "__MY_COMPUTER__":
                try:
                    self.show_my_computer()
                    try:
                        self.current_folder = "__MY_COMPUTER__"
                    except Exception:
                        pass
                    if hasattr(self, 'address_bar'):
                        try:
                            self.address_bar.setText('My Computer')
                        except Exception:
                            pass
                except Exception:
                    # Fallback to normal navigation if show_my_computer fails
                    self.navigate_to(path, add_to_history=False)
                return

            # Default behavior for filesystem paths
            self.navigate_to(path, add_to_history=False)
            if hasattr(self, 'address_bar'):
                self.address_bar.setText(path)
    
    def sort_items(self, items, folder_path):
        """Sort items according to current tab's sort settings"""
        import re
        
        def natural_sort_key(text):
            """Convert a string to a list of mixed strings and numbers for natural sorting"""
            if not self.natural_sort:
                return text.lower() if not self.case_sensitive else text
                
            # Split string into chunks of letters and numbers
            chunks = re.split(r'(\d+)', text)
            # Convert number chunks to integers for proper sorting
            for i in range(len(chunks)):
                if chunks[i].isdigit():
                    chunks[i] = int(chunks[i])
                else:
                    chunks[i] = chunks[i].lower() if not self.case_sensitive else chunks[i]
            return chunks
        
        def get_sort_key(item_name):
            """Get the sort key for an item based on current sort settings"""
            full_path = os.path.join(folder_path, item_name)
            is_dir = os.path.isdir(full_path)
            
            # Primary sort: directories first if enabled
            primary_key = not is_dir if self.directories_first else 0
            
            # Secondary sort: by group type if enabled
            secondary_key = ""
            if self.group_by_type and not is_dir:
                extension = os.path.splitext(item_name)[1].lower()
                # Group by file type categories
                if extension in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp']:
                    secondary_key = "1_images"
                elif extension in ['.txt', '.pdf', '.doc', '.docx', '.rtf', '.odt']:
                    secondary_key = "2_documents"
                elif extension in ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm']:
                    secondary_key = "3_videos"
                elif extension in ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma']:
                    secondary_key = "4_audio"
                elif extension in ['.py', '.js', '.html', '.css', '.cpp', '.java', '.c']:
                    secondary_key = "5_code"
                elif extension in ['.zip', '.rar', '.7z', '.tar', '.gz']:
                    secondary_key = "6_archives"
                else:
                    secondary_key = "7_other"
            
            # Tertiary sort: by the selected criteria
            tertiary_key = None
            try:
                if self.sort_by == "name":
                    tertiary_key = natural_sort_key(item_name)
                elif self.sort_by == "size":
                    if is_dir:
                        # For directories, use 0 size or count of items
                        try:
                            tertiary_key = len(os.listdir(full_path))
                        except:
                            tertiary_key = 0
                    else:
                        tertiary_key = os.path.getsize(full_path)
                elif self.sort_by == "date":
                    tertiary_key = os.path.getmtime(full_path)
                elif self.sort_by == "type":
                    if is_dir:
                        tertiary_key = "0_directory"  # Directories first in type sort
                    else:
                        extension = os.path.splitext(item_name)[1].lower()
                        tertiary_key = f"1_{extension}" if extension else "1_no_extension"
                elif self.sort_by == "extension":
                    if is_dir:
                        tertiary_key = ""
                    else:
                        extension = os.path.splitext(item_name)[1].lower()
                        tertiary_key = extension[1:] if extension else "zzz_no_extension"
                        if not self.case_sensitive:
                            tertiary_key = tertiary_key.lower()
                else:
                    tertiary_key = natural_sort_key(item_name)
            except (OSError, IOError):
                # If we can't get file info, fall back to name sorting
                tertiary_key = natural_sort_key(item_name)
            
            return (primary_key, secondary_key, tertiary_key)
        
        # Sort items
        sorted_items = sorted(items, key=get_sort_key)
        
        # Reverse if descending order
        if self.sort_order == "descending":
            sorted_items.reverse()
            
        return sorted_items

    def refresh_current_view(self):
        """Refresh the current view with files from current folder"""
        # This will be implemented based on the current view mode
        if self.view_stack.currentWidget() == self.thumbnail_view_widget:
            self.refresh_thumbnail_view()
        elif self.view_stack.currentWidget() == self.list_view:
            self.refresh_list_view()
        elif self.view_stack.currentWidget() == self.detail_view:
            self.refresh_detail_view()
    
    def refresh_thumbnail_view(self):
        """Refresh thumbnail view with current folder contents"""
        # Get settings from main window using direct reference
        main_window = self.tab_manager.main_window if self.tab_manager else None
        thumbnail_size = getattr(main_window, 'thumbnail_size', 64) if main_window else 64
        icons_wide = getattr(main_window, 'icons_wide', 0) if main_window else 0

        # If this tab is a My Computer drive-list, render connected drives instead
        if getattr(self, 'is_drive_list', False):
            try:
                icon_container = self.get_icon_container_safely()
                if not icon_container:
                    return
                layout = icon_container.layout()
                for i in reversed(range(layout.count())):
                    child = layout.itemAt(i).widget()
                    if child:
                        child.setParent(None)

                from PyQt5.QtCore import QDir
                # --- List drives first ---
                drives = QDir.drives()
                for d in drives:
                    try:
                        drive_path = d.absolutePath()
                        drive_name = drive_path
                        is_dir = True
                        icon_widget = IconWidget(drive_name, drive_path, is_dir, thumbnail_size, getattr(main_window, 'thumbnail_cache', None), use_icon_only=getattr(self, 'icon_view_active', False))
                        def _drv_dd(p, tab=self):
                            try:
                                if getattr(tab, 'is_drive_list', False) and isinstance(p, str) and os.path.isdir(p):
                                    tab.is_drive_list = False
                                    tab.list_model = FormattedFileSystemModel()
                                    tab.list_view.setModel(tab.list_model)
                                    tab.detail_model = FormattedFileSystemModel()
                                    tab.detail_view.setModel(tab.detail_model)
                                    tab.navigate_to(p)
                                    return
                                tab.handle_double_click(p)
                            except Exception:
                                pass
                        icon_widget.doubleClicked.connect(_drv_dd)
                        if self.tab_manager and self.tab_manager.main_window:
                            mw = self.tab_manager.main_window
                            icon_widget.clicked.connect(mw.icon_clicked)
                            icon_widget.rightClicked.connect(mw.icon_right_clicked)
                        icon_container.add_widget_optimized(icon_widget, thumbnail_size, icons_wide)
                    except Exception:
                        pass

                # --- Then add standard user folders (including Music) ---
                std_folders = [
                    ("Desktop", PlatformUtils.get_desktop_directory()),
                    ("Documents", PlatformUtils.get_documents_directory()),
                    ("Downloads", PlatformUtils.get_downloads_directory()),
                    ("Music", PlatformUtils.get_music_directory()),
                    ("Pictures", PlatformUtils.get_pictures_directory()),
                    ("Videos", PlatformUtils.get_videos_directory()),
                ]
                for label, folder_path in std_folders:
                    try:
                        if folder_path and os.path.exists(folder_path):
                            icon_widget = IconWidget(label, folder_path, True, thumbnail_size, getattr(main_window, 'thumbnail_cache', None), use_icon_only=getattr(self, 'icon_view_active', False))
                            def _std_dd(p, tab=self):
                                try:
                                    tab.is_drive_list = False
                                    tab.list_model = FormattedFileSystemModel()
                                    tab.list_view.setModel(tab.list_model)
                                    tab.detail_model = FormattedFileSystemModel()
                                    tab.detail_view.setModel(tab.detail_model)
                                    tab.navigate_to(p)
                                except Exception:
                                    pass
                            icon_widget.doubleClicked.connect(_std_dd)
                            if self.tab_manager and self.tab_manager.main_window:
                                mw = self.tab_manager.main_window
                                icon_widget.clicked.connect(mw.icon_clicked)
                                icon_widget.rightClicked.connect(mw.icon_right_clicked)
                            icon_container.add_widget_optimized(icon_widget, thumbnail_size, icons_wide)
                    except Exception:
                        pass

                layout.update()
                icon_container.update()
            except Exception:
                pass
            return

        # Pre-cache thumbnails for text and PDF files in the current folder for the current icon size only
        thumbnail_debug('Checking if main_window and thumbnail_cache exist for pre-caching in {}', self.current_folder)
        # Only precache thumbnails when not in Icon View (icon-only mode)
        try:
            in_icon_view = False
            if hasattr(main_window, 'icon_view_active'):
                in_icon_view = bool(main_window.icon_view_active)
            elif hasattr(main_window, 'view_mode_manager'):
                in_icon_view = (main_window.view_mode_manager.get_mode() == ViewModeManager.ICON_VIEW)
        except Exception:
            in_icon_view = False

        def after_thumbnailing():
            # Clear existing icons
            icon_container = self.get_icon_container_safely()
            if not icon_container:
                return  # Cannot refresh icons without icon_container
            layout = icon_container.layout()
            for i in reversed(range(layout.count())):
                child = layout.itemAt(i).widget()
                if child:
                    child.setParent(None)
            # Force layout update after clearing
            layout.update()
            icon_container.update()
            # Check if directory is large and use virtual loading if needed
            try:
                if main_window and hasattr(main_window, 'virtual_file_loader') and main_window.virtual_file_loader:
                    # Count items first to decide on loading strategy
                    item_count = len([name for name in os.listdir(self.current_folder) 
                                    if not name.startswith('.')])
                    if item_count > 1000:  # Use virtual loading for large directories
                        # Use virtual file loader for large directories
                        main_window.virtual_file_loader.load_directory_async(
                            self.current_folder,
                            lambda chunk, is_final: self._add_icons_chunk(chunk, is_final, thumbnail_size, icons_wide, main_window),
                            sort_func=lambda items: self.sort_items(items, self.current_folder)
                        )
                        return
                # Standard loading for smaller directories
                self._load_icons_standard(thumbnail_size, icons_wide, main_window)
            except PermissionError:
                pass

        if not in_icon_view and main_window and hasattr(main_window, 'thumbnail_cache') and main_window.thumbnail_cache:
            thumbnail_debug('About to call precache_text_pdf_thumbnails_in_directory for {} size={}', self.current_folder, thumbnail_size)
            try:
                precache_text_pdf_thumbnails_in_directory(
                    self.current_folder,
                    main_window.thumbnail_cache,
                    size=thumbnail_size,
                    on_complete=after_thumbnailing,
                    parent=main_window,
                    show_progress=True
                )
                thumbnail_debug('Finished call to precache_text_pdf_thumbnails_in_directory for {}', self.current_folder)
            except Exception as e:
                thumbnail_error('Exception in precache_text_pdf_thumbnails_in_directory: {}', e)
            return  # Only refresh after thumbnailing completes

        # If not thumbnailing, just refresh immediately
        after_thumbnailing()

        # Clear existing icons
        icon_container = self.get_icon_container_safely()
        if not icon_container:
            return  # Cannot refresh icons without icon_container
            
        layout = icon_container.layout()
        for i in reversed(range(layout.count())):
            child = layout.itemAt(i).widget()
            if child:
                child.setParent(None)
        
        # Force layout update after clearing
        layout.update()
        icon_container.update()
        
    # Check if directory is large and use virtual loading if needed
        try:
            if main_window and hasattr(main_window, 'virtual_file_loader') and main_window.virtual_file_loader:
                # Count items first to decide on loading strategy
                item_count = len([name for name in os.listdir(self.current_folder) 
                                if not name.startswith('.')])
                
                if item_count > 1000:  # Use virtual loading for large directories
                    # Use virtual file loader for large directories
                    main_window.virtual_file_loader.load_directory_async(
                        self.current_folder,
                        lambda chunk, is_final: self._add_icons_chunk(chunk, is_final, thumbnail_size, icons_wide, main_window),
                        sort_func=lambda items: self.sort_items(items, self.current_folder)
                    )
                    return
            
            # Standard loading for smaller directories
            self._load_icons_standard(thumbnail_size, icons_wide, main_window)
            
        except PermissionError:
            # Handle permission errors gracefully
            # ...removed thumbnail debug message...
            pass
    
    def _load_icons_standard(self, thumbnail_size, icons_wide, main_window):
        """Standard icon loading for smaller directories"""
        icon_container = self.get_icon_container_safely()
        if not icon_container:
            return  # Cannot load icons without icon_container
            
        items = os.listdir(self.current_folder)
        # If we're at the user's home or the filesystem root, show standard folders first
        try:
            home_dir = os.path.expanduser('~')
            cur_abs = os.path.abspath(self.current_folder)
            root_abs = os.path.abspath(os.sep)
            if cur_abs == os.path.abspath(home_dir) or cur_abs == root_abs:
                std_names = ['Desktop', 'Documents', 'Downloads', 'Pictures', 'Music', 'Videos']
                prepend = []
                for name in std_names:
                    candidate = os.path.join(home_dir, name)
                    # If the candidate exists and isn't already listed, show it first
                    if os.path.exists(candidate):
                        base = os.path.basename(candidate)
                        if base not in items:
                            prepend.append(base)
                # Prepend in reverse order so Desktop ends up first
                if prepend:
                    items = prepend + items
        except Exception:
            # Don't block listing if this logic fails
            pass
        
        # Use advanced sorting
        sorted_items = self.sort_items(items, self.current_folder)
        
        for item in sorted_items:
            self._create_and_add_icon(item, thumbnail_size, icons_wide, main_window)
        
        # Force layout update after adding widgets
        layout = icon_container.layout()
        layout.update()
        icon_container.update()
        icon_container.updateGeometry()
    
    def _add_icons_chunk(self, items_chunk, is_final, thumbnail_size, icons_wide, main_window):
        """Add a chunk of icons to the view (for virtual loading)"""
        icon_container = self.get_icon_container_safely()
        if not icon_container:
            return  # Cannot add icons without icon_container
            
        for item in items_chunk:
            self._create_and_add_icon(item, thumbnail_size, icons_wide, main_window)
        
        if is_final:
            # Force layout update after adding final chunk
            layout = icon_container.layout()
            layout.update()
            icon_container.update()
            icon_container.updateGeometry()
    
    def _create_and_add_icon(self, item, thumbnail_size, icons_wide, main_window):
        """Create and add a single icon widget"""
        icon_container = self.get_icon_container_safely()
        if not icon_container:
            return  # Cannot add icons without icon_container
            
        item_path = os.path.join(self.current_folder, item)
        is_dir = os.path.isdir(item_path)
        
        # Decide effective icon-only mode for this item. This combines:
        # - per-tab runtime flag (self.icon_view_active)
        # - main window view mode (ViewModeManager.ICON_VIEW)
        # - persisted user preference (main_window.icon_view_use_icons_only)
        effective_icon_only = False
        detected_mode = None
        try:
            if main_window and hasattr(main_window, 'view_mode_manager'):
                detected_mode = main_window.view_mode_manager.get_mode()

            # Are we in an icon view (either per-tab or main window mode)?
            in_icon_mode = False
            if hasattr(self, 'icon_view_active') and getattr(self, 'icon_view_active', False):
                in_icon_mode = True
            elif detected_mode == ViewModeManager.ICON_VIEW:
                in_icon_mode = True

            if in_icon_mode:
                # Respect persisted preference on the main window (default: True)
                pref = True
                if main_window and hasattr(main_window, 'icon_view_use_icons_only'):
                    pref = bool(main_window.icon_view_use_icons_only)
                effective_icon_only = bool(pref)
        except Exception:
            effective_icon_only = False

        # If we're not in effective icon-only mode and a thumbnail cache exists, provide it.
        if not effective_icon_only and main_window and hasattr(main_window, 'thumbnail_cache') and main_window.thumbnail_cache:
            icon_widget = IconWidget(item, item_path, is_dir, thumbnail_size, main_window.thumbnail_cache, use_icon_only=False)
        else:
            # If in icon-only mode, don't provide a thumbnail cache so IconWidget won't load thumbnails
            icon_widget = IconWidget(item, item_path, is_dir, thumbnail_size, None, use_icon_only=effective_icon_only)
            
        icon_widget.doubleClicked.connect(self.handle_double_click)
        
        # Connect to main window handlers through tab manager
        if self.tab_manager and self.tab_manager.main_window:
            main_window = self.tab_manager.main_window
            icon_widget.clicked.connect(main_window.icon_clicked)
            icon_widget.rightClicked.connect(main_window.icon_right_clicked)
        
        # Use the optimized layout from main window
        icon_container.add_widget_optimized(icon_widget, thumbnail_size, icons_wide)

    def refresh_list_view(self):
        """Refresh list view"""
        # If this tab shows drives, use the model root to enumerate drives rather than a folder path
        if getattr(self, 'is_drive_list', False):
            try:
                self.list_model.setRootPath("")
                self.list_view.setModel(self.list_model)
                self.list_view.setRootIndex(self.list_model.index(""))
            except Exception:
                self.list_model.setRootPath(QDir.rootPath())
                self.list_view.setRootIndex(self.list_model.index(QDir.rootPath()))
            return

        self.list_model.setRootPath(self.current_folder)
        self.list_view.setRootIndex(self.list_model.index(self.current_folder))
    
    def refresh_detail_view(self):
        """Refresh detail view"""
        # If this tab shows drives, set the detail model root to enumerate drives
        if getattr(self, 'is_drive_list', False):
            try:
                self.detail_model.setRootPath("")
                self.detail_view.setModel(self.detail_model)
                self.detail_view.setRootIndex(self.detail_model.index(""))
            except Exception:
                self.detail_model.setRootPath(QDir.rootPath())
                self.detail_view.setRootIndex(self.detail_model.index(QDir.rootPath()))
            return

        self.detail_model.setRootPath(self.current_folder)
        self.detail_view.setRootIndex(self.detail_model.index(self.current_folder))
    
    def resizeEvent(self, event):
        """Handle tab resize events to trigger auto-width recalculation"""
        super().resizeEvent(event)
        
        # If we're in auto-width mode, trigger a relayout of the icon container
        main_window = self.tab_manager.main_window if self.tab_manager else None
        if main_window and getattr(main_window, 'icons_wide', 0) == 0:
            # Get the current view's icon container safely
            icon_container = self.get_icon_container_safely()
            if icon_container:
                # Use a timer to prevent excessive relayout calls during resize
                if not hasattr(self, '_tab_resize_timer'):
                    from PyQt5.QtCore import QTimer
                    self._tab_resize_timer = QTimer()
                    self._tab_resize_timer.setSingleShot(True)
                    self._tab_resize_timer.timeout.connect(lambda: self.get_icon_container_safely() and self.get_icon_container_safely().relayout_icons())
                
                self._tab_resize_timer.stop()
                self._tab_resize_timer.start(150)  # Delay 150ms before relayout
    
    def eventFilter(self, obj, event):
        """Handle events from child widgets, specifically scroll area viewport resizes"""
        if (obj == getattr(self, 'scroll_area', None) or 
            obj == getattr(getattr(self, 'scroll_area', None), 'viewport', lambda: None)()):
            if event.type() == QEvent.Resize:
                # Viewport was resized, trigger auto-width recalculation if needed
                main_window = self.tab_manager.main_window if self.tab_manager else None
                if main_window and getattr(main_window, 'icons_wide', 0) == 0:
                    icon_container = self.get_icon_container_safely()
                    if icon_container:
                        # Use a shorter delay for viewport resize events
                        if not hasattr(self, '_viewport_resize_timer'):
                            from PyQt5.QtCore import QTimer
                            self._viewport_resize_timer = QTimer()
                            self._viewport_resize_timer.setSingleShot(True)
                            self._viewport_resize_timer.timeout.connect(lambda: self.get_icon_container_safely() and self.get_icon_container_safely().relayout_icons())
                        
                        self._viewport_resize_timer.stop()
                        self._viewport_resize_timer.start(50)  # Quick response for viewport changes
        
        return super().eventFilter(obj, event)
    
    def get_icon_container_safely(self):
        """Safely get icon_container reference, returns None if not available"""
        if hasattr(self, 'icon_container') and self.icon_container:
            return self.icon_container
        return None
    
    def handle_double_click(self, path):
        """Handle double click on file/folder"""
        if os.path.isdir(path):
            self.navigate_to(path)
        elif path.lower().endswith('.gsfmt'):
            # Handle .gsfmt files specially - load them as custom themes
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'load_theme_file'):
                main_window = main_window.parent()
            if main_window:
                main_window.load_theme_file(path)
        elif path.lower().endswith('.qss'):
            # Handle .qss files - load them as QSS stylesheets
            print(f"[DEBUG] .qss file clicked: {path}")
            # Try to call the main window's load_qss_file if available
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'load_qss_file'):
                print(f"[DEBUG] Ascending to parent: {main_window}")
                main_window = main_window.parent() if hasattr(main_window, 'parent') else None
            if main_window and hasattr(main_window, 'load_qss_file'):
                print(f"[DEBUG] Calling main_window.load_qss_file({path})")
                main_window.load_qss_file(path)
            else:
                from PyQt5.QtWidgets import QMessageBox
                print(f"[DEBUG] load_qss_file not available on main window")
                QMessageBox.warning(self, "QSS Error", f"QSS loader not available.")
        elif ArchiveManager.is_archive(path):
            # For archive files, always show browse dialog instead of opening externally
            if hasattr(self.parent(), 'browse_archive_contents'):
                self.parent().browse_archive_contents(path)
            else:
                # Try to find the main window with browse method
                main_window = self.parent()
                while main_window and not hasattr(main_window, 'browse_archive_contents'):
                    main_window = main_window.parent()
                if main_window:
                    main_window.browse_archive_contents(path)
                # If we still can't find the method, don't open with system default
                # Archive files should only be handled by built-in browser
        else:
            # Open non-archive file with default application
            QDesktopServices.openUrl(QUrl.fromLocalFile(path))


class SmbBrowserTab(QWidget):
    """A tab for browsing an SMB (Samba) network share."""
    def __init__(self, server, share, username, password, domain='', start_path='/', parent=None):
        super().__init__(parent)
        self.smb = SMBNetworkUtils(server, share, username, password, domain)
        self.current_path = start_path
        self.layout = QVBoxLayout(self)
        self.path_label = QLabel()
        self.layout.addWidget(self.path_label)
        # Add download/upload buttons
        btn_layout = QHBoxLayout()
        self.download_btn = QPushButton("⬇ Download")
        self.download_btn.clicked.connect(self.download_selected_file)
        btn_layout.addWidget(self.download_btn)
        self.upload_btn = QPushButton("⬆ Upload")
        self.upload_btn.clicked.connect(self.upload_file)
        btn_layout.addWidget(self.upload_btn)
        btn_layout.addStretch()
        self.layout.addLayout(btn_layout)
        self.list_widget = QListWidget()
        self.layout.addWidget(self.list_widget)
        self.list_widget.itemDoubleClicked.connect(self.on_item_double_clicked)
        self.refresh()

    def download_selected_file(self):
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        items = self.list_widget.selectedItems()
        if not items:
            QMessageBox.warning(self, "No Selection", "Select a file to download.")
            return
        name = items[0].text()
        remote_path = self.current_path.rstrip("/") + "/" + name
        # Ask user where to save
        save_path, _ = QFileDialog.getSaveFileName(self, "Save File As", name)
        if not save_path:
            return
        try:
            data = self.smb.read_file(remote_path)
            with open(save_path, "wb") as f:
                f.write(data)
            QMessageBox.information(self, "Download Complete", f"Downloaded to {save_path}")
        except Exception as e:
            QMessageBox.critical(self, "Download Failed", str(e))

    def upload_file(self):
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        file_path, _ = QFileDialog.getOpenFileName(self, "Select File to Upload")
        if not file_path:
            return
        name = os.path.basename(file_path)
        remote_path = self.current_path.rstrip("/") + "/" + name
        try:
            with open(file_path, "rb") as f:
                data = f.read()
            self.smb.write_file(remote_path, data)
            QMessageBox.information(self, "Upload Complete", f"Uploaded {name}")
            self.refresh()
        except Exception as e:
            QMessageBox.critical(self, "Upload Failed", str(e))

    def refresh(self):
        self.path_label.setText(f"smb://{self.smb.server}/{self.smb.share}{self.current_path}")
        self.list_widget.clear()
        try:
            entries = self.smb.listdir(self.current_path)
            for entry in entries:
                self.list_widget.addItem(entry)
        except Exception as e:
            self.list_widget.addItem(f"[ERROR] {e}")

    def on_item_double_clicked(self, item):
        name = item.text()
        if name.startswith("[ERROR]"):
            return
        # If it's a .gsfmt theme file, call the main window's loader
        if name.endswith('.gsfmt'):
            import os
            print(f"[DEBUG] .gsfmt file clicked: {name}")
            theme_path = os.path.join(self.current_path, name)
            print(f"[DEBUG] Theme path: {theme_path}")
            # Try to call the main window's load_theme_file if available
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'load_theme_file'):
                print(f"[DEBUG] Ascending to parent: {main_window}")
                main_window = main_window.parent() if hasattr(main_window, 'parent') else None
            if main_window and hasattr(main_window, 'load_theme_file'):
                print(f"[DEBUG] Calling main_window.load_theme_file({theme_path})")
                main_window.load_theme_file(theme_path)
            else:
                # Fallback: try to apply as before (legacy)
                try:
                    import json
                    print(f"[DEBUG] Loading theme file directly: {theme_path}")
                    with open(theme_path, 'r', encoding='utf-8') as f:
                        theme_data = json.load(f)
                    print(f"[DEBUG] Theme data loaded: {type(theme_data)}")
                    if isinstance(theme_data, dict):
                        if 'theme_data' in theme_data:
                            theme_modes = theme_data['theme_data']
                        else:
                            theme_modes = theme_data
                        print(f"[DEBUG] Theme modes: {list(theme_modes.keys()) if isinstance(theme_modes, dict) else 'not a dict'}")
                        if isinstance(theme_modes, dict):
                            if 'strong' in theme_modes:
                                selected_mode = 'strong'
                            elif 'regular' in theme_modes:
                                selected_mode = 'regular'
                            else:
                                selected_mode = next(iter(theme_modes.keys()))
                            print(f"[DEBUG] Selected mode: {selected_mode}")
                            selected_theme = theme_modes[selected_mode]
                            from PyQt5.QtWidgets import QMessageBox
                            QMessageBox.information(self, "Theme Loaded", f"Loaded theme '{name}' in mode '{selected_mode}'.")
                            if hasattr(self, 'apply_theme_dict'):
                                print(f"[DEBUG] Applying theme dict for mode: {selected_mode}")
                                self.apply_theme_dict(selected_theme)
                            else:
                                print(f"[DEBUG] apply_theme_dict not implemented on this object")
                                QMessageBox.information(self, "Theme Loaded", f"Theme loaded, but apply_theme_dict is not implemented.")
                            return
                    from PyQt5.QtWidgets import QMessageBox
                    print(f"[DEBUG] Not a valid theme file: {name}")
                    QMessageBox.warning(self, "Theme Error", f"File '{name}' is not a valid theme.")
                except Exception as e:
                    from PyQt5.QtWidgets import QMessageBox
                    print(f"[DEBUG] Exception loading theme: {e}")
                    QMessageBox.critical(self, "Theme Load Error", f"Failed to load theme '{name}': {e}")
            return
        # If it's a .qss stylesheet file, call the main window's QSS loader
        if name.endswith('.qss'):
            import os
            print(f"[DEBUG] .qss file clicked: {name}")
            qss_path = os.path.join(self.current_path, name)
            print(f"[DEBUG] QSS path: {qss_path}")
            # Try to call the main window's load_qss_file if available
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'load_qss_file'):
                print(f"[DEBUG] Ascending to parent: {main_window}")
                main_window = main_window.parent() if hasattr(main_window, 'parent') else None
            if main_window and hasattr(main_window, 'load_qss_file'):
                print(f"[DEBUG] Calling main_window.load_qss_file({qss_path})")
                main_window.load_qss_file(qss_path)
            else:
                from PyQt5.QtWidgets import QMessageBox
                print(f"[DEBUG] load_qss_file not available on main window")
                QMessageBox.warning(self, "QSS Error", f"QSS loader not available.")
            return
        # Try to enter directory
        new_path = self.current_path.rstrip("/") + "/" + name
        try:
            entries = self.smb.listdir(new_path)
            self.current_path = new_path
            self.refresh()
        except Exception:
            pass  # Not a directory or error

class TabManager(QWidget):
    def add_smb_tab(self, server, share, username, password, domain='', start_path='/'):
        tab = SmbBrowserTab(server, share, username, password, domain, start_path, parent=self)
        tab_title = f" smb://{server}/{share}{start_path} "  # Add padding spaces
        tab_index = self.tab_bar.addTab(tab_title)
        self.tab_stack.addWidget(tab)
        self.tabs.append(tab)
        self.tab_bar.setCurrentIndex(tab_index)
        self.tab_stack.setCurrentWidget(tab)
        if self.tab_changed_callback:
            self.tab_changed_callback()
        return tab
    """Manages multiple file manager tabs"""
    
    def __init__(self, parent=None, create_initial_tab=True):
        super().__init__(parent)
        self.main_window = parent  # Store direct reference to main window
        self.tabs = []  # Initialize before setup_ui
        self.tab_changed_callback = None  # Callback for when tabs change
        self.setup_ui()
        
        # Create initial tab only if requested
        if create_initial_tab:
            self.new_tab(os.path.expanduser("~"))
    
    def set_tab_changed_callback(self, callback):
        """Set callback to be called when tabs change"""
        self.tab_changed_callback = callback
        
    def setup_ui(self):
        """Setup the tab manager UI"""
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)  # Remove spacing between tab controls and content
        
        # Tab bar and controls
        tab_controls = QHBoxLayout()
        tab_controls.setContentsMargins(0, 0, 0, 0)  # Remove margins from tab controls
        tab_controls.setSpacing(2)  # Minimal spacing between tab bar and buttons
        
        self.tab_bar = QTabBar()
        self.tab_bar.setTabsClosable(True)
        self.tab_bar.setMovable(True)
        # Increase maximum tab width to accommodate full directory names
        self.tab_bar.setElideMode(Qt.ElideNone)  # Disable text eliding
        self.tab_bar.setExpanding(False)  # Prevent tabs from expanding to fill available space
        self.tab_bar.setUsesScrollButtons(True)  # Enable scroll buttons when tabs overflow
        self.tab_bar.tabCloseRequested.connect(self.close_tab)
        self.tab_bar.currentChanged.connect(self.tab_changed)
        self.tab_bar.tabMoved.connect(self.tab_moved)
        tab_controls.addWidget(self.tab_bar)
        
        # New tab button
        self.new_tab_btn = QPushButton("+")
        self.new_tab_btn.setFixedSize(30, 25)
        self.new_tab_btn.setToolTip("New Tab")

        def _new_tab_clicked():
            try:
                # placeholder
                _ = None
            except Exception:
                pass
            try:
                # Open a new tab at the user's home directory when New Tab is clicked
                self.new_tab(os.path.expanduser("~"))
            except Exception:
                try:
                    self.new_tab(os.path.expanduser("~"))
                except Exception:
                    pass

        try:
            self.new_tab_btn.clicked.connect(_new_tab_clicked)
        except Exception:
            self.new_tab_btn.clicked.connect(self.new_tab)
        tab_controls.addWidget(self.new_tab_btn)
        
        tab_controls.addStretch()
        
        layout.addLayout(tab_controls)
        
        # Tab content area
        self.tab_stack = QStackedWidget()
        layout.addWidget(self.tab_stack)
        
        self.setLayout(layout)
        
        # Initial tab creation is handled by parent class now
    
    def new_tab(self, initial_path=None):
        """Create a new tab"""
    # TabManager.new_tab called
        # If no initial_path specified and running on Windows, open My Computer (drive list)
        if initial_path is None:
            try:
                if PlatformUtils.is_windows():
                    # Use sentinel so FileManagerTab can initialize a drive-list view
                    initial_path = "__MY_COMPUTER__"
                else:
                    initial_path = os.path.expanduser("~")
            except Exception:
                initial_path = os.path.expanduser("~")
        # Accept ftp:// and sftp:// addresses as-is
        is_remote = False
        if isinstance(initial_path, str) and (initial_path.startswith('ftp://') or initial_path.startswith('sftp://')):
            is_remote = True
        # If initial_path is the My Computer sentinel, treat it as a special drive-list view
        is_drive_list = (initial_path == "__MY_COMPUTER__")
        # For local paths, ensure the path exists
        if not is_remote and not is_drive_list:
            if not isinstance(initial_path, str):
                initial_path = os.path.expanduser("~")
            if not os.path.exists(initial_path) or not os.path.isdir(initial_path):
                initial_path = os.path.expanduser("~")
        tab = FileManagerTab(initial_path, self)
        self.tabs.append(tab)
        # Install event filter for right-click handling on this tab's scroll area
        if hasattr(self, 'main_window') and self.main_window:
            tab.scroll_area.viewport().installEventFilter(self.main_window)
        # Tab title for remote: show address, for local: show folder name
        if is_remote:
            tab_title = f" {initial_path} "  # Add padding spaces
        elif is_drive_list:
            tab_title = " My Computer "  # Add padding spaces
        else:
            # Get folder name, handling edge cases
            folder_name = os.path.basename(initial_path) if initial_path else ""
            if not folder_name:
                # If basename is empty, try dirname for root paths
                folder_name = os.path.dirname(initial_path) if initial_path else ""
            if not folder_name or folder_name == os.sep:
                # For root paths or empty, use "Home" or drive letter
                if initial_path and len(initial_path) >= 2 and initial_path[1] == ':':
                    folder_name = initial_path[:2]  # Use drive letter like "C:"
                else:
                    folder_name = "Home"
            tab_title = f" {folder_name} "  # Add padding spaces
        tab_index = self.tab_bar.addTab(tab_title)
        self.tab_stack.addWidget(tab)
        # Switch to new tab
        self.tab_bar.setCurrentIndex(tab_index)
        self.tab_stack.setCurrentWidget(tab)
        # Notify about tab change
        if self.tab_changed_callback:
            self.tab_changed_callback()
        return tab
    
    def close_tab(self, index):
        """Close a tab"""
        if len(self.tabs) <= 1:
            return  # Don't close the last tab
        
        if not (0 <= index < len(self.tabs)):
            return  # Invalid index
        
        tab = self.tabs[index]
        
        # Save sort settings before closing the tab
        if hasattr(self.main_window, 'save_tab_sort_settings'):
            self.main_window.save_tab_sort_settings(tab)
        
        # Remove from our list first
        # Unregister monitored directory for this tab if present
        try:
            if hasattr(tab, '_monitored_directory') and tab._monitored_directory:
                try:
                    if hasattr(self, 'main_window') and getattr(self, 'main_window') and hasattr(self.main_window, 'background_monitor'):
                        self.main_window.background_monitor.remove_directory(tab._monitored_directory)
                except Exception:
                    pass
        except Exception:
            pass

        self.tabs.remove(tab)
        
        # Remove from UI components
        self.tab_bar.removeTab(index)
        self.tab_stack.removeWidget(tab)
        
        # Clean up the widget
        tab.deleteLater()
        
        # If the current tab was closed, switch to a valid tab
        current_index = self.tab_bar.currentIndex()
        if current_index >= len(self.tabs) and len(self.tabs) > 0:
            new_index = len(self.tabs) - 1
            self.tab_bar.setCurrentIndex(new_index)
            self.tab_stack.setCurrentWidget(self.tabs[new_index])
        
        # Notify about tab change
        if self.tab_changed_callback:
            self.tab_changed_callback()
    
    def tab_changed(self, index):
        """Handle tab change"""
        if 0 <= index < len(self.tabs):
            target_tab = self.tabs[index]
            # Verify the widget is in the stack before setting it
            stack_widget_index = self.tab_stack.indexOf(target_tab)
            if stack_widget_index >= 0:
                self.tab_stack.setCurrentWidget(target_tab)
            else:
                print(f"Warning: Tab widget at index {index} not found in stack")
                # Fallback: use stack index instead
                if index < self.tab_stack.count():
                    self.tab_stack.setCurrentIndex(index)
            
            # Notify about tab change
            if self.tab_changed_callback:
                self.tab_changed_callback()
    
    def tab_moved(self, from_index, to_index):
        """Handle tab reordering"""
        if 0 <= from_index < len(self.tabs) and 0 <= to_index < len(self.tabs):
            # Move the tab widget in the tabs list to match the new order
            tab_widget = self.tabs.pop(from_index)
            self.tabs.insert(to_index, tab_widget)
            
            # Update the stacked widget order to match
            # Remove the widget from its current position
            self.tab_stack.removeWidget(tab_widget)
            # Insert it at the new position
            self.tab_stack.insertWidget(to_index, tab_widget)
            
            # Ensure the current tab view is still correct after reordering
            current_index = self.tab_bar.currentIndex()
            if 0 <= current_index < len(self.tabs):
                self.tab_stack.setCurrentWidget(self.tabs[current_index])
    
    def update_tab_title(self, tab, title):
        """Update tab title"""
        try:
            index = self.tabs.index(tab)
            self.tab_bar.setTabText(index, title)
        except ValueError:
            pass  # Tab not found
    
    def get_current_tab(self):
        """Get the currently active tab"""
        current_index = self.tab_bar.currentIndex()
        if 0 <= current_index < len(self.tabs):
            return self.tabs[current_index]
        return None
    
    def get_current_path(self):
        """Get current path from active tab"""
        current_tab = self.get_current_tab()
        return current_tab.current_folder if current_tab else os.path.expanduser("~")
    
    def open_my_computer_tab(self):
        """Open a new tab showing My Computer (all connected drives)"""
        try:
            # Use the special sentinel string to indicate My Computer view
            self.new_tab("__MY_COMPUTER__")
        except Exception as e:
            print(f"Error opening My Computer tab: {e}")
            # Fallback to a regular home directory tab
            self.new_tab(os.path.expanduser("~"))
    
    def _add_tab_widget(self, tab_widget):
        """Add an existing tab widget to this manager (internal helper for dual pane)"""
        if tab_widget and tab_widget not in self.tabs:
            # Update the tab's manager reference
            tab_widget.tab_manager = self
            
            # Add to our collections
            self.tabs.append(tab_widget)
            self.tab_stack.addWidget(tab_widget)
            
            # Generate proper tab title based on current folder
            tab_title = self._generate_tab_title(tab_widget)
            self.tab_bar.addTab(tab_title)
            
            # Set as current tab
            self.tab_bar.setCurrentIndex(len(self.tabs) - 1)
            self.tab_stack.setCurrentWidget(tab_widget)
            
            # Connect signals
            if self.main_window and hasattr(self.main_window, 'connect_tab_signals'):
                self.main_window.connect_tab_signals(tab_widget)
    
    def _remove_tab_widget(self, tab_widget):
        """Remove a tab widget from this manager (internal helper for dual pane)"""
        if tab_widget in self.tabs:
            tab_index = self.tabs.index(tab_widget)
            
            # Remove from tab bar
            self.tab_bar.removeTab(tab_index)
            
            # Remove from stack and list
            self.tab_stack.removeWidget(tab_widget)
            self.tabs.remove(tab_widget)
            
            # Clear the tab's manager reference
            tab_widget.tab_manager = None
    
    def _generate_tab_title(self, tab_widget):
        """Generate appropriate tab title based on tab's current folder"""
        try:
            current_folder = getattr(tab_widget, 'current_folder', None)
            
            if not current_folder:
                return " Home "
            
            # Handle special cases
            if current_folder == "__MY_COMPUTER__":
                return " My Computer "
            
            # Handle remote paths (contain ://)
            if "://" in current_folder:
                return f" {current_folder} "
            
            # Handle regular directories
            folder_name = os.path.basename(current_folder) or os.path.dirname(current_folder) or "Home"
            return f" {folder_name} "
            
        except Exception:
            return " Home "


class DualPaneManager(QWidget):
    """Manages dual tabbed panes for side-by-side file operations"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.main_window = parent
        self.active_pane = 0  # 0 = left, 1 = right
        self.setup_ui()
        
    def setup_ui(self):
        """Initialize the dual pane layout"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create horizontal splitter for the two panes
        self.splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(self.splitter)
        
        # Create left pane (TabManager)
        self.left_pane = TabManager(parent=self.main_window, create_initial_tab=False)
        self.left_pane.set_tab_changed_callback(self.on_left_tab_changed)
        self.splitter.addWidget(self.left_pane)
        
        # Create right pane (TabManager)
        self.right_pane = TabManager(parent=self.main_window, create_initial_tab=False)
        self.right_pane.set_tab_changed_callback(self.on_right_tab_changed)
        self.splitter.addWidget(self.right_pane)
        
        # Set equal sizes for both panes
        self.splitter.setSizes([400, 400])
        
        # Install event filters for hover detection
        self.setup_hover_detection()
        
        # Style the active pane
        self.update_active_pane_styling()
    
    def setup_hover_detection(self):
        """Setup hover detection for both panes"""
        # Install event filters on both panes to detect mouse enter/leave
        self.left_pane.installEventFilter(self)
        self.right_pane.installEventFilter(self)
        
        # Also enable mouse tracking to get hover events
        self.left_pane.setMouseTracking(True)
        self.right_pane.setMouseTracking(True)
        
        # Install event filters on child widgets for better hover detection
        self._install_recursive_event_filters(self.left_pane, 0)
        self._install_recursive_event_filters(self.right_pane, 1)
    
    def _install_recursive_event_filters(self, widget, pane_index):
        """Recursively install event filters on child widgets"""
        try:
            widget.installEventFilter(self)
            widget.setMouseTracking(True)
            # Store pane index as a property for later reference
            widget.setProperty("pane_index", pane_index)
            
            # Recursively apply to children
            for child in widget.findChildren(QWidget):
                if not hasattr(child, 'eventFilter'):  # Skip widgets that already handle events
                    child.installEventFilter(self)
                    child.setMouseTracking(True)
                    child.setProperty("pane_index", pane_index)
        except Exception:
            pass  # Fail silently for any problematic widgets
    
    def _refresh_hover_detection(self):
        """Refresh hover detection for any new widgets that may have been added"""
        try:
            # Re-apply event filters to any new child widgets
            self._install_recursive_event_filters(self.left_pane, 0)
            self._install_recursive_event_filters(self.right_pane, 1)
        except Exception:
            pass  # Fail silently
    
    def eventFilter(self, obj, event):
        """Handle hover events for pane switching"""
        try:
            if event.type() == QEvent.Enter:
                # Mouse entered a widget - determine which pane it belongs to
                pane_index = None
                
                # Check if it's one of the main panes
                if obj == self.left_pane:
                    pane_index = 0
                elif obj == self.right_pane:
                    pane_index = 1
                else:
                    # Check if it's a child widget with pane_index property
                    pane_index = obj.property("pane_index")
                
                # Switch to the appropriate pane if different from current
                if pane_index is not None and pane_index != self.active_pane:
                    self.set_active_pane(pane_index)
                    
            elif event.type() == QEvent.Leave:
                # Mouse left a widget - we don't need to do anything special here
                pass
        except Exception as e:
            # Fail silently to avoid disrupting normal operation
            pass
        
        # Always call the parent's event filter
        return super().eventFilter(obj, event)
    
    def set_active_pane(self, pane_index):
        """Set the active pane by index (0=left, 1=right)"""
        if pane_index != self.active_pane and pane_index in [0, 1]:
            self.active_pane = pane_index
            self.update_active_pane_styling()
            
            # Update focus to the active pane
            active_pane = self.get_active_pane()
            if active_pane.tabs:
                current_tab = active_pane.get_current_tab()
                if current_tab:
                    current_tab.setFocus()
            
            # Notify main window of tab change
            if self.main_window and hasattr(self.main_window, 'on_tab_changed'):
                self.main_window.on_tab_changed()
        
    def get_active_pane(self):
        """Get the currently active pane"""
        return self.left_pane if self.active_pane == 0 else self.right_pane
        
    def get_inactive_pane(self):
        """Get the currently inactive pane"""
        return self.right_pane if self.active_pane == 0 else self.left_pane
        
    def switch_active_pane(self):
        """Switch focus between left and right panes"""
        new_pane = 1 - self.active_pane  # Toggle between 0 and 1
        self.set_active_pane(new_pane)
    
    def update_active_pane_styling(self):
        """Update styling to show which pane is active"""
        # Add a subtle border to the active pane
        self.left_pane.setStyleSheet("" if self.active_pane == 1 else "QWidget { border: 2px solid #0078d4; }")
        self.right_pane.setStyleSheet("" if self.active_pane == 0 else "QWidget { border: 2px solid #0078d4; }")
    
    def on_left_tab_changed(self):
        """Handle tab change in left pane"""
        self.set_active_pane(0)
    
    def on_right_tab_changed(self):
        """Handle tab change in right pane"""
        self.set_active_pane(1)
    
    def new_tab(self, path=None):
        """Create a new tab in the active pane"""
        result = self.get_active_pane().new_tab(path)
        # Refresh hover detection for the new tab
        self._refresh_hover_detection()
        return result
    
    def close_current_tab(self):
        """Close the current tab in the active pane"""
        return self.get_active_pane().close_current_tab()
    
    def get_current_tab(self):
        """Get the current tab from the active pane"""
        return self.get_active_pane().get_current_tab()
    
    def update_tab_title(self, tab, title):
        """Update tab title - automatically detects which pane contains the tab"""
        if tab in self.left_pane.tabs:
            self.left_pane.update_tab_title(tab, title)
        elif tab in self.right_pane.tabs:
            self.right_pane.update_tab_title(tab, title)
    
    def get_all_tabs(self):
        """Get all tabs from both panes"""
        return self.left_pane.tabs + self.right_pane.tabs
    
    def migrate_from_single_pane(self, single_tab_manager):
        """Migrate tabs from a single TabManager to dual panes"""
        if single_tab_manager and single_tab_manager.tabs:
            # Move first tab to left pane, rest to right pane (or all to left if only one)
            tabs_to_move = single_tab_manager.tabs.copy()
            
            if tabs_to_move:
                # Move first tab to left pane
                first_tab = tabs_to_move[0]
                single_tab_manager._remove_tab_widget(first_tab)
                self.left_pane._add_tab_widget(first_tab)
                
                # Move remaining tabs to right pane
                for tab in tabs_to_move[1:]:
                    single_tab_manager._remove_tab_widget(tab)
                    self.right_pane._add_tab_widget(tab)
    
    def migrate_to_single_pane(self, target_tab_manager):
        """Migrate all tabs from dual panes to a single TabManager"""
        # Move all tabs from both panes to the target
        all_tabs = self.get_all_tabs().copy()
        
        for tab in all_tabs:
            if tab in self.left_pane.tabs:
                self.left_pane._remove_tab_widget(tab)
            elif tab in self.right_pane.tabs:
                self.right_pane._remove_tab_widget(tab)
            target_tab_manager._add_tab_widget(tab)


class SimpleFileManager(QMainWindow):
    def show_status_message(self, message, timeout=3000):
        """Stub: Show a status message in the UI. Replace with your actual logic."""
        # Example: show in status bar if available
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message, timeout)
        else:
            print(f"STATUS: {message}")
    def apply_theme_dict(self, theme_dict):
        """Apply a theme dictionary to the main window and all key widgets using QSS stylesheets."""
        # Extract theme colors
        bg = theme_dict.get('window_bg') or theme_dict.get('background')
        fg = theme_dict.get('text') or theme_dict.get('foreground')
        accent = theme_dict.get('accent')
        panel_bg = theme_dict.get('panel_bg', bg)
        selection_bg = theme_dict.get('selection_bg', accent)
        selection_text = theme_dict.get('selection_text', fg)
        border = theme_dict.get('border', accent)
        button_bg = theme_dict.get('button_bg', panel_bg)
        button_fg = theme_dict.get('button_text', fg)
        label_fg = theme_dict.get('label_fg', fg)
        
        # Build comprehensive QSS stylesheet
        qss_style = f"""
        /* Main Window */
        QMainWindow {{
            background-color: {bg or '#ffffff'};
            color: {fg or '#000000'};
        }}
        
        /* Labels */
        QLabel {{
            color: {label_fg or fg or '#000000'};
            background-color: transparent;
        }}
        
        /* Buttons */
        QPushButton {{
            background-color: {button_bg or panel_bg or '#f0f0f0'};
            color: {button_fg or fg or '#000000'};
            border: 1px solid {border or accent or '#cccccc'};
            padding: 5px 10px;
            border-radius: 3px;
        }}
        QPushButton:hover {{
            background-color: {accent or '#e0e0e0'};
        }}
        QPushButton:pressed {{
            background-color: {selection_bg or '#d0d0d0'};
        }}
        
        /* Text Inputs */
        QLineEdit, QTextEdit {{
            background-color: {bg or '#ffffff'};
            color: {fg or '#000000'};
            border: 1px solid {border or accent or '#cccccc'};
            padding: 3px;
            border-radius: 2px;
        }}
        QLineEdit:focus, QTextEdit:focus {{
            border: 2px solid {accent or '#0078d4'};
        }}
        
        /* List/Tree Views */
        QListWidget, QTreeView {{
            background-color: {panel_bg or bg or '#ffffff'};
            color: {fg or '#000000'};
            border: 1px solid {border or accent or '#cccccc'};
            selection-background-color: {selection_bg or accent or '#0078d4'};
            selection-color: {selection_text or '#ffffff'};
            alternate-background-color: {panel_bg or '#f9f9f9'};
        }}
        QListWidget::item:hover, QTreeView::item:hover {{
            background-color: {accent or '#e0e0e0'};
        }}
        
        /* Tab Widget */
        QTabWidget::pane {{
            background: {panel_bg or bg or '#ffffff'};
            border: 1px solid {border or accent or '#cccccc'};
        }}
        QTabBar::tab {{
            background: {button_bg or panel_bg or '#f0f0f0'};
            color: {fg or '#000000'};
            border: 1px solid {border or accent or '#cccccc'};
            padding: 5px 10px;
            margin-right: 2px;
        }}
        QTabBar::tab:selected {{
            background: {selection_bg or accent or '#0078d4'};
            color: {selection_text or '#ffffff'};
        }}
        QTabBar::tab:hover {{
            background: {accent or '#e0e0e0'};
        }}
        
        /* Menu Bar & Menus */
        QMenuBar {{
            background-color: {panel_bg or bg or '#ffffff'};
            color: {fg or '#000000'};
            border-bottom: 1px solid {border or accent or '#cccccc'};
        }}
        QMenuBar::item:selected {{
            background-color: {selection_bg or accent or '#0078d4'};
            color: {selection_text or '#ffffff'};
        }}
        QMenu {{
            background-color: {bg or '#ffffff'};
            color: {fg or '#000000'};
            border: 1px solid {border or accent or '#cccccc'};
        }}
        QMenu::item:selected {{
            background-color: {selection_bg or accent or '#0078d4'};
            color: {selection_text or '#ffffff'};
        }}
        
        /* Toolbar */
        QToolBar {{
            background-color: {panel_bg or bg or '#f0f0f0'};
            border: 1px solid {border or accent or '#cccccc'};
            spacing: 2px;
        }}
        
        /* Status Bar */
        QStatusBar {{
            background-color: {panel_bg or bg or '#f0f0f0'};
            color: {fg or '#000000'};
            border-top: 1px solid {border or accent or '#cccccc'};
        }}
        
        /* Scroll Bars */
        QScrollBar:vertical {{
            background: {panel_bg or '#f0f0f0'};
            width: 12px;
            border: none;
        }}
        QScrollBar::handle:vertical {{
            background: {accent or '#c0c0c0'};
            border-radius: 6px;
            min-height: 20px;
        }}
        QScrollBar::handle:vertical:hover {{
            background: {selection_bg or '#a0a0a0'};
        }}
        QScrollBar:horizontal {{
            background: {panel_bg or '#f0f0f0'};
            height: 12px;
            border: none;
        }}
        QScrollBar::handle:horizontal {{
            background: {accent or '#c0c0c0'};
            border-radius: 6px;
            min-width: 20px;
        }}
        QScrollBar::handle:horizontal:hover {{
            background: {selection_bg or '#a0a0a0'};
        }}
        """
        
        # Apply the comprehensive stylesheet to the main window
        self.setStyleSheet(qss_style)
        
        # Apply specific styles to components that might need special handling
        if hasattr(self, 'path_label'):
            self.path_label.setStyleSheet(f"color: {label_fg or fg}; font-weight: bold; padding: 5px; background-color: {panel_bg or bg};")
            
        # Update breadcrumb if present
        if hasattr(self, 'breadcrumb') and label_fg:
            self.breadcrumb.set_text_color(label_fg)
            
        self.show_status_message("QSS Theme applied successfully.")

    def get_current_theme_dict(self):
        """Get the current theme dictionary for applying to dialogs"""
        try:
            # Use the current theme depending on mode
            if getattr(self, 'subdued_mode', False):
                return self.SUBDUED_COLOR_THEMES.get(self.color_theme, {})
            elif getattr(self, 'strong_mode', False):
                return self.STRONG_COLOR_THEMES.get(self.color_theme, {})
            elif getattr(self, 'dark_mode', False):
                return self.DARK_COLOR_THEMES.get(self.color_theme, {})
            else:
                return self.COLOR_THEMES.get(self.color_theme, {})
        except Exception:
            return {}

    def apply_windows98_qss_if_applicable(self, theme_name):
        """Automatically apply Windows 98 QSS stylesheet for Windows 98 themes."""
        import os
        
        # Check if this is a Windows 98 theme
        if not theme_name or 'windows 98' not in theme_name.lower():
            return
            
        # Map theme names to QSS files
        qss_mapping = {
            'windows 98': 'windows98_classic.qss',
            'windows 98 blue': 'windows98_blue.qss',
            'windows 98 green': 'windows98_green.qss',
            'windows 98 red': 'windows98_red.qss',
            'windows 98 purple': 'windows98_purple.qss',
            'windows 98 yellow': 'windows98_yellow.qss',
            'windows 98 orange': 'windows98_orange.qss',
            'windows 98 pink': 'windows98_pink.qss'
        }
        
        # Find matching QSS file
        qss_filename = qss_mapping.get(theme_name.lower())
        if not qss_filename:
            # Try partial matching for other Windows 98 variants
            for key, filename in qss_mapping.items():
                if key in theme_name.lower():
                    qss_filename = filename
                    break
        
        if qss_filename:
            qss_path = os.path.join(os.path.dirname(__file__), 'qss', qss_filename)
            if os.path.exists(qss_path):
                print(f"[DEBUG] Auto-applying Windows 98 QSS: {qss_filename}")
                self.load_qss_file(qss_path)
            else:
                print(f"[DEBUG] Windows 98 QSS file not found: {qss_path}")

    def load_view_mode(self):
        settings = QSettings("garysfm", "garysfm")
        mode = settings.value("view_mode", None)
        if mode is not None:
            self.set_view_mode(mode)

    def save_view_mode(self, mode):
        settings = QSettings("garysfm", "garysfm")
        settings.setValue("view_mode", str(mode))
    SETTINGS_FILE = "filemanager_settings.json"

    def __init__(self):
        super().__init__()
        
        # Initialize logger for the file manager
        self.logger = setup_logger(f'{__name__}.SimpleFileManager')
        
        self.clipboard_data = None
        self.thumbnail_size = 64  # Default thumbnail size

        # Control verbose thumbnail logging during development and tests.
        # Set to False in production to avoid huge console output.
        THUMBNAIL_VERBOSE = False

        def thumbnail_debug(msg, *args):
            try:
                if THUMBNAIL_VERBOSE:
                    print(f"[THUMBNAIL-DEBUG] {msg.format(*args)}")
            except Exception:
                pass

        def thumbnail_info(msg, *args):
            try:
                if THUMBNAIL_VERBOSE:
                    print(f"[THUMBNAIL-INFO] {msg.format(*args)}")
            except Exception:
                pass

        def thumbnail_error(msg, *args):
            try:
                # Always show errors so failures are visible even when verbose is off
                print(f"[THUMBNAIL-ERROR] {msg.format(*args)}")
            except Exception:
                pass

        
        # Initialize dark mode as default on all platforms
        # Only use system detection on macOS if user prefers, otherwise default to dark
        self.dark_mode = True  # Default to dark mode on all platforms
            
        self.icons_wide = 0  # 0 means auto-calculate, >0 means fixed width

        # Color themes mapping (light palettes). Dark mode remains an override.
        # Each theme is a dict of basic colors used by apply_theme
        self.COLOR_THEMES = {
            'Default Light': {
                'window_bg': '#ffffff', 'panel_bg': '#f5f5f5', 'text': '#000000', 'accent': '#0078d7'
            },
        }

        # Dark-mode variants for the named color themes. When dark_mode is enabled
        # we prefer these palettes so the selected theme feels consistent in dark.
        # Keys mirror those in COLOR_THEMES.
        self.DARK_COLOR_THEMES = {
            'Default Light': {
                'window_bg': '#2b2b2b', 'panel_bg': '#363636', 'text': '#ffffff', 'accent': '#3daee9'
            },
        }

        # Strong-mode palettes: vibrant, high-contrast accents for dramatic UI (now empty)
        self.STRONG_COLOR_THEMES = {
        }

        # Subdued-mode palettes: more understated themes (now empty)
        self.SUBDUED_COLOR_THEMES = {
        }

        # Strong theme mapping from regular themes to strong variants (now empty)
        self.STRONG_THEME_MAP = {
        }

        # Subdued theme mapping (now empty since no subdued themes exist)
        self.SUBDUED_THEME_MAP = {
        }

        # Generate stronger, darker subdued variants from the existing
        # named light themes so Subdued Themes don't look pastel.
        try:
            from PyQt5.QtGui import QColor

            def _darker(hexcol, factor=140):
                try:
                    q = QColor(hexcol)
                    # QColor.darker expects an int percentage (100 = same)
                    return q.darker(factor).name()
                except Exception:
                    return hexcol

            # For each named theme, create a "<Name> Subdued" entry unless one exists
            for base_name, base_theme in list(self.COLOR_THEMES.items()):
                subdued_key = f"{base_name} Subdued"
                if subdued_key in self.SUBDUED_COLOR_THEMES:
                    continue

                win = base_theme.get('window_bg') or base_theme.get('panel_bg') or '#111111'
                panel = base_theme.get('panel_bg') or win
                accent = base_theme.get('accent') or '#ff4d00'

                # Make backgrounds significantly stronger/darker than the light theme
                win_v = _darker(win, 160)   # stronger/darker window background
                panel_v = _darker(panel, 140)  # slightly lighter than window_v

                # Ensure accent is vivid: if it's too pale, darken it OR boost contrast
                try:
                    aq = QColor(accent)
                    # If accent is very light, darken it; otherwise keep it
                    if aq.lightness() > 200:
                        acc_v = aq.darker(140).name()
                    else:
                        acc_v = aq.name()
                except Exception:
                    acc_v = accent

                # Prefer white text for dark subdued backgrounds
                txt_v = '#ffffff'

                self.SUBDUED_COLOR_THEMES[subdued_key] = {
                    'window_bg': win_v,
                    'panel_bg': panel_v,
                    'text': txt_v,
                    'accent': acc_v
                }

                # If no explicit mapping existed, map the base theme to this subdued variant
                try:
                    self.SUBDUED_THEME_MAP.setdefault(base_name, subdued_key)
                except Exception:
                    pass
        except Exception:
            # If QColor isn't available, skip auto-generation silently
            pass

        # Load custom themes from settings
        self.load_custom_themes()
        
        # Automatically clean up orphaned themes on startup (silent)
        self.scan_and_cleanup_themes()
        
        # Set up file watcher for .gsfmt files if available
        self.setup_theme_file_watcher()

        # Subdued mode flag (persisted separately)
        try:
            settings = QSettings('garysfm', 'garysfm')
            stored_subdued = settings.value('subdued_mode', None)
            if stored_subdued is not None:
                self.subdued_mode = True if str(stored_subdued).lower() in ('1', 'true', 'yes') else False
                # If subdued mode is enabled, restore the saved subdued theme
                if self.subdued_mode:
                    stored_subdued_theme = settings.value('subdued_theme', None)
                    if stored_subdued_theme:
                        self.color_theme = stored_subdued_theme
            else:
                self.subdued_mode = False
        except Exception:
            self.subdued_mode = False

        # Strong mode flag (persisted separately)
        try:
            settings = QSettings('garysfm', 'garysfm')
            stored_strong = settings.value('strong_mode', None)
            if stored_strong is not None:
                self.strong_mode = True if str(stored_strong).lower() in ('1', 'true', 'yes') else False
                # If strong mode is enabled, restore the saved strong theme
                if self.strong_mode:
                    stored_strong_theme = settings.value('strong_theme', None)
                    if stored_strong_theme and stored_strong_theme in self.STRONG_COLOR_THEMES:
                        self.color_theme = stored_strong_theme
                    else:
                        # If no valid strong theme is saved, use the first available strong theme
                        try:
                            self.color_theme = next(iter(self.STRONG_COLOR_THEMES.keys()))
                        except StopIteration:
                            self.color_theme = 'Default Light'  # fallback
            else:
                self.strong_mode = False
        except Exception:
            self.strong_mode = False

        # Load persisted color theme and dark mode preference
        # Compute recommended text color for themes based on contrast ratio (black or white)
        try:
            from PyQt5.QtGui import QColor

            def _rel_luminance(qc):
                r, g, b, _ = qc.getRgb()
                rs = r / 255.0
                gs = g / 255.0
                bs = b / 255.0
                def _adj(c):
                    return c / 12.92 if c <= 0.03928 else ((c + 0.055) / 1.055) ** 2.4
                return 0.2126 * _adj(rs) + 0.7152 * _adj(gs) + 0.0722 * _adj(bs)

            def _contrast_ratio(l1, l2):
                a = max(l1, l2)
                b = min(l1, l2)
                return (a + 0.05) / (b + 0.05)

            def _pick_text_for_bg(bg_hex, current_text_hex=None):
                try:
                    bg = QColor(bg_hex)
                    l_bg = _rel_luminance(bg)
                    # contrast with black
                    l_black = 0.0
                    l_white = 1.0
                    contrast_black = _contrast_ratio(l_bg, l_black)
                    contrast_white = _contrast_ratio(l_bg, l_white)
                    # If current_text provided, prefer it when adequate
                    if current_text_hex:
                        cur = QColor(current_text_hex)
                        l_cur = _rel_luminance(cur)
                        if _contrast_ratio(l_bg, l_cur) >= 4.5:
                            return current_text_hex
                    return '#000000' if contrast_black >= contrast_white else '#ffffff'
                except Exception:
                    return current_text_hex or '#000000'

            # Annotate light themes
            for k, v in self.COLOR_THEMES.items():
                try:
                    win_bg = v.get('window_bg') or v.get('panel_bg')
                    cur_text = v.get('text')
                    v['recommended_text'] = _pick_text_for_bg(win_bg, cur_text)
                except Exception:
                    v['recommended_text'] = v.get('text', '#000000')

            # Annotate dark themes similarly
            for k, v in self.DARK_COLOR_THEMES.items():
                try:
                    win_bg = v.get('window_bg') or v.get('panel_bg')
                    cur_text = v.get('text')
                    v['recommended_text'] = _pick_text_for_bg(win_bg, cur_text)
                except Exception:
                    v['recommended_text'] = v.get('text', '#ffffff')
        except Exception:
            # If QColor isn't available at this phase, skip recommendations silently
            pass
        try:
            settings = QSettings('garysfm', 'garysfm')
            stored_theme = settings.value('color_theme', None)
            # Only load regular theme if not in subdued mode or strong mode
            if not getattr(self, 'subdued_mode', False) and not getattr(self, 'strong_mode', False):
                if stored_theme and stored_theme in self.COLOR_THEMES:
                    self.color_theme = stored_theme
                else:
                    self.color_theme = 'Default Light'
            stored_dark = settings.value('dark_mode', None)
            if stored_dark is not None:
                # QSettings may return 'true'/'false' or bool
                self.dark_mode = True if str(stored_dark).lower() in ('1', 'true', 'yes') else False
        except Exception:
            if not getattr(self, 'subdued_mode', False) and not getattr(self, 'strong_mode', False):
                self.color_theme = 'Default Light'
        
        # View panel states (default hidden for cleaner interface)
        self.show_tree_view = False
        self.show_right_panel = True  # Right panel visible by default
        self.show_transfer_manager = False  # Transfer manager hidden by default
        self.search_visible = False
        
        # Define cleanup methods before they're used
        def _cleanup_thumbnails():
            """Clean up thumbnail cache memory"""
            try:
                if hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                    self.thumbnail_cache.clear_memory_cache()
                    # Break circular references
                    if hasattr(self.thumbnail_cache, 'memory_cache'):
                        del self.thumbnail_cache.memory_cache
                        self.thumbnail_cache.memory_cache = OrderedDict()
            except Exception as e:
                # ...removed cache debug message...
                pass

        def _cleanup_virtual_loader():
            """Clean up virtual file loader resources"""
            try:
                if hasattr(self, 'virtual_file_loader') and self.virtual_file_loader:
                    self.virtual_file_loader.cleanup()
                    # Clear references to prevent memory leaks
                    if hasattr(self.virtual_file_loader, 'loaded_chunks'):
                        self.virtual_file_loader.loaded_chunks.clear()
                    if hasattr(self.virtual_file_loader, 'directory_cache'):
                        self.virtual_file_loader.directory_cache.clear()
            except Exception as e:
                print(f"Error in virtual loader cleanup: {e}")
        
        # Bind cleanup methods to self
        self._cleanup_thumbnails = _cleanup_thumbnails
        self._cleanup_virtual_loader = _cleanup_virtual_loader
        
        # Initialize performance optimization components (FIXED CLEANUP)
        self.thumbnail_cache = ThumbnailCache()
        self.virtual_file_loader = VirtualFileLoader()
        self.memory_manager = MemoryManager()
        self.background_monitor = BackgroundFileMonitor()
        
        # Initialize advanced search engine
        self.search_engine = SearchEngine()
        
        # Initialize cloud storage and file organization systems
        self.auth_manager = AuthenticationManager()
        self.cloud_sync_manager = CloudSyncManager()
        self.tag_manager = TagManager()
        self.collection_manager = CollectionManager(self.tag_manager)
        
        # Register cleanup callbacks for memory management
        if self.memory_manager:
            self.memory_manager.add_cleanup_callback(self._cleanup_thumbnails)
            self.memory_manager.add_cleanup_callback(self._cleanup_virtual_loader)
            self.memory_manager.add_cleanup_callback(lambda: self.search_engine.cleanup())
        
        # Initialize managers first (needed for settings loading)
        self.clipboard_manager = ClipboardHistoryManager()
        self.view_mode_manager = ViewModeManager()
        # Register drive change callback to update My Computer tabs/tree
        try:
            def _on_drives_changed(drives):
                try:
                    # Update left tree view if showing My Computer
                    try:
                        if hasattr(self, 'tree_view') and self.path_label and self.path_label.text() == 'My Computer':
                            try:
                                root_index = self.model.index("")
                                self.tree_view.setRootIndex(root_index)
                            except Exception:
                                pass
                    except Exception:
                        pass

                    # Refresh any open My Computer tabs
                    try:
                        if hasattr(self, 'tab_manager') and self.tab_manager:
                            for t in list(self.tab_manager.tabs):
                                try:
                                    if getattr(t, 'is_drive_list', False):
                                        try:
                                            t.refresh_current_view()
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                    except Exception:
                        pass
                except Exception:
                    pass
            self.background_monitor.add_drive_callback(_on_drives_changed)
        except Exception:
            pass
    # ...existing code for UI setup, actions, toolbar, etc...
    # ...existing code for status bar, shortcuts, restoring session, etc...
    # Now load persistent view mode as the last step
    # ...existing code...
    # Restore tab session from previous launch
    # ...existing code...
        # Load persistent user settings from JSON (simple flat structure)
        try:
            self.icon_view_use_icons_only = True
            self.is_dual_pane_mode = False
            if os.path.exists(self.SETTINGS_FILE):
                with open(self.SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    settings_json = json.load(f)
                # backward-compatible keys
                self.icon_view_use_icons_only = bool(settings_json.get('icon_view_use_icons_only', settings_json.get('user_prefs', {}).get('icon_view_use_icons_only', True)))
                self.is_dual_pane_mode = bool(settings_json.get('dual_pane_mode', False))
        except Exception:
            # Default if anything goes wrong
            self.icon_view_use_icons_only = True
            self.is_dual_pane_mode = False
        
        self.last_dir = self.load_last_dir() or QDir.rootPath()
        self.selected_icon = None  # Track selected icon
        self.selected_items = []  # Track multiple selected items
        self.error_count = 0  # Track errors for improved error handling
        self.current_search_results = []
        
        # Main layout with splitter for resizable panes
        self.main_widget = QWidget()
        self.main_layout = QVBoxLayout()
        # Minimize spacing between toolbar and content
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)
        self.main_widget.setLayout(self.main_layout)
        self.setCentralWidget(self.main_widget)

        # Toolbar for quick access
        self.create_toolbar()

        # Initialize bookmark system
        self.bookmark_manager = BookmarkManager()

        # Add breadcrumb navigation at the top
        self.breadcrumb = BreadcrumbWidget()
        self.breadcrumb.pathClicked.connect(self.navigate_to_path)
        self.main_layout.addWidget(self.breadcrumb)

        # Search and filter widget (enhanced version with advanced capabilities)
        self.search_filter = SearchFilterWidget()
        # Connect search results to display handler
        self.search_filter.searchRequested.connect(self.handle_advanced_search_results)
        # Note: The new SearchFilterWidget is self-contained and doesn't need a searchRequested connection
        self.search_filter.hide()  # Initially hidden, can be toggled
        self.main_layout.addWidget(self.search_filter)

        # Main content splitter (horizontal)
        self.main_splitter = QSplitter(Qt.Horizontal)
        self.main_layout.addWidget(self.main_splitter)

        # Left pane: tree view and controls
        self.left_pane = QWidget()
        self.left_layout = QVBoxLayout()
        self.left_pane.setLayout(self.left_layout)
        self.main_splitter.addWidget(self.left_pane)

        # Tree view setup
        self.setup_tree_view()

        # Middle splitter for main view and preview
        self.content_splitter = QSplitter(Qt.Horizontal)
        self.main_splitter.addWidget(self.content_splitter)

        # Center pane: file view with multiple view modes
        self.center_pane = QWidget()
        self.center_layout = QVBoxLayout()
        # Remove vertical spacing between toolbar and tabs
        self.center_layout.setContentsMargins(0, 0, 0, 0)
        self.center_layout.setSpacing(0)
        self.center_pane.setLayout(self.center_layout)
        self.content_splitter.addWidget(self.center_pane)

        # Multiple view widgets
        self.setup_multiple_views()

        # View mode controls (My Computer button etc.) — created after tab manager exists
        self.setup_view_mode_controls()

        # Right pane: tabbed widget for preview and cloud/tagging features
        self.right_pane_tabs = QTabWidget()
        
        # Preview pane
        self.preview_pane = PreviewPane()
        self.right_pane_tabs.addTab(self.preview_pane, "Preview")
        
        # Cloud sync widget
        self.cloud_sync_widget = CloudSyncWidget(self.cloud_sync_manager, self.auth_manager)
        self.right_pane_tabs.addTab(self.cloud_sync_widget, "Cloud Sync")
        
        # Tags and collections widget
        self.tags_widget = TagsWidget(self.tag_manager)
        self.right_pane_tabs.addTab(self.tags_widget, "Tags")
        
        self.collections_widget = CollectionsWidget(self.collection_manager)
        self.right_pane_tabs.addTab(self.collections_widget, "Collections")
        
        self.content_splitter.addWidget(self.right_pane_tabs)

        # Set initial splitter proportions
        self.main_splitter.setSizes([200, 800])  # Tree view : Content
        self.content_splitter.setSizes([600, 300])  # File view : Right pane tabs

        # Make splitters collapsible
        self.main_splitter.setCollapsible(0, True)
        self.content_splitter.setCollapsible(1, True)

        # Add transfer manager widget at the bottom
        self.transfer_manager_widget = TransferManagerWidget(self)
        self.transfer_manager_widget.setMaximumHeight(200)  # Limit height
        self.transfer_manager_widget.hide()  # Initially hidden
        self.main_layout.addWidget(self.transfer_manager_widget)

        self.setWindowTitle('garysfm - Enhanced File Manager')
        self.resize(1200, 700)

        # Setup macOS-specific window behavior
        PlatformUtils.setup_macos_window_behavior(self)

        # Initialize file system model
        self.setup_file_system_model()

        # Setup menus with enhanced options
        self.setup_enhanced_menus()

        # Load persisted event-filter verbose setting (controls debug prints from eventFilter helpers)
        try:
            settings = QSettings('garysfm', 'garysfm')
            val = settings.value('event_filter_verbose', False)
            # normalize possible string values
            global EVENT_FILTER_VERBOSE
            if isinstance(val, str):
                EVENT_FILTER_VERBOSE = True if val.lower() in ('true', '1') else False
            else:
                EVENT_FILTER_VERBOSE = bool(val)
        except Exception:
            pass

        # For right-click context menu
        self.current_right_clicked_path = None

        # Add status bar
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)

        # Setup keyboard shortcuts
        self.setup_enhanced_keyboard_shortcuts()

        # Migrate old sort settings to new deterministic format
        self.migrate_tab_sort_settings()

        # Restore tab session from previous launch
        self.restore_tab_session()
        # Load persistent view mode only after tab manager and tabs are restored
        self.load_view_mode()

        # Connect signals from current active tab
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            self.connect_tab_signals(current_tab)

        self.selected_items = []

        # Restore view states from settings
        self.restore_view_states()

        # Apply dark mode if it was saved
        self.apply_dark_mode()
        
        # Ensure theme is applied after all initialization
        self.apply_theme()
        
        # Load saved QSS stylesheet if enabled (after theme application, with 0.013-second delay)
        QTimer.singleShot(13, self.load_saved_qss_on_startup)

        # Enable drag and drop
        self.setAcceptDrops(True)
        self.update_dark_mode_checkmark()
        QTimer.singleShot(100, self.refresh_all_themes)

        # Initialize status bar after everything is set up
        QTimer.singleShot(0, self.safe_update_status_bar)

    def dragEnterEvent(self, event):
        """Accept drag event if it contains URLs (files/folders)."""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
            # Add visual feedback for the main window
            if hasattr(self, 'status_bar'):
                urls = event.mimeData().urls()
                file_count = len(urls)
                self.status_bar.showMessage(f"Drop {file_count} item{'s' if file_count != 1 else ''} to open or navigate", 2000)
        else:
            event.ignore()

    def dragLeaveEvent(self, event):
        """Clear status message when drag leaves the window."""
        if hasattr(self, 'status_bar'):
            self.status_bar.clearMessage()
        event.accept()

    def dropEvent(self, event):
        """Handle drop event for files/folders."""
        # Clear status message
        if hasattr(self, 'status_bar'):
            self.status_bar.clearMessage()
            
        if event.mimeData().hasUrls():
            paths = [url.toLocalFile() for url in event.mimeData().urls()]
            # You can customize what to do with the dropped files/folders here
            # For example, open them, copy, or display in the UI
            self.handle_dropped_files(paths)
            event.acceptProposedAction()
        else:
            event.ignore()

    def handle_dropped_files(self, paths):
        """Custom handler for dropped files/folders."""
        import os
        if not paths:
            return
        
        try:
            # Check if we have any active tabs to navigate to the dropped files
            tab_manager = getattr(self, 'tab_manager', None)
            if tab_manager and hasattr(tab_manager, 'current_tab'):
                current_tab = tab_manager.current_tab()
                if current_tab and hasattr(current_tab, 'navigate_to_path'):
                    # If only one path and it's a directory, navigate to it
                    if len(paths) == 1 and os.path.isdir(paths[0]):
                        current_tab.navigate_to_path(paths[0])
                        return
                    
                    # If multiple paths or files, navigate to the parent directory of the first path
                    if paths:
                        parent_dir = os.path.dirname(paths[0])
                        if os.path.isdir(parent_dir):
                            current_tab.navigate_to_path(parent_dir)
                            # Optional: Select the dropped files in the view
                            if hasattr(current_tab, 'select_items'):
                                filenames = [os.path.basename(p) for p in paths]
                                QTimer.singleShot(100, lambda: current_tab.select_items(filenames))
                            return
            
            # Fallback: show SourceForge upload dialog if available
            if hasattr(self, 'show_sourceforge_upload_dialog'):
                self.show_sourceforge_upload_dialog(prefill_paths=paths, auto_start=False)
            else:
                # Final fallback: just print the dropped paths
                print("Dropped files/folders:", paths)
                
        except Exception as e:
            # Error fallback: just print the dropped paths
            print(f"Error handling dropped files: {e}")
            print("Dropped files/folders:", paths)

    def create_toolbar(self):
        """Create the main toolbar"""
        self.toolbar = QToolBar()
        # Make toolbar more compact to reduce vertical space
        self.toolbar.setToolButtonStyle(Qt.ToolButtonTextOnly)
        self.toolbar.setIconSize(QSize(16, 16))  # Smaller icons
        self.toolbar.setContentsMargins(0, 0, 0, 0)  # Remove toolbar margins
        self.toolbar.setStyleSheet("QToolBar { border: 0px; padding: 0px; margin: 0px; }")
        self.addToolBar(self.toolbar)

        # Navigation buttons
        self.back_action = QAction("< Back", self)
        self.forward_action = QAction("> Forward", self)
        self.up_action = QAction("^ Up", self)
        self.my_computer_action = QAction("🖥️ My Computer", self)
        self.back_action.triggered.connect(self.go_back)
        self.forward_action.triggered.connect(self.go_forward)
        self.up_action.triggered.connect(self.go_up)
        self.my_computer_action.triggered.connect(self.show_my_computer_main)

        self.toolbar.addAction(self.back_action)
        self.toolbar.addAction(self.forward_action)
        self.toolbar.addAction(self.up_action)
        self.toolbar.addAction(self.my_computer_action)
        self.toolbar.addSeparator()

        # Bookmark actions
        self.add_bookmark_action = QAction("+ Bookmark", self)
        self.add_bookmark_action.triggered.connect(self.add_current_bookmark)
        self.toolbar.addAction(self.add_bookmark_action)
        
        self.bookmarks_dropdown_action = QAction("☆ Bookmarks", self)
        self.bookmarks_dropdown_action.triggered.connect(self.show_bookmarks_dropdown)
        self.toolbar.addAction(self.bookmarks_dropdown_action)
        
        self.manage_bookmarks_action = QAction("⚙ Manage", self)
        self.manage_bookmarks_action.triggered.connect(self.show_bookmark_manager)
        self.toolbar.addAction(self.manage_bookmarks_action)



    def open_network_folder_dialog(self):
        """Show a dialog to connect to a network (SMB) folder and open it in a new tab."""
        dlg = QDialog(self)
        dlg.setWindowTitle("Connect to Network Share (SMB)")
        layout = QFormLayout(dlg)
        server_edit = QLineEdit()
        share_edit = QLineEdit()
        user_edit = QLineEdit()
        pass_edit = QLineEdit()
        pass_edit.setEchoMode(QLineEdit.Password)
        domain_edit = QLineEdit()
        path_edit = QLineEdit()
        layout.addRow("Server:", server_edit)
        layout.addRow("Share:", share_edit)
        layout.addRow("Username:", user_edit)
        layout.addRow("Password:", pass_edit)
        layout.addRow("Domain (optional):", domain_edit)
        layout.addRow("Path (e.g. / or /folder):", path_edit)
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        layout.addRow(buttons)
        def on_connect():
            from PyQt5.QtWidgets import QMessageBox
            server = server_edit.text().strip()
            share = share_edit.text().strip()
            user = user_edit.text().strip()
            passwd = pass_edit.text()
            domain = domain_edit.text().strip()
            path = path_edit.text().strip() or "/"
            if not (server and share and user and passwd):
                QMessageBox.warning(dlg, "Missing Info", "Please fill in all required fields.")
                return
            try:
                self.tab_manager.add_smb_tab(server, share, user, passwd, domain, path)
                dlg.accept()
            except Exception as e:
                QMessageBox.critical(dlg, "Connection Error", str(e))
        buttons.accepted.connect(on_connect)
        buttons.rejected.connect(dlg.reject)
        dlg.exec_()

    def setup_tree_view(self):
        """Setup the tree view for folder navigation"""
        self.model = QFileSystemModel()

        # Always show filesystem root (drive list) in the tree view
        # Use empty rootPath so QFileSystemModel exposes all drives on Windows
        self.model.setRootPath("")

        # Only show directories (and drives) in the tree view — no files
        # Include NoDotAndDotDot and Drives to ensure root drives are visible on Windows
        self.model.setFilter(QDir.Drives | QDir.Dirs | QDir.NoDotAndDotDot)

        self.tree_view = QTreeView()
        self.tree_view.setModel(self.model)

        # Always show drives/root in the tree for navigation (use empty root to list drives)
        try:
            root_index = self.model.index("")
            self.tree_view.setRootIndex(root_index)
        except Exception:
            # Fallback to home dir if root can't be used for some reason
            home_dir = PlatformUtils.get_home_directory()
            self.tree_view.setRootIndex(self.model.index(home_dir))
            self.last_dir = home_dir
            self.current_folder = home_dir

        self.tree_view.clicked.connect(self.on_tree_item_clicked)
        self.tree_view.doubleClicked.connect(self.on_double_click)
        self.left_layout.addWidget(self.tree_view)

    def show_my_computer_main(self):
        """Open My Computer in a new tab within the selected pane."""
        try:
            # Get the current tab manager to work with the active pane
            current_tab_manager = self.get_current_tab_manager()
            
            if current_tab_manager and hasattr(current_tab_manager, 'new_tab'):
                # Create a new tab with My Computer in the selected pane
                current_tab_manager.new_tab("__MY_COMPUTER__")
                return
            
            # Fallback: try alternative tab creation methods
            if current_tab_manager:
                current_tab = current_tab_manager.get_current_tab()
                
                # Check if there's an open_my_computer_tab method
                if hasattr(current_tab_manager, 'open_my_computer_tab'):
                    current_tab_manager.open_my_computer_tab()
                    return
                elif current_tab and hasattr(current_tab, 'navigate_to'):
                    # Last resort: navigate current tab if no new tab method available
                    current_tab.navigate_to("__MY_COMPUTER__")
                    return
            
            # Final fallback: use the original tree view method
            if hasattr(self, 'tree_view') and hasattr(self, 'model'):
                root_index = self.model.index("")
                self.tree_view.setRootIndex(root_index)
                if hasattr(self, 'path_label'):
                    self.path_label.setText("My Computer")
                return
                
        except Exception as e:
            print(f"Error opening My Computer: {e}")
            # Final emergency fallback
            try:
                if hasattr(self, 'tree_view') and hasattr(self, 'model'):
                    from PyQt5.QtCore import QDir
                    self.tree_view.setRootIndex(self.model.index(QDir.rootPath()))
                    if hasattr(self, 'path_label'):
                        self.path_label.setText("My Computer")
            except Exception:
                pass
            try:
                self.tree_view.setRootIndex(self.model.index(QDir.rootPath()))
                self.path_label.setText("My Computer")
            except Exception:
                pass

    def restore_filesystem_root(self):
        """Restore previous tree root (if any) or home directory."""
        try:
            if getattr(self, '_previous_tree_root', None):
                idx = self.model.index(self._previous_tree_root)
                self.tree_view.setRootIndex(idx)
                self.path_label.setText(self._previous_tree_root)
            else:
                home = PlatformUtils.get_home_directory()
                self.tree_view.setRootIndex(self.model.index(home))
                self.path_label.setText(home)
        except Exception:
            pass

    def setup_view_mode_controls(self):
        """Setup view mode control buttons"""
        controls_layout = QHBoxLayout()

        # View mode buttons group
        self.view_group = QButtonGroup()

        controls_layout.addStretch()

        # Insert controls at the top so they remain visible above the tab manager
        try:
            self.center_layout.insertLayout(0, controls_layout)
        except Exception:
            # Fallback to append if insertLayout fails for any reason
            self.center_layout.addLayout(controls_layout)

    def setup_multiple_views(self):
        """Setup tabbed interface for file management"""
        # Initialize dual pane mode state
        dual_pane_requested = getattr(self, 'is_dual_pane_mode', False)
        self.is_dual_pane_mode = False  # Reset to start in single pane mode
        self.dual_pane_manager = None
        
        # Replace the simple view stack with tab manager (don't create initial tab yet)
        self.tab_manager = TabManager(parent=self, create_initial_tab=False)
        
        # Set up callback to save tab session and update sort menu on changes
        self.tab_manager.set_tab_changed_callback(self.on_tab_changed)
        
        self.center_layout.addWidget(self.tab_manager)
        
        # Setup background operations manager
        self.active_operations = []
        self.operation_progress_dialogs = []
        
        # Store the dual pane preference for later initialization
        self._dual_pane_requested = dual_pane_requested
    
    def connect_tab_signals(self, tab):
        """Connect signals from a tab to main window handlers"""
        if tab:
            icon_container = getattr(tab, 'icon_container', None) if hasattr(tab, 'get_icon_container_safely') else None
            if not icon_container and hasattr(tab, 'get_icon_container_safely'):
                icon_container = tab.get_icon_container_safely()
            
            if icon_container:
                try:
                    icon_container.emptySpaceClicked.connect(self.deselect_icons)
                    icon_container.emptySpaceRightClicked.connect(self.empty_space_right_clicked)
                    icon_container.selectionChanged.connect(self.on_selection_changed)
                except AttributeError:
                    # Handle case where icon_container exists but doesn't have expected signals
                    pass
    
    def start_background_operation(self, operation_type, source_paths, destination_path=None):
        """Start a background file operation with progress dialog"""
        operation = AsyncFileOperation(source_paths, destination_path, operation_type)
        self.active_operations.append(operation)
        
        # Create enhanced progress dialog
        operation_name = operation_type.title()
        progress_dialog = EnhancedProgressDialog(operation_name, len(source_paths), self)
        self.operation_progress_dialogs.append(progress_dialog)
        
        # Start operation
        progress_dialog.start_operation(operation)
        progress_dialog.show()
        
        # Clean up when finished
        progress_dialog.finished.connect(lambda: self.cleanup_operation(operation, progress_dialog))
        
        return operation
    
    def cleanup_operation(self, operation, progress_dialog):
        """Clean up completed operation"""
        if operation in self.active_operations:
            self.active_operations.remove(operation)
        if progress_dialog in self.operation_progress_dialogs:
            self.operation_progress_dialogs.remove(progress_dialog)
        
        # Refresh current view
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            current_tab.refresh_current_view()
    
    def close_current_tab(self):
        """Close the currently active tab"""
        current_tab_manager = self.get_current_tab_manager()
        current_index = current_tab_manager.tab_bar.currentIndex()
        if current_index >= 0:
            current_tab_manager.close_tab(current_index)

    def setup_menu_bar(self):
        """Setup enhanced menu system"""
        menu_bar = self.menuBar()
        
        # Detail/Table view
        self.table_view = QTableView()
        self.table_model = QFileSystemModel()
        self.table_view.setModel(self.table_model)
        self.table_view.clicked.connect(self.on_table_item_clicked)
        self.table_view.doubleClicked.connect(self.on_table_double_click)
        # Configure table view
        self.table_view.horizontalHeader().setStretchLastSection(True)
        self.table_view.setSelectionBehavior(QTableView.SelectRows)
        self.table_view.setSortingEnabled(True)
        self.view_stack.addWidget(self.table_view)
        
        # Set initial view
        # ensure thumbnail view is current if present
        try:
            self.view_stack.setCurrentWidget(self.thumbnail_view_widget)
        except Exception:
            pass

    def setup_file_system_model(self):
        """Initialize the file system model"""
        pass  # Models are set up in individual view setup methods

    def setup_enhanced_menus(self):
        """Setup enhanced menu system (clean, consistent implementation)."""
        menu_bar = self.menuBar()

        # macOS native menu bar support
        if PlatformUtils.is_macos():
            menu_bar.setNativeMenuBar(True)

        main_modifier = PlatformUtils.get_modifier_key()

        # File menu
        file_menu = menu_bar.addMenu("File")
        self.new_tab_action = QAction("New Tab", self)
        self.new_tab_action.setShortcut(f"{main_modifier}+T")
        self.new_tab_action.triggered.connect(lambda: self.get_current_tab_manager().new_tab())
        file_menu.addAction(self.new_tab_action)

        self.close_tab_action = QAction("Close Tab", self)
        self.close_tab_action.setShortcut(f"{main_modifier}+W")
        self.close_tab_action.triggered.connect(self.close_current_tab)
        file_menu.addAction(self.close_tab_action)

        file_menu.addSeparator()

        self.network_shares_action = QAction("Network Shares...", self)
        self.network_shares_action.setShortcut(f"{main_modifier}+K")
        self.network_shares_action.triggered.connect(self.open_network_folder_dialog)
        file_menu.addAction(self.network_shares_action)

        file_menu.addSeparator()

        self.new_folder_action = QAction("New Folder", self)
        self.new_folder_action.setShortcut(f"{main_modifier}+Shift+N")
        self.new_folder_action.triggered.connect(self.create_new_folder)
        file_menu.addAction(self.new_folder_action)

        file_menu.addSeparator()

        self.properties_action = QAction("Properties", self)
        self.properties_action.setShortcut("Alt+Return")
        self.properties_action.triggered.connect(self.show_properties_selected_item)
        file_menu.addAction(self.properties_action)

        file_menu.addSeparator()
        self.exit_action = QAction("Exit", self)
        self.exit_action.setShortcut(f"{main_modifier}+Q")
        self.exit_action.triggered.connect(self.close)
        file_menu.addAction(self.exit_action)

        file_menu.addSeparator()
        self.upload_github_action = QAction("Upload to GitHub Release...", self)
        self.upload_github_action.triggered.connect(self.show_github_upload_dialog)
        file_menu.addAction(self.upload_github_action)

        self.upload_sourceforge_action = QAction("Upload to SourceForge...", self)
        self.upload_sourceforge_action.triggered.connect(self.show_sourceforge_upload_dialog)
        file_menu.addAction(self.upload_sourceforge_action)

        # Edit menu
        edit_menu = menu_bar.addMenu("Edit")
        self.cut_action = QAction("Cut", self)
        self.copy_action = QAction("Copy", self)
        self.paste_action = QAction("Paste", self)
        self.delete_action = QAction("Delete", self)
        
        # Set keyboard shortcuts for cut, copy, paste
        self.cut_action.setShortcut(f"{main_modifier}+X")
        self.copy_action.setShortcut(f"{main_modifier}+C")
        self.paste_action.setShortcut(f"{main_modifier}+V")
        self.delete_action.setShortcut("Delete")
        
        self.cut_action.triggered.connect(self.cut_action_triggered)
        self.copy_action.triggered.connect(self.copy_action_triggered)
        self.paste_action.triggered.connect(self.paste_action_triggered)
        self.delete_action.triggered.connect(self.delete_selected_items)
        edit_menu.addAction(self.cut_action)
        edit_menu.addAction(self.copy_action)
        edit_menu.addAction(self.paste_action)
        
        # Clipboard history
        self.clipboard_history_action = QAction("Clipboard History...", self)
        self.clipboard_history_action.triggered.connect(self.show_clipboard_history)
        edit_menu.addAction(self.clipboard_history_action)
        
        edit_menu.addSeparator()
        edit_menu.addAction(self.delete_action)

        edit_menu.addSeparator()
        self.select_all_action = QAction("Select All", self)
        self.select_all_action.setShortcut("Ctrl+A")
        self.select_all_action.triggered.connect(self.select_all_items)
        edit_menu.addAction(self.select_all_action)

        edit_menu.addSeparator()
        self.bulk_rename_action = QAction("Bulk Rename...", self)
        self.bulk_rename_action.triggered.connect(self.show_bulk_rename_dialog)
        edit_menu.addAction(self.bulk_rename_action)

        self.advanced_operations_action = QAction("Advanced Operations...", self)
        self.advanced_operations_action.triggered.connect(self.show_advanced_operations)
        edit_menu.addAction(self.advanced_operations_action)

        # View menu
        view_menu = menu_bar.addMenu("View")
        
        # Theme submenu - moved to top of view menu
        if not hasattr(self, '_theme_menu_added'):
            theme_menu = view_menu.addMenu('Theme')
            self.theme_menu = theme_menu  # Store reference for later updates
            self._theme_actions = {}

            # Add QSS stylesheet items directly to themes menu
            # Add "Default Theme" action
            reset_action = QAction('Default Theme', self)
            reset_action.triggered.connect(self.clear_qss_stylesheet)
            theme_menu.addAction(reset_action)
            
            theme_menu.addSeparator()
            
            # Load available QSS files and add them directly to themes menu
            qss_files = self.load_qss_files_from_folder()
            
            if qss_files:
                # Add actions for each QSS file with color swatches
                for qss_file in qss_files:
                    action = QAction(qss_file['name'], self)
                    action.setToolTip(f"Apply QSS stylesheet: {qss_file['filename']}")
                    
                    # Extract colors and create swatch
                    try:
                        qss_colors = self.extract_qss_colors(qss_file['path'])
                        swatch_icon = self.create_theme_swatch(qss_colors, 'regular')
                        action.setIcon(swatch_icon)
                    except Exception:
                        # Continue without icon if swatch creation fails
                        pass
                    
                    # Create a lambda that captures the path
                    def make_qss_handler(qss_path):
                        return lambda: self.load_qss_file(qss_path)
                    
                    action.triggered.connect(make_qss_handler(qss_file['path']))
                    theme_menu.addAction(action)
            else:
                no_files_action = QAction('No QSS files found', self)
                no_files_action.setEnabled(False)
                theme_menu.addAction(no_files_action)
            
            theme_menu.addSeparator()

            # Create Classic Themes submenu containing all theme variants
            classic_menu = theme_menu.addMenu('Classic Themes')
            
            # Add Theme Color Customization action to Classic Themes submenu
            theme_customize_action = QAction('Theme Color Customization...', self)
            theme_customize_action.triggered.connect(self.open_theme_color_customization)
            classic_menu.addAction(theme_customize_action)
            
            # Add Dark Mode toggle to Classic Themes submenu
            if not hasattr(self, '_dark_mode_action_added'):
                self.dark_mode_action = QAction("Dark Mode", self, checkable=True)
                self.dark_mode_action.triggered.connect(self.toggle_dark_mode)
                classic_menu.addAction(self.dark_mode_action)
                self._dark_mode_action_added = True
            
            # Add separator before theme variants
            classic_menu.addSeparator()
            
            # Create Standard Themes submenu within Classic Themes
            all_theme_names = sorted(self.COLOR_THEMES.keys())
            
            if all_theme_names:
                standard_menu = classic_menu.addMenu('Standard Themes')
                
                for name in all_theme_names:
                    a = QAction(name, self, checkable=True)
                    a._is_theme_action = True  # Mark as theme action for later removal
                    
                    theme = self.COLOR_THEMES.get(name, {})
                    
                    # Create a swatch icon using the helper function
                    swatch_icon = self.create_theme_swatch(theme, 'regular')
                    if swatch_icon:
                        a.setIcon(swatch_icon)
                    
                    # Set up the action trigger for standard themes
                    def _set_standard_theme(checked, name=name):
                        try:
                            if checked:
                                # Disable subdued mode and strong mode, set regular theme
                                self.subdued_mode = False
                                self.strong_mode = False
                                try:
                                    settings = QSettings('garysfm', 'garysfm')
                                    settings.setValue('subdued_mode', False)
                                    settings.setValue('strong_mode', False)
                                    # Save the regular theme name
                                    settings.setValue('color_theme', name)
                                except Exception:
                                    pass
                                self.set_color_theme(name)
                        except Exception:
                            pass
                    a.triggered.connect(_set_standard_theme)
                    standard_menu.addAction(a)
                    self._theme_actions[name] = a
            
            # Create subdued themes submenu within Classic Themes only if there are subdued themes
            subdued_names = sorted(self.SUBDUED_COLOR_THEMES.keys())
            if subdued_names:
                subdued_menu = classic_menu.addMenu('Subdued Themes')
                
                # Create actions for subdued themes
                for name in subdued_names:
                    a = QAction(name, self, checkable=True)
                    
                    theme = self.SUBDUED_COLOR_THEMES.get(name, {})
                    
                    # Create a swatch icon using the helper function
                    swatch_icon = self.create_theme_swatch(theme, 'subdued')
                    if swatch_icon:
                        a.setIcon(swatch_icon)
                    
                    # Set up the action trigger for subdued themes
                    def _set_subdued_theme(checked, name=name):
                        try:
                            if checked:
                                # Enable subdued mode and set this theme
                                self.subdued_mode = True
                                self.strong_mode = False  # Disable strong mode
                                try:
                                    settings = QSettings('garysfm', 'garysfm')
                                    settings.setValue('subdued_mode', True)
                                    settings.setValue('strong_mode', False)
                                    # Save the subdued theme name
                                    settings.setValue('subdued_theme', name)
                                except Exception:
                                    pass
                                self.color_theme = name
                                self.apply_theme()
                                self.refresh_all_themes()
                        except Exception:
                            pass
                    a.triggered.connect(_set_subdued_theme)
                    subdued_menu.addAction(a)
                    self._theme_actions[name] = a
            
            # Create strong themes submenu within Classic Themes
            strong_menu = classic_menu.addMenu('Strong Themes')
            strong_names = sorted(self.STRONG_COLOR_THEMES.keys())
            
            # Create actions for strong themes
            for name in strong_names:
                a = QAction(name, self, checkable=True)
                
                theme = self.STRONG_COLOR_THEMES.get(name, {})
                
                # Create a swatch icon using the helper function
                swatch_icon = self.create_theme_swatch(theme, 'strong')
                if swatch_icon:
                    a.setIcon(swatch_icon)
                
                # Set up the action trigger for strong themes
                def _set_strong_theme(checked, name=name):
                    try:
                        if checked:
                            # Enable strong mode and set this theme
                            self.strong_mode = True
                            self.subdued_mode = False  # Disable subdued mode
                            try:
                                settings = QSettings('garysfm', 'garysfm')
                                settings.setValue('strong_mode', True)
                                settings.setValue('subdued_mode', False)
                                # Save the strong theme name
                                settings.setValue('strong_theme', name)
                            except Exception:
                                pass
                            self.color_theme = name
                            self.apply_theme()
                            self.refresh_all_themes()
                    except Exception:
                        pass
                a.triggered.connect(_set_strong_theme)
                strong_menu.addAction(a)
                self._theme_actions[name] = a
                
            self._theme_menu_added = True
            # Ensure currently selected theme is checked
            try:
                sel = getattr(self, 'color_theme', None)
                if sel and sel in self._theme_actions:
                    self._theme_actions[sel].setChecked(True)
            except Exception:
                pass
        
        # Add separator after themes
        view_menu.addSeparator()
        
        view_mode_menu = view_menu.addMenu("View Mode")
        self.thumbnail_mode_action = QAction("Thumbnail View", self, checkable=True, checked=True)
        self.icon_mode_action = QAction("Icon View", self, checkable=True)
        self.list_mode_action = QAction("List View", self, checkable=True)
        self.detail_mode_action = QAction("Detail View", self, checkable=True)
        self.thumbnail_mode_action.triggered.connect(lambda: self.set_view_mode(ViewModeManager.THUMBNAIL_VIEW))
        self.icon_mode_action.triggered.connect(lambda: self.set_view_mode(ViewModeManager.ICON_VIEW))
        self.list_mode_action.triggered.connect(lambda: self.set_view_mode(ViewModeManager.LIST_VIEW))
        self.detail_mode_action.triggered.connect(lambda: self.set_view_mode(ViewModeManager.DETAIL_VIEW))
        view_mode_menu.addAction(self.thumbnail_mode_action)
        view_mode_menu.addAction(self.icon_mode_action)
        view_mode_menu.addAction(self.list_mode_action)
        view_mode_menu.addAction(self.detail_mode_action)

    # (Removed menu entry for 'Icon View: Use simple icons')

        # Thumbnail size submenu
        thumbnail_menu = view_menu.addMenu("Thumbnail Size")
        self.thumb_24_action = QAction("24px", self, checkable=True)
        self.thumb_32_action = QAction("32px", self, checkable=True)
        self.small_thumb_action = QAction("Small (48px)", self, checkable=True)
        self.medium_thumb_action = QAction("Medium (64px)", self, checkable=True)
        self.large_thumb_action = QAction("Large (96px)", self, checkable=True)
        self.xlarge_thumb_action = QAction("Extra Large (128px)", self, checkable=True)
        # Additional sizes
        self.thumb_80_action = QAction("80px", self, checkable=True)
        self.thumb_160_action = QAction("160px", self, checkable=True)
        self.thumb_192_action = QAction("192px", self, checkable=True)
        self.thumb_224_action = QAction("224px", self, checkable=True)
        self.thumb_256_action = QAction("256px", self, checkable=True)
        self.thumb_384_action = QAction("384px", self, checkable=True)
        self.thumb_512_action = QAction("512px", self, checkable=True)
        # Large photo-style thumbnails
        self.thumb_640_action = QAction("640px", self, checkable=True)
        self.thumb_768_action = QAction("768px", self, checkable=True)

        # Default selection
        self.medium_thumb_action.setChecked(True)

        # Connect size actions
        self.thumb_24_action.triggered.connect(lambda: self.set_thumbnail_size(24))
        self.thumb_32_action.triggered.connect(lambda: self.set_thumbnail_size(32))
        self.small_thumb_action.triggered.connect(lambda: self.set_thumbnail_size(48))
        self.medium_thumb_action.triggered.connect(lambda: self.set_thumbnail_size(64))
        self.large_thumb_action.triggered.connect(lambda: self.set_thumbnail_size(96))
        self.xlarge_thumb_action.triggered.connect(lambda: self.set_thumbnail_size(128))
        self.thumb_80_action.triggered.connect(lambda: self.set_thumbnail_size(80))
        self.thumb_160_action.triggered.connect(lambda: self.set_thumbnail_size(160))
        self.thumb_192_action.triggered.connect(lambda: self.set_thumbnail_size(192))
        self.thumb_224_action.triggered.connect(lambda: self.set_thumbnail_size(224))
        self.thumb_256_action.triggered.connect(lambda: self.set_thumbnail_size(256))
        self.thumb_384_action.triggered.connect(lambda: self.set_thumbnail_size(384))
        self.thumb_512_action.triggered.connect(lambda: self.set_thumbnail_size(512))
        self.thumb_640_action.triggered.connect(lambda: self.set_thumbnail_size(640))
        self.thumb_768_action.triggered.connect(lambda: self.set_thumbnail_size(768))

        # Add size actions to menu
        thumbnail_menu.addAction(self.thumb_24_action)
        thumbnail_menu.addAction(self.thumb_32_action)
        thumbnail_menu.addAction(self.small_thumb_action)
        thumbnail_menu.addAction(self.medium_thumb_action)
        thumbnail_menu.addAction(self.thumb_80_action)
        thumbnail_menu.addAction(self.large_thumb_action)
        thumbnail_menu.addAction(self.xlarge_thumb_action)
        thumbnail_menu.addAction(self.thumb_160_action)
        thumbnail_menu.addAction(self.thumb_192_action)
        thumbnail_menu.addAction(self.thumb_224_action)
        thumbnail_menu.addAction(self.thumb_256_action)
        thumbnail_menu.addAction(self.thumb_384_action)
        thumbnail_menu.addAction(self.thumb_512_action)
        thumbnail_menu.addAction(self.thumb_640_action)
        thumbnail_menu.addAction(self.thumb_768_action)

        # Icon layout submenu
        layout_menu = view_menu.addMenu("Icon Layout")
        self.auto_width_action = QAction("Auto Width", self, checkable=True, checked=True)
        self.fixed_4_wide_action = QAction("4 Icons Wide", self, checkable=True)
        self.fixed_6_wide_action = QAction("6 Icons Wide", self, checkable=True)
        self.fixed_8_wide_action = QAction("8 Icons Wide", self, checkable=True)
        self.fixed_10_wide_action = QAction("10 Icons Wide", self, checkable=True)
        self.fixed_12_wide_action = QAction("12 Icons Wide", self, checkable=True)
        self.auto_width_action.triggered.connect(lambda: self.set_icons_wide(0))
        self.fixed_4_wide_action.triggered.connect(lambda: self.set_icons_wide(4))
        self.fixed_6_wide_action.triggered.connect(lambda: self.set_icons_wide(6))
        self.fixed_8_wide_action.triggered.connect(lambda: self.set_icons_wide(8))
        self.fixed_10_wide_action.triggered.connect(lambda: self.set_icons_wide(10))
        self.fixed_12_wide_action.triggered.connect(lambda: self.set_icons_wide(12))
        layout_menu.addAction(self.auto_width_action)
        layout_menu.addAction(self.fixed_4_wide_action)
        layout_menu.addAction(self.fixed_6_wide_action)
        layout_menu.addAction(self.fixed_8_wide_action)
        layout_menu.addAction(self.fixed_10_wide_action)
        layout_menu.addAction(self.fixed_12_wide_action)

        view_menu.addSeparator()

        # Sort submenu
        sort_menu = view_menu.addMenu("Sort")
        sort_by_menu = sort_menu.addMenu("Sort By")
        self.sort_by_name_action = QAction("Name", self, checkable=True, checked=True)
        self.sort_by_size_action = QAction("Size", self, checkable=True)
        self.sort_by_date_action = QAction("Date Modified", self, checkable=True)
        self.sort_by_type_action = QAction("Type", self, checkable=True)
        self.sort_by_extension_action = QAction("Extension", self, checkable=True)
        self.sort_by_name_action.triggered.connect(lambda: self.set_sort_by("name"))
        self.sort_by_size_action.triggered.connect(lambda: self.set_sort_by("size"))
        self.sort_by_date_action.triggered.connect(lambda: self.set_sort_by("date"))
        self.sort_by_type_action.triggered.connect(lambda: self.set_sort_by("type"))
        self.sort_by_extension_action.triggered.connect(lambda: self.set_sort_by("extension"))
        sort_by_menu.addAction(self.sort_by_name_action)
        sort_by_menu.addAction(self.sort_by_size_action)
        sort_by_menu.addAction(self.sort_by_date_action)
        sort_by_menu.addAction(self.sort_by_type_action)
        sort_by_menu.addAction(self.sort_by_extension_action)

        # Sort order submenu
        sort_order_menu = sort_menu.addMenu("Sort Order")
        self.sort_ascending_action = QAction("Ascending", self, checkable=True, checked=True)
        self.sort_descending_action = QAction("Descending", self, checkable=True)
        self.sort_ascending_action.triggered.connect(lambda: self.set_sort_order("ascending"))
        self.sort_descending_action.triggered.connect(lambda: self.set_sort_order("descending"))
        sort_order_menu.addAction(self.sort_ascending_action)
        sort_order_menu.addAction(self.sort_descending_action)
        sort_menu.addSeparator()

        # Sort options
        self.directories_first_action = QAction("Directories First", self, checkable=True, checked=True)
        self.case_sensitive_action = QAction("Case Sensitive", self, checkable=True)
        self.group_by_type_action = QAction("Group by Type", self, checkable=True)
        self.natural_sort_action = QAction("Natural Sort (Numbers)", self, checkable=True, checked=True)
        self.directories_first_action.triggered.connect(self.toggle_directories_first)
        self.case_sensitive_action.triggered.connect(self.toggle_case_sensitive)
        self.group_by_type_action.triggered.connect(self.toggle_group_by_type)
        self.natural_sort_action.triggered.connect(self.toggle_natural_sort)
        sort_menu.addAction(self.directories_first_action)
        sort_menu.addAction(self.case_sensitive_action)
        sort_menu.addAction(self.group_by_type_action)
        sort_menu.addAction(self.natural_sort_action)

        # Panel toggles
        self.toggle_tree_action = QAction("Show Tree View", self, checkable=True, checked=True)
        self.toggle_search_action = QAction("Show Search Panel", self, checkable=True)
        self.toggle_right_panel_action = QAction("Show Right Panel", self, checkable=True, checked=True)
        self.toggle_dual_pane_action = QAction("Dual Pane View", self, checkable=True, checked=False)
        self.toggle_transfer_manager_action = QAction("Show Transfer Manager", self, checkable=True, checked=False)
        self.toggle_dual_pane_action.setShortcut("F6")
        self.toggle_dual_pane_action.setToolTip("Toggle dual pane view (F6)")
        self.toggle_right_panel_action.setToolTip("Show/hide right panel (Preview, Cloud Sync, Tags, Collections)")
        self.toggle_transfer_manager_action.setToolTip("Show/hide transfer manager for file operations")
        self.toggle_tree_action.triggered.connect(self.toggle_tree_view)
        self.toggle_search_action.triggered.connect(self.toggle_search_pane)
        self.toggle_right_panel_action.triggered.connect(self.toggle_right_panel)
        self.toggle_dual_pane_action.triggered.connect(self.toggle_dual_pane)
        self.toggle_transfer_manager_action.triggered.connect(self.toggle_transfer_manager)
        view_menu.addAction(self.toggle_tree_action)
        view_menu.addAction(self.toggle_search_action)
        view_menu.addAction(self.toggle_right_panel_action)
        view_menu.addAction(self.toggle_dual_pane_action)
        view_menu.addAction(self.toggle_transfer_manager_action)
        # Verbose event-filter messages toggle (persisted)
        view_menu.addSeparator()
        # Removed theme menu from this location - moved to top of view menu
        # Update menu checkmarks and theme
        self.update_thumbnail_menu_checkmarks()
        self.update_layout_menu_checkmarks()
        self.update_sort_menu_checkmarks()
        self.update_dark_mode_checkmark()
        self.apply_theme()

        # Tools menu
        tools_menu = menu_bar.addMenu("Tools")
        # Windows-only Control Panel action
        try:
            if sys.platform.startswith('win'):
                self.control_panel_action = QAction("Control Panel", self)
                def _open_control_panel():
                    import subprocess
                    try:
                        subprocess.Popen(["control"])
                    except Exception:
                        # fallback to rundll32 if control fails
                        try:
                            subprocess.Popen(["rundll32.exe", "shell32.dll,Control_RunDLL"])
                        except Exception:
                            pass
                self.control_panel_action.triggered.connect(_open_control_panel)
                tools_menu.addSeparator()
                tools_menu.addAction(self.control_panel_action)
        except Exception:
            pass
        self.clipboard_history_menu_action = QAction("Clipboard History...", self)
        self.clipboard_history_menu_action.triggered.connect(self.show_clipboard_history)
        tools_menu.addAction(self.clipboard_history_menu_action)
        tools_menu.addSeparator()
        archive_menu = tools_menu.addMenu("Archive Tools")
        self.create_archive_action = QAction("Create Archive...", self)
        self.create_archive_action.triggered.connect(lambda: self.create_archive_from_selection())
        archive_menu.addAction(self.create_archive_action)
        self.extract_archive_action = QAction("Extract Archive...", self)
        self.extract_archive_action.triggered.connect(lambda: self.extract_archive_from_selection())
        archive_menu.addAction(self.extract_archive_action)
        self.browse_archive_action = QAction("Browse Archive...", self)
        self.browse_archive_action.triggered.connect(lambda: self.browse_archive_from_selection())
        archive_menu.addAction(self.browse_archive_action)
        tools_menu.addSeparator()

        # Enhanced search submenu
        search_menu = tools_menu.addMenu("Search")
        self.search_files_action = QAction("Search Files && Folders...", self)
        self.search_files_action.setShortcut("Ctrl+F")
        self.search_files_action.triggered.connect(self.focus_search)
        search_menu.addAction(self.search_files_action)
        self.search_content_action = QAction("Search File Contents...", self)
        self.search_content_action.setShortcut("Ctrl+Shift+F")
        self.search_content_action.triggered.connect(self.focus_content_search)
        search_menu.addAction(self.search_content_action)
        search_menu.addSeparator()
        self.find_duplicates_action = QAction("Find Duplicate Files...", self)
        self.find_duplicates_action.triggered.connect(self.show_duplicate_finder)
        search_menu.addAction(self.find_duplicates_action)
        self.find_large_files_action = QAction("Find Large Files...", self)
        self.find_large_files_action.triggered.connect(self.show_large_file_finder)
        search_menu.addAction(self.find_large_files_action)
        
        search_menu.addSeparator()
        self.search_toggle_action = QAction("🔍 Toggle Search Panel", self, checkable=True)
        self.search_toggle_action.triggered.connect(self.toggle_search_pane)
        self.search_toggle_action.setShortcut("Ctrl+Alt+F")
        self.search_toggle_action.setToolTip("Toggle Advanced Search Panel (Ctrl+Alt+F)")
        search_menu.addAction(self.search_toggle_action)

        # Info menu
        info_menu = menu_bar.addMenu("Info")
        self.about_action = QAction("About", self)
        self.about_action.triggered.connect(self.show_about_dialog)
        info_menu.addAction(self.about_action)
        
        # Add debug theme paths action
        self.debug_themes_action = QAction("Debug Theme Paths...", self)
        self.debug_themes_action.triggered.connect(self.debug_theme_paths)
        info_menu.addAction(self.debug_themes_action)
        
        info_menu.addSeparator()
        
        self.contact_action = QAction("Contact Me", self)
        self.contact_action.triggered.connect(self.show_contact_dialog)
        info_menu.addAction(self.contact_action)
        self.website_action = QAction("Website", self)
        self.website_action.triggered.connect(self.open_website)
        info_menu.addAction(self.website_action)
        
        # Recursive precache tool: cache all missing thumbnails in a directory tree
        self.recursive_precache_action = QAction("Recursive Precache Thumbnails...", self)
        def _run_recursive_precache():
            try:
                print('[RECURSIVE-PRECACHE] _run_recursive_precache started')
                from PyQt5.QtWidgets import QFileDialog, QInputDialog, QMessageBox
                # Ask user for directory
                dlg = QFileDialog(self, 'Select directory to precache')
                dlg.setFileMode(QFileDialog.Directory)
                dlg.setOption(QFileDialog.ShowDirsOnly, True)
                if dlg.exec_() != QFileDialog.Accepted:
                    print('[RECURSIVE-PRECACHE] Directory selection canceled or dialog closed')
                    return
                selected = dlg.selectedFiles()
                if not selected:
                    print('[RECURSIVE-PRECACHE] No directory selected')
                    return
                directory = selected[0]
                print(f'[RECURSIVE-PRECACHE] Selected directory: {directory}')
                # Ask for sizes: present a checkbox dialog listing all sizes the app supports
                from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QScrollArea, QWidget, QCheckBox, QLabel

                class SizeSelectionDialog(QDialog):
                    def __init__(self, parent, available_sizes, current_size):
                        super().__init__(parent)
                        self.setWindowTitle('Select thumbnail sizes')
                        self.selected = []
                        self.available_sizes = available_sizes
                        layout = QVBoxLayout()
                        label = QLabel('Choose which thumbnail sizes to generate:')
                        layout.addWidget(label)

                        scroll = QScrollArea(self)
                        scroll.setWidgetResizable(True)
                        content = QWidget()
                        content_layout = QVBoxLayout()
                        content.setLayout(content_layout)

                        self.checkboxes = []
                        for s in available_sizes:
                            cb = QCheckBox(f"{s}px")
                            if s == current_size:
                                cb.setChecked(True)
                            content_layout.addWidget(cb)
                            self.checkboxes.append((s, cb))

                        scroll.setWidget(content)
                        layout.addWidget(scroll)

                        btn_layout = QHBoxLayout()
                        select_all = QPushButton('Select All')
                        clear_all = QPushButton('Clear All')
                        btn_layout.addWidget(select_all)
                        btn_layout.addWidget(clear_all)
                        layout.addLayout(btn_layout)

                        ok_cancel = QHBoxLayout()
                        ok_btn = QPushButton('OK')
                        cancel_btn = QPushButton('Cancel')
                        ok_cancel.addWidget(ok_btn)
                        ok_cancel.addWidget(cancel_btn)
                        layout.addLayout(ok_cancel)

                        select_all.clicked.connect(self._select_all)
                        clear_all.clicked.connect(self._clear_all)
                        ok_btn.clicked.connect(self.accept)
                        cancel_btn.clicked.connect(self.reject)

                        self.setLayout(layout)

                    def _select_all(self):
                        for _, cb in self.checkboxes:
                            cb.setChecked(True)

                    def _clear_all(self):
                        for _, cb in self.checkboxes:
                            cb.setChecked(False)

                    def get_selected(self):
                        return [s for s, cb in self.checkboxes if cb.isChecked()]

                # Build list of available sizes from the app (read thumbnail QAction attributes)
                available_sizes = []
                try:
                    # Common attribute name pattern set when the menu was created
                    candidate_attrs = [
                        'thumb_24_action','thumb_32_action','small_thumb_action','medium_thumb_action',
                        'large_thumb_action','xlarge_thumb_action','thumb_80_action','thumb_160_action',
                        'thumb_192_action','thumb_224_action','thumb_256_action','thumb_384_action',
                        'thumb_512_action','thumb_640_action','thumb_768_action'
                    ]
                    seen = set()
                    for attr in candidate_attrs:
                        act = getattr(self, attr, None)
                        if act is None:
                            continue
                        # Try to parse numeric size from the action text
                        text = act.text() if hasattr(act, 'text') else None
                        if text:
                            import re
                            m = re.search(r'(\d{2,4})', text)
                            if m:
                                val = int(m.group(1))
                                if val not in seen:
                                    available_sizes.append(val)
                                    seen.add(val)
                    # Fallback to a sensible default set if nothing found
                    if not available_sizes:
                        available_sizes = [24, 32, 48, 64, 80, 96, 128, 160, 192, 224, 256, 384, 512, 640, 768]
                except Exception:
                    available_sizes = [24, 32, 48, 64, 80, 96, 128, 160, 192, 224, 256, 384, 512, 640, 768]
                # Keep order predictable
                available_sizes = sorted(available_sizes)
                current = getattr(self, 'thumbnail_size', 64)
                dlg = SizeSelectionDialog(self, available_sizes, current)
                print('[RECURSIVE-PRECACHE] Showing size selection dialog')
                if dlg.exec_() != QDialog.Accepted:
                    print('[RECURSIVE-PRECACHE] Size selection canceled')
                    return
                sizes = dlg.get_selected()
                print(f'[RECURSIVE-PRECACHE] Sizes selected: {sizes}')
                if not sizes:
                    QMessageBox.information(self, 'Precache', 'No sizes selected')
                    return
                # Walk tree and collect files to precache
                import os
                import glob
                files = []
                for root, dirs, filenames in os.walk(directory):
                    for fn in filenames:
                        files.append(os.path.join(root, fn))
                # Deduplicate files while preserving order (some file trees can yield duplicates)
                seen_files = set()
                unique_files = []
                for f in files:
                    if f not in seen_files:
                        seen_files.add(f)
                        unique_files.append(f)
                files = unique_files
                if not files:
                    QMessageBox.information(self, 'Precache', 'No files found under selected directory')
                    return

                # Worker: run caching in a background thread and show a progress dialog
                from PyQt5.QtCore import QThread, pyqtSignal, QObject

                class RecursivePrecacheWorker(QObject):
                    finished = pyqtSignal()
                    progress = pyqtSignal(int, int)  # completed, total
                    def __init__(self, files, thumbnail_cache, sizes, parent):
                        super().__init__()
                        self.files = files
                        self.thumbnail_cache = thumbnail_cache
                        self.sizes = list(sizes)
                        self.parent = parent
                        self._stop = False

                    def run(self):
                        total = len(self.files) * max(1, len(self.sizes))
                        completed = 0
                        # Track directories already processed for a given size to avoid duplicate work
                        processed_dirs = set()  # set of (dirpath, size)

                        print(f"[RECURSIVE-PRECACHE-WORKER] starting run: {len(self.files)} files, sizes={self.sizes}, total_steps={total}")

                        for idx, fp in enumerate(self.files):
                            if getattr(self, '_stop', False):
                                print('[RECURSIVE-PRECACHE-WORKER] stop flag set, breaking')
                                break
                            try:
                                ext = os.path.splitext(fp)[1].lower()
                                dirpath = os.path.dirname(fp) or '.'
                                for s in self.sizes:
                                    if getattr(self, '_stop', False):
                                        break
                                    try:
                                        # If this exact file+size is already cached, skip
                                        try:
                                            cached = self.thumbnail_cache.get(fp, s)
                                            if cached is not None:
                                                completed += 1
                                                print(f"[RECURSIVE-PRECACHE-WORKER] cached skip: {fp} size={s} (completed {completed}/{total})")
                                                self.progress.emit(completed, total)
                                                continue
                                        except Exception as e:
                                            print(f"[RECURSIVE-PRECACHE-WORKER] cache lookup error for {fp} size={s}: {e}")

                                        # Only run the expensive per-directory precache once per directory+size
                                        key = (dirpath, s)
                                        if key in processed_dirs:
                                            completed += 1
                                            print(f"[RECURSIVE-PRECACHE-WORKER] dir already processed: {dirpath} size={s} (completed {completed}/{total})")
                                            self.progress.emit(completed, total)
                                            continue

                                        print(f"[RECURSIVE-PRECACHE-WORKER] processing dir={dirpath} size={s} for file {fp}")
                                        # Choose helper based on extension
                                        try:
                                            if ext in ('.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v'):
                                                precache_video_thumbnails_in_directory(dirpath, self.thumbnail_cache, size=s, parent=self.parent, show_progress=False)
                                            else:
                                                precache_text_pdf_thumbnails_in_directory(dirpath, self.thumbnail_cache, size=s, parent=self.parent, show_progress=False)
                                        except Exception as e:
                                            print(f"[RECURSIVE-PRECACHE-WORKER] helper error for dir={dirpath} size={s}: {e}")

                                        # Mark directory+size as processed to avoid repeating work
                                        processed_dirs.add(key)

                                        # After helper runs, increment progress (the helper may have cached multiple files)
                                        completed += 1
                                        print(f"[RECURSIVE-PRECACHE-WORKER] emit progress {completed}/{total}")
                                        self.progress.emit(completed, total)
                                    except Exception as e:
                                        print(f"[RECURSIVE-PRECACHE-WORKER] inner loop exception for {fp} size={s}: {e}")
                                        pass
                            except Exception as e:
                                print(f"[RECURSIVE-PRECACHE-WORKER] outer loop exception for {fp}: {e}")
                                # Continue on errors for directories/files
                                pass
                        print('[RECURSIVE-PRECACHE-WORKER] run finished, emitting finished')
                        self.finished.emit()

                print('[RECURSIVE-PRECACHE] Preparing progress dialog and worker')
                # Set up dialog and thread
                from PyQt5.QtWidgets import QProgressDialog
                from PyQt5.QtCore import Qt
                # Compute a more accurate total: unique directories x sizes
                try:
                    unique_dirs = {os.path.dirname(fp) or '.' for fp in files}
                    total_steps = max(1, len(unique_dirs) * max(1, len(sizes)))
                except Exception:
                    total_steps = max(1, len(files) * max(1, len(sizes)))

                # Create a non-cancelable progress dialog for the recursive precache operation
                progress_dialog = QProgressDialog('Recursively caching thumbnails...', '', 0, total_steps, self)
                try:
                    progress_dialog.setCancelButton(None)
                except Exception:
                    try:
                        progress_dialog.setCancelButtonText('')
                    except Exception:
                        pass
                progress_dialog.setWindowTitle('Recursive precache')
                progress_dialog.setMinimumDuration(200)
                # Make dialog window-modal so it reliably appears above the main window
                try:
                    progress_dialog.setWindowModality(Qt.WindowModal)
                except Exception:
                    try:
                        progress_dialog.setWindowModality(1)
                    except Exception:
                        pass

                worker_thread = QThread()
                worker = RecursivePrecacheWorker(files, getattr(self, 'thumbnail_cache', None), sizes, self)
                worker.moveToThread(worker_thread)
                worker.finished.connect(worker_thread.quit)
                worker.finished.connect(progress_dialog.close)
                # Ensure worker is deleted on the main thread when finished
                worker.finished.connect(worker.deleteLater)
                worker_thread.started.connect(worker.run)

                # Keep the thread/worker alive by parenting them to the dialog and storing strong refs
                try:
                    worker_thread.setParent(progress_dialog)
                except Exception:
                    pass
                progress_dialog._worker_thread = worker_thread
                progress_dialog._worker = worker

                # Define cleanup to clear stored references when thread finishes
                def _cleanup_worker_refs():
                    try:
                        if hasattr(progress_dialog, '_worker_thread'):
                            try:
                                progress_dialog._worker_thread.deleteLater()
                            except Exception:
                                pass
                            try:
                                delattr(progress_dialog, '_worker_thread')
                            except Exception:
                                try:
                                    del progress_dialog._worker_thread
                                except Exception:
                                    pass
                        if hasattr(progress_dialog, '_worker'):
                            try:
                                progress_dialog._worker.deleteLater()
                            except Exception:
                                pass
                            try:
                                delattr(progress_dialog, '_worker')
                            except Exception:
                                try:
                                    del progress_dialog._worker
                                except Exception:
                                    pass
                    except Exception:
                        pass
                try:
                    worker_thread.finished.connect(_cleanup_worker_refs)
                except Exception:
                    pass

                # Make progress dialog cancelable and wire cancellation to the worker's stop flag
                try:
                    progress_dialog.setCancelButtonText('Cancel')
                    # Connect dialog cancel to cooperative stop
                    def _on_cancel():
                        try:
                            print('[RECURSIVE-PRECACHE] User requested cancel')
                            setattr(worker, '_stop', True)
                        except Exception:
                            pass
                    try:
                        progress_dialog.canceled.connect(_on_cancel)
                    except Exception:
                        try:
                            progress_dialog.canceled.connect(lambda: setattr(worker, '_stop', True))
                        except Exception:
                            pass
                except Exception:
                    pass

                # ETA tracking and progress handler (runs on main thread)
                from PyQt5.QtWidgets import QApplication
                import time as _time
                def _format_eta(seconds):
                    if seconds <= 0:
                        return '0s'
                    m, s = divmod(int(seconds), 60)
                    h, m = divmod(m, 60)
                    if h:
                        return f"{h}h {m}m"
                    if m:
                        return f"{m}m {s}s"
                    return f"{s}s"

                def _on_progress(completed, total):
                    try:
                        # Initialize start time on first progress
                        if not hasattr(progress_dialog, '_start_time'):
                            progress_dialog._start_time = _time.time()
                        elapsed = _time.time() - getattr(progress_dialog, '_start_time', _time.time())
                        if completed > 0:
                            rate = elapsed / completed
                            remaining = max(0, total - completed)
                            eta = remaining * rate
                        else:
                            eta = 0
                        eta_str = _format_eta(eta)
                        # Update dialog value and label to include ETA
                        try:
                            progress_dialog.setMaximum(total)
                            progress_dialog.setValue(completed)
                            progress_dialog.setLabelText(f"Recursively caching thumbnails... ({completed}/{total}) ETA: {eta_str}")
                        except Exception:
                            pass
                        try:
                            QApplication.processEvents()
                        except Exception:
                            pass
                    except Exception:
                        pass

                worker.progress.connect(_on_progress)

                # Show the progress dialog and start worker
                try:
                    progress_dialog.setValue(0)
                    print('[RECURSIVE-PRECACHE] Showing progress dialog')
                    progress_dialog.show()
                except Exception as e:
                    print(f'[RECURSIVE-PRECACHE] Failed to show progress dialog: {e}')
                    pass

                # Cancellation via dialog button removed to make this a non-interruptible progress dialog.
                # Worker cooperative stop is still available via code changes if desired.
                worker_thread.finished.connect(worker_thread.deleteLater)
                worker_thread.start()
                print('[RECURSIVE-PRECACHE] Worker thread started')
                # Run modal exec to keep UI responsive until finished
                try:
                    progress_dialog.exec_()
                except Exception:
                    # Fallback: if exec_ fails, just show non-modal dialog
                    try:
                        progress_dialog.show()
                    except Exception:
                        pass
            except Exception as e:
                import traceback
                print(f"[TOOLS-PRECACHE-ERROR] {e}\n{traceback.format_exc()}")

        self.recursive_precache_action.triggered.connect(_run_recursive_precache)
        tools_menu.addAction(self.recursive_precache_action)

        # Remove thumbnails tool: delete cached thumbnails for selected sizes from this app's cache dir
        self.remove_thumbnails_action = QAction("Remove Thumbnails...", self)
        def _run_remove_thumbnails():
            try:
                logging.debug('[REMOVE-THUMBNAILS] _run_remove_thumbnails started')
                from PyQt5.QtWidgets import QMessageBox, QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QScrollArea, QWidget, QCheckBox, QLabel
                from PyQt5.QtCore import Qt
                from PyQt5.QtWidgets import QProgressDialog

                # Use the application's thumbnail cache directory (do not prompt for directory)
                tc = getattr(self, 'thumbnail_cache', None)
                if not tc:
                    QMessageBox.information(self, 'Remove Thumbnails', 'No thumbnail cache is configured for this application.')
                    return
                directory = getattr(tc, 'cache_dir', None)
                if not directory:
                    QMessageBox.information(self, 'Remove Thumbnails', 'Thumbnail cache directory is not set for this application.')
                    return

                # Size selection dialog with dry-run option
                class SizeSelectionDialog(QDialog):
                    def __init__(self, parent, available_sizes, current_size):
                        super().__init__(parent)
                        self.setWindowTitle('Select thumbnail sizes')
                        self.available_sizes = available_sizes
                        layout = QVBoxLayout()
                        label = QLabel('Choose which thumbnail sizes to remove:')
                        layout.addWidget(label)

                        scroll = QScrollArea(self)
                        scroll.setWidgetResizable(True)
                        content = QWidget()
                        content_layout = QVBoxLayout()
                        content.setLayout(content_layout)

                        self.checkboxes = []
                        for s in available_sizes:
                            cb = QCheckBox(f"{s}px")
                            if s == current_size:
                                cb.setChecked(True)
                            content_layout.addWidget(cb)
                            self.checkboxes.append((s, cb))

                        scroll.setWidget(content)
                        layout.addWidget(scroll)

                        btn_layout = QHBoxLayout()
                        select_all = QPushButton('Select All')
                        clear_all = QPushButton('Clear All')
                        btn_layout.addWidget(select_all)
                        btn_layout.addWidget(clear_all)
                        layout.addLayout(btn_layout)

                        # Dry-run option: do not actually delete files
                        self.dry_run_cb = QCheckBox('Dry run (do not delete files)')
                        layout.addWidget(self.dry_run_cb)

                        ok_cancel = QHBoxLayout()
                        ok_btn = QPushButton('OK')
                        cancel_btn = QPushButton('Cancel')
                        ok_cancel.addWidget(ok_btn)
                        ok_cancel.addWidget(cancel_btn)
                        layout.addLayout(ok_cancel)

                        select_all.clicked.connect(self._select_all)
                        clear_all.clicked.connect(self._clear_all)
                        ok_btn.clicked.connect(self.accept)
                        cancel_btn.clicked.connect(self.reject)

                        self.setLayout(layout)

                    def _select_all(self):
                        for _, cb in self.checkboxes:
                            cb.setChecked(True)

                    def _clear_all(self):
                        for _, cb in self.checkboxes:
                            cb.setChecked(False)

                    def get_selected(self):
                        return [s for s, cb in self.checkboxes if cb.isChecked()]

                    def is_dry_run(self):
                        return bool(self.dry_run_cb.isChecked())

                # Build list of available sizes
                try:
                    candidate_attrs = [
                        'thumb_24_action','thumb_32_action','small_thumb_action','medium_thumb_action',
                        'large_thumb_action','xlarge_thumb_action','thumb_80_action','thumb_160_action',
                        'thumb_192_action','thumb_224_action','thumb_256_action','thumb_384_action',
                        'thumb_512_action','thumb_640_action','thumb_768_action'
                    ]
                    available_sizes = []
                    seen = set()
                    for attr in candidate_attrs:
                        act = getattr(self, attr, None)
                        if act is None:
                            continue
                        text = act.text() if hasattr(act, 'text') else None
                        if text:
                            import re
                            m = re.search(r'(\d{2,4})', text)
                            if m:
                                val = int(m.group(1))
                                if val not in seen:
                                    available_sizes.append(val)
                                    seen.add(val)
                    if not available_sizes:
                        available_sizes = [24,32,48,64,80,96,128,160,192,224,256,384,512,640,768]
                except Exception:
                    available_sizes = [24,32,48,64,80,96,128,160,192,224,256,384,512,640,768]

                available_sizes = sorted(available_sizes)
                current = getattr(self, 'thumbnail_size', 64)
                sdlg = SizeSelectionDialog(self, available_sizes, current)
                if sdlg.exec_() != QDialog.Accepted:
                    logging.debug('[REMOVE-THUMBNAILS] Size selection canceled')
                    return
                sizes = sdlg.get_selected()
                dry_run = sdlg.is_dry_run()
                logging.debug('[REMOVE-THUMBNAILS] Sizes selected: %s dry_run=%s', sizes, dry_run)
                if not sizes:
                    QMessageBox.information(self, 'Remove Thumbnails', 'No sizes selected')
                    return

                # Confirm with the user
                if QMessageBox.question(self, 'Confirm Remove Thumbnails', f"Remove thumbnails for sizes {sizes} in cache {directory}? This cannot be undone.", QMessageBox.Yes | QMessageBox.No) != QMessageBox.Yes:
                    logging.debug('[REMOVE-THUMBNAILS] User canceled remove')
                    return

                # Gather target files in cache dir matching selected sizes
                import os
                removed = 0
                errors = 0
                targets = []  # list of (fpath, fn, size)
                try:
                    for fn in os.listdir(directory):
                        fpath = os.path.join(directory, fn)
                        if not os.path.isfile(fpath):
                            continue
                        for s in sizes:
                            suffix_thumb = f"_{s}.thumb"
                            suffix_png = f"_{s}.png"
                            if fn.endswith(suffix_thumb) or fn.endswith(suffix_png):
                                targets.append((fpath, fn, s))
                except Exception:
                    logging.exception('Error listing thumbnail cache directory %s', directory)

                # Progress dialog for deletion
                total = len(targets)
                progress = QProgressDialog('Removing thumbnails...', 'Cancel', 0, max(1, total), self)
                progress.setWindowModality(Qt.WindowModal)
                progress.setMinimumDuration(200)
                progress.setValue(0)

                for idx, (fpath, fn, s) in enumerate(targets, start=1):
                    if progress.wasCanceled():
                        logging.info('Thumbnail removal canceled by user at %d/%d', idx - 1, total)
                        break
                    try:
                        if not dry_run:
                            try:
                                os.remove(fpath)
                                removed += 1
                                # Also remove metadata and memory cache entries if present
                                cache_key = fn.rsplit('.', 1)[0]
                                try:
                                    with tc._lock:
                                        if cache_key in tc.metadata:
                                            del tc.metadata[cache_key]
                                        if cache_key in tc.memory_cache:
                                            del tc.memory_cache[cache_key]
                                except Exception:
                                    pass
                            except Exception:
                                errors += 1
                        else:
                            # Dry run - count but do not delete
                            removed += 1
                    except Exception:
                        errors += 1
                    progress.setValue(idx)
                progress.close()

                logging.info('Removed %d thumbnail files. Errors: %d', removed, errors)
                QMessageBox.information(self, 'Remove Thumbnails', f'Removed {removed} thumbnail files. Errors: {errors}')
            except Exception as e:
                import traceback
                try:
                    QMessageBox.critical(self, 'Error', f'Error removing thumbnails: {e}\n{traceback.format_exc()}')
                except Exception:
                    logging.error('[REMOVE-THUMBNAILS-ERROR] %s\n%s', e, traceback.format_exc())

        self.remove_thumbnails_action.triggered.connect(_run_remove_thumbnails)
        tools_menu.addAction(self.remove_thumbnails_action)
        
        # Add Verbose Event Filter Messages toggle at bottom of tools menu
        tools_menu.addSeparator()
        try:
            self.event_filter_verbose_action = QAction("Verbose Event Filter Messages", self, checkable=True)
            # Initialize checked state from global variable
            try:
                self.event_filter_verbose_action.setChecked(bool(EVENT_FILTER_VERBOSE))
            except Exception:
                pass
            def _toggle_event_filter_verbose(checked):
                try:
                    global EVENT_FILTER_VERBOSE
                    EVENT_FILTER_VERBOSE = bool(checked)
                    settings = QSettings('garysfm', 'garysfm')
                    settings.setValue('event_filter_verbose', bool(checked))
                except Exception:
                    pass
            self.event_filter_verbose_action.toggled.connect(_toggle_event_filter_verbose)
            tools_menu.addAction(self.event_filter_verbose_action)
        except Exception:
            pass

    def setup_enhanced_keyboard_shortcuts(self):
        """Setup enhanced keyboard shortcuts with platform-specific modifiers"""
        main_modifier = PlatformUtils.get_modifier_key()
        alt_modifier = PlatformUtils.get_alt_modifier_key()
        nav_modifier = PlatformUtils.get_navigation_modifier()

        # Platform-specific shortcuts (macOS uses Cmd, others use Ctrl)
        if PlatformUtils.is_macos():
            QShortcut(QKeySequence("Cmd+W"), self, self.close)
            QShortcut(QKeySequence("Cmd+Q"), self, self.close)
            QShortcut(QKeySequence("Cmd+,"), self, self.show_preferences)
            QShortcut(QKeySequence("Cmd+Shift+."), self, self.toggle_show_hidden_files)
            QShortcut(QKeySequence("Cmd+T"), self, self.open_new_tab)
            QShortcut(QKeySequence("Cmd+Delete"), self, self.move_to_trash)
        else:
            QShortcut(QKeySequence("Ctrl+Q"), self, self.close)
            if PlatformUtils.is_windows():
                QShortcut(QKeySequence("Alt+F4"), self, self.close)
            QShortcut(QKeySequence("Ctrl+H"), self, self.toggle_show_hidden_files)
            QShortcut(QKeySequence("Ctrl+T"), self, self.open_new_tab)
            QShortcut(QKeySequence("Shift+Delete"), self, self.move_to_trash)

        # Cross-platform shortcuts
        QShortcut(QKeySequence("F11"), self, self.toggle_fullscreen)
        QShortcut(QKeySequence(f"{main_modifier}+Plus"), self, self.increase_thumbnail_size)
        QShortcut(QKeySequence(f"{main_modifier}+Minus"), self, self.decrease_thumbnail_size)
        QShortcut(QKeySequence(f"{main_modifier}+0"), self, lambda: self.set_thumbnail_size(64))

        # Additional cross-platform shortcuts
        QShortcut(QKeySequence(f"{main_modifier}+L"), self, self.focus_location_bar)
        QShortcut(QKeySequence(f"{main_modifier}+D"), self, self.go_to_desktop)
        QShortcut(QKeySequence(f"{main_modifier}+Shift+D"), self, self.go_to_downloads)
        QShortcut(QKeySequence(f"{main_modifier}+Shift+H"), self, self.go_to_home)

        # Bookmark shortcuts
        QShortcut(QKeySequence(f"{main_modifier}+Shift+B"), self, self.bookmark_current_folder)
        QShortcut(QKeySequence(f"{main_modifier}+B"), self, self.show_bookmark_manager)

    # Enhanced Methods for New Features

    def set_view_mode(self, mode):
        """Switch between different view modes and persist it"""
        self.view_mode_manager.set_mode(mode)
        self.save_view_mode(mode)

        # Update toolbar buttons
        # toolbar/button check for thumbnail view
        try:
            self.thumbnail_view_action.setChecked(mode == ViewModeManager.THUMBNAIL_VIEW)
        except AttributeError:
            pass
        try:
            self.icon_view_action.setChecked(mode == ViewModeManager.ICON_VIEW)
        except AttributeError:
            pass
        try:
            self.list_view_action.setChecked(mode == ViewModeManager.LIST_VIEW)
        except AttributeError:
            pass
        try:
            self.detail_view_action.setChecked(mode == ViewModeManager.DETAIL_VIEW)
        except AttributeError:
            pass

        # Update menu items
        try:
            self.thumbnail_mode_action.setChecked(mode == ViewModeManager.THUMBNAIL_VIEW)
        except AttributeError:
            pass
        try:
            self.icon_mode_action.setChecked(mode == ViewModeManager.ICON_VIEW)
        except AttributeError:
            pass
        try:
            self.list_mode_action.setChecked(mode == ViewModeManager.LIST_VIEW)
        except AttributeError:
            pass
        try:
            self.detail_mode_action.setChecked(mode == ViewModeManager.DETAIL_VIEW)
        except AttributeError:
            pass

        # Switch the actual view for current tab
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            if mode == ViewModeManager.THUMBNAIL_VIEW:
                # Mark main window state
                try:
                    if hasattr(self, 'view_mode_manager'):
                        self.icon_view_active = False
                except Exception:
                    pass
                # Switch every tab's visible widget to the thumbnail view widget
                for tab in getattr(self.tab_manager, 'tabs', []):
                    try:
                        if hasattr(tab, 'view_stack') and hasattr(tab, 'thumbnail_view_widget') and tab.view_stack and tab.thumbnail_view_widget:
                            tab.view_stack.setCurrentWidget(tab.thumbnail_view_widget)
                        # Clear per-tab icon flag where present
                        try:
                            setattr(tab, 'icon_view_active', False)
                        except Exception:
                            pass
                    except Exception:
                        pass
                # Run thumbnail refresh logic for all tabs
                for tab in getattr(self.tab_manager, 'tabs', []):
                    try:
                        tab.refresh_thumbnail_view()
                    except Exception:
                        pass
                # Also ensure current_tab flag
                try:
                    current_tab.icon_view_active = False
                except Exception:
                    pass
                # Auto-refresh removed: do not schedule a delayed refresh 1 second after switching to thumbnail view
            elif mode == ViewModeManager.ICON_VIEW:
                # Mark main window state
                try:
                    if hasattr(self, 'view_mode_manager'):
                        self.icon_view_active = True
                except Exception:
                    pass
                # Icon view uses the same widget as thumbnail view; switch every tab to that widget and mark icon mode per-tab
                for tab in getattr(self.tab_manager, 'tabs', []):
                    try:
                        if hasattr(tab, 'view_stack') and hasattr(tab, 'thumbnail_view_widget') and tab.view_stack and tab.thumbnail_view_widget:
                            tab.view_stack.setCurrentWidget(tab.thumbnail_view_widget)
                        # Mark per-tab icon flag where supported
                        try:
                            setattr(tab, 'icon_view_active', True)
                        except Exception:
                            pass
                    except Exception:
                        pass
                # Refresh all tabs immediately
                for tab in getattr(self.tab_manager, 'tabs', []):
                    try:
                        tab.refresh_current_view()
                    except Exception:
                        pass
                try:
                    current_tab.icon_view_active = True
                except Exception:
                    pass
                # Auto-refresh removed: do not schedule a delayed refresh 1 second after switching to icon view
            elif mode == ViewModeManager.LIST_VIEW:
                try:
                    if hasattr(self, 'view_mode_manager'):
                        self.icon_view_active = False
                except Exception:
                    pass
                # Set list view widget and refresh it for all tabs
                for tab in getattr(self.tab_manager, 'tabs', []):
                    try:
                        if hasattr(tab, 'view_stack') and hasattr(tab, 'list_view') and tab.view_stack and tab.list_view:
                            tab.view_stack.setCurrentWidget(tab.list_view)
                    except Exception:
                        pass
                # Refresh list view for all tabs to keep them in sync
                for tab in getattr(self.tab_manager, 'tabs', []):
                    try:
                        getattr(tab, 'refresh_list_view', lambda: None)()
                    except Exception:
                        pass
            elif mode == ViewModeManager.DETAIL_VIEW:
                try:
                    if hasattr(self, 'view_mode_manager'):
                        self.icon_view_active = False
                except Exception:
                    pass
                # Set detail view widget and refresh it for all tabs
                for tab in getattr(self.tab_manager, 'tabs', []):
                    try:
                        if hasattr(tab, 'view_stack') and hasattr(tab, 'detail_view') and tab.view_stack and tab.detail_view:
                            tab.view_stack.setCurrentWidget(tab.detail_view)
                        # Set detail view header text color to green for this tab
                        try:
                            # Horizontal header (column titles)
                            header = getattr(tab.detail_view, 'horizontalHeader', None)
                            if callable(header):
                                hdr = header()
                                try:
                                    hdr.setStyleSheet('QHeaderView::section { color: green; }')
                                except Exception:
                                    pass
                            else:
                                # detail_view may expose header directly
                                try:
                                    hdr = getattr(tab.detail_view, 'horizontalHeader')
                                    hdr.setStyleSheet('QHeaderView::section { color: green; }')
                                except Exception:
                                    pass

                            # Vertical header (line numbers)
                            vheader = getattr(tab.detail_view, 'verticalHeader', None)
                            if callable(vheader):
                                vh = vheader()
                                try:
                                    vh.setStyleSheet('QHeaderView::section { color: green; }')
                                except Exception:
                                    pass
                            else:
                                try:
                                    vh = getattr(tab.detail_view, 'verticalHeader')
                                    vh.setStyleSheet('QHeaderView::section { color: green; }')
                                except Exception:
                                    pass
                        except Exception:
                            pass
                    except Exception:
                        pass
                # Refresh detail view for all tabs (not just current) to keep them in sync
                for tab in getattr(self.tab_manager, 'tabs', []):
                    try:
                        getattr(tab, 'refresh_detail_view', lambda: None)()
                    except Exception:
                        pass

    # Cross-platform navigation methods
    def focus_location_bar(self):
        """Focus the location/address bar"""
        if hasattr(self, 'location_bar') and self.location_bar:
            self.location_bar.setFocus()
            self.location_bar.selectAll()
    
    def go_to_desktop(self):
        """Navigate to the desktop directory"""
        desktop_path = PlatformUtils.get_desktop_directory()
        if os.path.exists(desktop_path):
            self.navigate_to_folder(desktop_path)
        else:
            self.show_error_message("Error", "Desktop directory not found")
    
    def go_to_downloads(self):
        """Navigate to the downloads directory"""
        downloads_path = PlatformUtils.get_downloads_directory()
        if os.path.exists(downloads_path):
            self.navigate_to_folder(downloads_path)
        else:
            self.show_error_message("Error", "Downloads directory not found")
    
    def go_to_home(self):
        """Navigate to the home directory"""
        home_path = PlatformUtils.get_home_directory()
        if os.path.exists(home_path):
            self.navigate_to_folder(home_path)
        else:
            self.show_error_message("Error", "Home directory not found")
    
    def navigate_to_folder(self, folder_path):
        """Navigate to a specific folder"""
        try:
            if os.path.exists(folder_path) and os.path.isdir(folder_path):
                self.current_folder = folder_path
                self.update_views(folder_path)
                # Update address bar if it exists
                if hasattr(self, 'location_bar') and self.location_bar:
                    self.location_bar.setText(folder_path)
                # Update navigation history
                if hasattr(self, 'add_to_history'):
                    self.add_to_history(folder_path)
            else:
                self.show_error_message("Error", f"Cannot navigate to folder: {folder_path}")
        except Exception as e:
            self.show_error_message("Navigation Error", f"Cannot navigate to folder: {folder_path}", str(e))
    
    def update_views(self, folder_path):
        """Update all views with the new folder"""
        # Update icon view
        if hasattr(self, 'update_thumbnail_view'):
            self.update_thumbnail_view(folder_path)
        # Update list view
        if hasattr(self, 'update_list_view'):
            self.update_list_view(folder_path)
        # Update tree view
        if hasattr(self, 'tree_view') and self.tree_view and hasattr(self, 'model'):
            try:
                index = self.model.index(folder_path)
                if index.isValid():
                    self.tree_view.setCurrentIndex(index)
                    self.tree_view.scrollTo(index)
            except Exception:
                # Ignore tree view update errors to prevent navigation failures
                pass
    
    def show_reveal_in_file_manager_option(self, file_path):
        """Add reveal in file manager option to context menus"""
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            return
            
        try:
            PlatformUtils.reveal_in_file_manager(file_path)
            self.statusBar().showMessage(f"Revealed {os.path.basename(file_path)} in file manager", 2000)
        except Exception as e:
            self.show_error_message("Error", f"Cannot reveal file in file manager: {str(e)}")
            current_tab.navigate_to_path(current_tab.current_folder)
        
        # Save the view mode setting
        self.save_last_dir(current_tab.current_folder)

    def bookmark_current_folder(self):
        """Bookmark the current folder using Ctrl+Shift+B"""
        try:
            # Use the new add_current_bookmark method which handles everything
            self.add_current_bookmark()
        except Exception as e:
            self.show_error_message("Bookmark Error", f"Cannot bookmark current folder: {str(e)}")

    def update_list_view(self, folder_path):
        """Update the list view with current folder contents"""
        if not os.path.exists(folder_path):
            return
        
        # Check if list_model exists (it might be in tabs, not main window)
        if hasattr(self, 'list_model') and self.list_model:
            try:
                self.list_model.setRootPath(folder_path)
                if hasattr(self, 'list_view') and self.list_view:
                    self.list_view.setRootIndex(self.list_model.index(folder_path))
            except Exception:
                # Ignore list view update errors
                pass
        elif hasattr(self, 'tab_manager'):
            # Try to update through current tab
            current_tab = self.tab_manager.get_current_tab()
            if current_tab and hasattr(current_tab, 'update_list_view'):
                try:
                    current_tab.update_list_view(folder_path)
                except Exception:
                    pass
    
    def update_table_view(self, folder_path):
        """Update the table view with current folder contents"""
        if not os.path.exists(folder_path):
            return
            
        # Check if table_model exists
        if hasattr(self, 'table_model') and self.table_model:
            try:
                self.table_model.setRootPath(folder_path)
                if hasattr(self, 'table_view') and self.table_view:
                    self.table_view.setRootIndex(self.table_model.index(folder_path))
            except Exception:
                # Ignore table view update errors
                pass
        elif hasattr(self, 'tab_manager'):
            # Try to update through current tab
            current_tab = self.tab_manager.get_current_tab()
            if current_tab and hasattr(current_tab, 'update_table_view'):
                try:
                    current_tab.update_table_view(folder_path)
                except Exception:
                    pass
    
    def on_list_item_clicked(self, index):
        """Handle list view item clicks"""
        try:
            if hasattr(self, 'list_model') and self.list_model:
                file_path = self.list_model.filePath(index)
                if hasattr(self, 'preview_pane'):
                    self.preview_pane.preview_file(file_path)
                if self.list_model.isDir(index):
                    self.selected_items = [file_path]
                else:
                    self.selected_items = [file_path]
                self.safe_update_status_bar()
        except Exception:
            # Ignore click handling errors
            pass
    
    def on_list_double_click(self, index):
        """Handle list view double clicks"""
        try:
            if hasattr(self, 'list_model') and self.list_model:
                file_path = self.list_model.filePath(index)
                if self.list_model.isDir(index):
                    self.update_thumbnail_view(file_path)
                    self.update_list_view(file_path)
                    self.update_table_view(file_path)
                else:
                    self.open_file(file_path)
        except Exception:
            # Ignore double-click handling errors
            pass
    
    def on_table_item_clicked(self, index):
        """Handle table view item clicks"""
        try:
            if hasattr(self, 'table_model') and self.table_model:
                file_path = self.table_model.filePath(index)
                if hasattr(self, 'preview_pane'):
                    self.preview_pane.preview_file(file_path)
        except Exception:
            # Ignore click handling errors
            pass
        if self.table_model.isDir(index):
            self.selected_items = [file_path]
        else:
            self.selected_items = [file_path]
        self.safe_update_status_bar()
    
    def on_table_double_click(self, index):
        """Handle table view double clicks"""
        try:
            if hasattr(self, 'table_model') and self.table_model:
                file_path = self.table_model.filePath(index)
                if self.table_model.isDir(index):
                    # Navigate to directory in the current tab
                    current_tab = self.tab_manager.get_current_tab()
                    if current_tab:
                        current_tab.navigate_to_path(file_path)
                else:
                    self.open_file(file_path)
        except Exception:
            # Ignore double-click handling errors
            pass
    
    def perform_search(self, search_text, filter_options):
        """Perform search with filters"""
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            return
            
        if not search_text.strip() and filter_options['type'] == 'All':
            # If no search term and no filters, refresh current tab
            current_tab.navigate_to_path(current_tab.current_folder)
            return
        
        self.current_search_results = []
        search_folder = current_tab.current_folder
        
        try:
            for root, dirs, files in os.walk(search_folder):
                # Search in directories
                for dir_name in dirs:
                    if self.matches_search_criteria(dir_name, os.path.join(root, dir_name), 
                                                   search_text, filter_options, is_dir=True):
                        self.current_search_results.append(os.path.join(root, dir_name))
                
                # Search in files
                for file_name in files:
                    file_path = os.path.join(root, file_name)
                    if self.matches_search_criteria(file_name, file_path, 
                                                   search_text, filter_options, is_dir=False):
                        self.current_search_results.append(file_path)
        except Exception as e:
            self.show_error_message("Search Error", f"Error during search: {str(e)}")
            return
        
        # Update view with search results
        self.display_search_results()
    
    def matches_search_criteria(self, name, full_path, search_text, filter_options, is_dir):
        """Check if item matches search criteria"""
        # Text search
        if search_text.strip():
            if search_text.lower() not in name.lower():
                return False
        
        # Type filter
        type_filter = filter_options.get('type', 'All')
        if type_filter == 'Files Only' and is_dir:
            return False
        elif type_filter == 'Folders Only' and not is_dir:
            return False
        elif type_filter in ['Images', 'Documents', 'Videos', 'Audio'] and is_dir:
            return False
        elif type_filter != 'All' and not is_dir:
            # Check file type
            if not self.matches_file_type(full_path, type_filter):
                return False
        
        # Size filter
        if not is_dir:
            size_filter = filter_options.get('size', 'Any Size')
            if not self.matches_size_filter(full_path, size_filter):
                return False
        
        # Date filter
        date_filter = filter_options.get('date', 'Any Time')
        if not self.matches_date_filter(full_path, date_filter):
            return False
        
        return True
    
    def matches_file_type(self, file_path, type_filter):
        """Check if file matches type filter"""
        _, ext = os.path.splitext(file_path.lower())
        
        type_extensions = {
            'Images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.svg', '.webp'],
            'Documents': ['.txt', '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.rtf'],
            'Videos': ['.mp4', '.avi', '.mov', '.wmv', '.flv', '.mkv', '.webm'],
            'Audio': ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma']
        }
        
        return ext in type_extensions.get(type_filter, [])
    
    def matches_size_filter(self, file_path, size_filter):
        """Check if file matches size filter"""
        try:
            size_bytes = os.path.getsize(file_path)
            size_mb = size_bytes / (1024 * 1024)
            
            if size_filter == 'Small (<1MB)':
                return size_mb < 1
            elif size_filter == 'Medium (1-10MB)':
                return 1 <= size_mb <= 10
            elif size_filter == 'Large (10-100MB)':
                return 10 < size_mb <= 100
            elif size_filter == 'Very Large (>100MB)':
                return size_mb > 100
            else:  # Any Size
                return True
        except:
            return True
    
    def matches_date_filter(self, file_path, date_filter):
        """Check if file matches date filter"""
        try:
            mod_time = os.path.getmtime(file_path)
            mod_date = datetime.fromtimestamp(mod_time)
            now = datetime.now()
            
            if date_filter == 'Today':
                return mod_date.date() == now.date()
            elif date_filter == 'This Week':
                week_start = now - timedelta(days=now.weekday())
                return mod_date >= week_start
            elif date_filter == 'This Month':
                return mod_date.year == now.year and mod_date.month == now.month
            elif date_filter == 'This Year':
                return mod_date.year == now.year
            else:  # Any Time
                return True
        except:
            return True
    
    def display_search_results(self):
        """Display search results in current view"""
        # For now, update icon view with search results
        # Clear current icons
        layout = self.icon_grid
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        
        # Add search result icons
        row = 0
        col = 0
        max_cols = 6
        
        for file_path in self.current_search_results:
            if os.path.exists(file_path):
                file_name = os.path.basename(file_path)
                is_dir = os.path.isdir(file_path)
                
                # Determine if main window is in icon-only mode and avoid passing thumbnail cache when in that mode
                use_icon_only = bool(hasattr(self, 'view_mode_manager') and self.view_mode_manager.get_mode() == ViewModeManager.ICON_VIEW)
                in_icon_view = bool(use_icon_only)
                if not in_icon_view and hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                    icon_widget = IconWidget(file_name, file_path, is_dir, self.thumbnail_size, self.thumbnail_cache, use_icon_only)
                else:
                    icon_widget = IconWidget(file_name, file_path, is_dir, self.thumbnail_size, None, use_icon_only)
                icon_widget.clicked.connect(self.icon_clicked)
                icon_widget.doubleClicked.connect(self.icon_double_clicked)
                icon_widget.rightClicked.connect(self.icon_right_clicked)
                icon_widget.update_style_for_theme(self.dark_mode)
                
                layout.addWidget(icon_widget, row, col)
                col += 1
                if col >= max_cols:
                    col = 0
                    row += 1
        
        self.safe_update_status_bar()

    def handle_advanced_search_results(self, query, filters):
        """Handle search results from the advanced search widget"""
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            return
        
        # Get current directory
        current_dir = current_tab.current_folder
        
        # Start async search using the advanced search engine
        def search_callback(callback_type, data):
            if callback_type == 'complete':
                # Update UI with search results
                self.current_search_results = [item['path'] for item in data['results']]
                self.display_search_results()
                self.status_bar.showMessage(f"Found {len(data['results'])} results")
            elif callback_type == 'error':
                self.status_bar.showMessage(f"Search error: {data['message']}")
        
        # Start the search
        future = self.search_engine.search_files_async(current_dir, query, filters, search_callback)
        
    def find_files_with_advanced_criteria(self, directory, criteria):
        """Enhanced file finding with multiple criteria"""
        results = []
        
        try:
            for root, dirs, files in os.walk(directory):
                # Check directories if requested
                if criteria.get('include_directories', False):
                    for dir_name in dirs:
                        dir_path = os.path.join(root, dir_name)
                        if self.matches_advanced_criteria(dir_path, dir_name, criteria, is_dir=True):
                            results.append(dir_path)
                
                # Check files
                for file_name in files:
                    file_path = os.path.join(root, file_name)
                    if self.matches_advanced_criteria(file_path, file_name, criteria, is_dir=False):
                        results.append(file_path)
                        
        except Exception as e:
            print(f"Error in advanced file search: {e}")
            
        return results
    
    def matches_advanced_criteria(self, file_path, file_name, criteria, is_dir=False):
        """Check if file matches advanced search criteria"""
        try:
            # Get file info
            stat_info = os.stat(file_path)
            file_size = stat_info.st_size
            file_mtime = stat_info.st_mtime
            file_ext = os.path.splitext(file_name)[1].lower()
            
            # Name pattern matching
            name_pattern = criteria.get('name_pattern', '')
            if name_pattern:
                import fnmatch
                if not fnmatch.fnmatch(file_name.lower(), name_pattern.lower()):
                    return False
            
            # Size criteria
            size_criteria = criteria.get('size', {})
            if size_criteria:
                if 'min' in size_criteria and file_size < size_criteria['min']:
                    return False
                if 'max' in size_criteria and file_size > size_criteria['max']:
                    return False
            
            # Date criteria
            date_criteria = criteria.get('date', {})
            if date_criteria:
                if 'after' in date_criteria and file_mtime < date_criteria['after']:
                    return False
                if 'before' in date_criteria and file_mtime > date_criteria['before']:
                    return False
            
            # File type criteria
            file_type = criteria.get('file_type')
            if file_type and file_type != 'all':
                type_extensions = {
                    'image': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg'],
                    'video': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v'],
                    'audio': ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma', '.m4a'],
                    'document': ['.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt', '.xls', '.xlsx', '.ppt', '.pptx'],
                    'code': ['.py', '.js', '.html', '.css', '.cpp', '.c', '.java', '.php', '.rb', '.go'],
                    'archive': ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz'],
                    'executable': ['.exe', '.msi', '.app', '.deb', '.rpm', '.dmg']
                }
                
                if file_type in type_extensions and file_ext not in type_extensions[file_type]:
                    return False
            
            # Content search (for text files)
            content_search = criteria.get('content_search', '')
            if content_search and not is_dir:
                text_extensions = {'.txt', '.py', '.js', '.html', '.css', '.json', '.xml', '.yaml', '.yml', 
                                 '.md', '.rst', '.ini', '.cfg', '.conf', '.log', '.sql', '.csv', '.qss', '.gsfmt'}
                filename = os.path.basename(file_path).upper()
                if file_ext in text_extensions or filename in ['LICENSE', 'LICENCE', 'COPYRIGHT', 'COPYING']:
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read(1024 * 1024)  # Read first 1MB
                            if content_search.lower() not in content.lower():
                                return False
                    except:
                        return False
            
            return True
            
        except (OSError, PermissionError):
            return False
    
    def toggle_search_pane(self):
        """Toggle the search pane visibility"""
        if self.search_filter.isVisible():
            self.search_filter.hide()
            self.search_toggle_action.setChecked(False)
            self.toggle_search_action.setChecked(False)
            self.search_visible = False
        else:
            self.search_filter.show()
            self.search_toggle_action.setChecked(True)
            self.toggle_search_action.setChecked(True)
            self.search_visible = True
        
        # Save the setting
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            self.save_last_dir(current_tab.current_folder)
    
    def focus_search(self):
        """Focus the search input"""
        if not self.search_filter.isVisible():
            self.toggle_search_pane()
        self.search_filter.search_input.setFocus()
        self.search_filter.search_input.selectAll()
    
    def focus_content_search(self):
        """Focus the search field and enable content search mode"""
        if not self.search_filter.isVisible():
            self.toggle_search_pane()
        
        # Enable advanced filters and set content search
        if hasattr(self.search_filter, 'filters_group'):
            self.search_filter.filters_group.setChecked(True)
        
        # Focus content search field
        if hasattr(self.search_filter, 'content_search'):
            self.search_filter.content_search.setFocus()
            self.search_filter.content_search.selectAll()
        else:
            # Fallback to main search input
            self.search_filter.search_input.setFocus()
            self.search_filter.search_input.selectAll()
    
    def show_duplicate_finder(self):
        """Show duplicate file finder in a new tab as a table, with progress dialog (thread-safe)"""
        import hashlib
        import threading
        from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QWidget, QVBoxLayout, QProgressDialog
        from PyQt5.QtCore import Qt, QTimer

        class Worker:
            def __init__(self, folder):
                self.folder = folder
                self.progress = 0
                self.duplicates = None
                self.rows = None
                self.headers = None
                self.done = False
                self._progress_callback = None

            def set_progress_callback(self, cb):
                self._progress_callback = cb

            def run(self):
                hashes = {}
                total_files = 0
                for root, _, files in os.walk(self.folder):
                    total_files += len(files)
                scanned = 0
                for root, _, files in os.walk(self.folder):
                    for name in files:
                        path = os.path.join(root, name)
                        try:
                            with open(path, 'rb') as f:
                                h = hashlib.md5()
                                while True:
                                    chunk = f.read(8192)
                                    if not chunk:
                                        break
                                    h.update(chunk)
                                digest = h.hexdigest()
                            hashes.setdefault(digest, []).append(path)
                        except Exception:
                            continue
                        scanned += 1
                        if self._progress_callback and total_files > 0:
                            self._progress_callback(int(scanned * 100 / total_files))
                self.duplicates = {k: v for k, v in hashes.items() if len(v) > 1}
                self.rows = []
                for group_id, files in enumerate(self.duplicates.values(), 1):
                    for f in files:
                        self.rows.append((group_id, f))
                self.headers = ["Group", "File Path"]
                self.done = True

        def start_worker():
            current_tab = self.tab_manager.get_current_tab()
            folder = current_tab.current_folder if current_tab else os.getcwd()
            self.statusBar().showMessage("Scanning for duplicates...")
            worker = Worker(folder)
            def progress_cb(val):
                worker.progress = val
            worker.set_progress_callback(progress_cb)
            t = threading.Thread(target=worker.run, daemon=True)
            t.start()
            return worker, t

        progress_dialog = QProgressDialog("Scanning for duplicate files...", None, 0, 100, self)
        progress_dialog.setWindowModality(Qt.ApplicationModal)
        progress_dialog.setWindowTitle("Please Wait")
        progress_dialog.setMinimumDuration(0)
        progress_dialog.setValue(0)

        worker, thread = start_worker()

        def poll():
            progress_dialog.setValue(worker.progress)
            if worker.done:
                progress_dialog.close()
                self.statusBar().showMessage(f"Found {sum(len(v) for v in (worker.duplicates or {}).values())} duplicate files" if worker.duplicates else "No duplicates found", 5000)
                self.open_results_tab("Duplicate Files", worker.headers, worker.rows)
                return
            QTimer.singleShot(100, poll)

        poll()

    def show_large_file_finder(self):
        """Show large file finder in a new tab as a table, with progress dialog (thread-safe)"""
        import threading
        from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QWidget, QVBoxLayout, QProgressDialog
        from PyQt5.QtCore import Qt, QTimer

        class Worker:
            def __init__(self, folder, limit=20):
                self.folder = folder
                self.limit = limit
                self.progress = 0
                self.files = None
                self.rows = None
                self.headers = None
                self.done = False
                self._progress_callback = None

            def set_progress_callback(self, cb):
                self._progress_callback = cb

            def run(self):
                file_sizes = []
                total_files = 0
                for root, _, files in os.walk(self.folder):
                    total_files += len(files)
                scanned = 0
                for root, _, files in os.walk(self.folder):
                    for name in files:
                        path = os.path.join(root, name)
                        try:
                            size = os.path.getsize(path)
                            file_sizes.append((path, size))
                        except Exception:
                            continue
                        scanned += 1
                        if self._progress_callback and total_files > 0:
                            self._progress_callback(int(scanned * 100 / total_files))
                file_sizes.sort(key=lambda x: x[1], reverse=True)
                self.files = file_sizes[:self.limit]
                self.rows = [(path, f"{size/1024/1024:.2f} MB") for path, size in self.files]
                self.headers = ["File Path", "Size"]
                self.done = True

        def start_worker():
            current_tab = self.tab_manager.get_current_tab()
            folder = current_tab.current_folder if current_tab else os.getcwd()
            self.statusBar().showMessage("Scanning for large files...")
            worker = Worker(folder)
            def progress_cb(val):
                worker.progress = val
            worker.set_progress_callback(progress_cb)
            t = threading.Thread(target=worker.run, daemon=True)
            t.start()
            return worker, t

        progress_dialog = QProgressDialog("Scanning for large files...", None, 0, 100, self)
        progress_dialog.setWindowModality(Qt.ApplicationModal)
        progress_dialog.setWindowTitle("Please Wait")
        progress_dialog.setMinimumDuration(0)
        progress_dialog.setValue(0)

        worker, thread = start_worker()

        def poll():
            progress_dialog.setValue(worker.progress)
            if worker.done:
                progress_dialog.close()
                self.statusBar().showMessage(f"Found {len(worker.files) if worker.files else 0} large files", 5000)
                self.open_results_tab("Large Files", worker.headers, worker.rows)
                return
            QTimer.singleShot(100, poll)

        poll()

    def open_results_tab(self, title, headers, rows):
        """Open a new tab with a table of results (for search, large, duplicate, etc)"""
        from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QWidget, QVBoxLayout
        table = QTableWidget()
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setRowCount(len(rows))
        for i, row in enumerate(rows):
            for j, value in enumerate(row):
                item = QTableWidgetItem(str(value))
                table.setItem(i, j, item)
        table.resizeColumnsToContents()
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.addWidget(table)
        widget.setLayout(layout)
        self.tab_manager.tabs.append(widget)
        tab_index = self.tab_manager.tab_bar.addTab(title)
        self.tab_manager.tab_stack.addWidget(widget)
        self.tab_manager.tab_bar.setCurrentIndex(tab_index)
        self.tab_manager.tab_stack.setCurrentWidget(widget)
    
    def restore_view_states(self):
        """Restore view panel states from settings"""
        # Restore tree view state
        if not self.show_tree_view:
            self.left_pane.hide()
            try:
                self.toggle_tree_action.setChecked(False)
            except AttributeError:
                pass
        else:
            self.left_pane.show()
            try:
                self.toggle_tree_action.setChecked(True)
            except AttributeError:
                pass
        
        # Preview pane will be controlled by right panel toggle
        
        # Restore right panel state
        if not self.show_right_panel:
            self.right_pane_tabs.hide()
            try:
                self.toggle_right_panel_action.setChecked(False)
            except AttributeError:
                pass
        else:
            self.right_pane_tabs.show()
            try:
                self.toggle_right_panel_action.setChecked(True)
            except AttributeError:
                pass
        
        # Restore transfer manager state
        if hasattr(self, 'transfer_manager_widget'):
            if self.show_transfer_manager:
                self.transfer_manager_widget.show()
                try:
                    self.toggle_transfer_manager_action.setChecked(True)
                except AttributeError:
                    pass
            else:
                self.transfer_manager_widget.hide()
                try:
                    self.toggle_transfer_manager_action.setChecked(False)
                except AttributeError:
                    pass
        
        # Restore search panel state
        if self.search_visible:
            self.search_filter.show()
            try:
                self.search_toggle_action.setChecked(True)
            except AttributeError:
                pass
            try:
                self.toggle_search_action.setChecked(True)
            except AttributeError:
                pass
        else:
            self.search_filter.hide()
            try:
                self.search_toggle_action.setChecked(False)
            except AttributeError:
                pass
            try:
                self.toggle_search_action.setChecked(False)
            except AttributeError:
                pass
    
    def toggle_tree_view(self):
        """Toggle tree view visibility"""
        if self.left_pane.isVisible():
            self.left_pane.hide()
            self.toggle_tree_action.setChecked(False)
            self.show_tree_view = False
        else:
            self.left_pane.show()
            self.toggle_tree_action.setChecked(True)
            self.show_tree_view = True
        
        # Save the setting
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            self.save_last_dir(current_tab.current_folder)
    
    def toggle_right_panel(self):
        """Toggle right panel visibility (Preview, Cloud Sync, Tags, Collections)"""
        if self.right_pane_tabs.isVisible():
            self.right_pane_tabs.hide()
            self.toggle_right_panel_action.setChecked(False)
            self.show_right_panel = False
        else:
            self.right_pane_tabs.show()
            self.toggle_right_panel_action.setChecked(True)
            self.show_right_panel = True
        
        # Save the setting
        current_tab = self.get_current_tab_manager().get_current_tab()
        if current_tab:
            self.save_last_dir(current_tab.current_folder)
    
    def toggle_transfer_manager(self):
        """Toggle transfer manager widget visibility"""
        if hasattr(self, 'transfer_manager_widget'):
            if self.transfer_manager_widget.isVisible():
                self.transfer_manager_widget.hide()
                self.toggle_transfer_manager_action.setChecked(False)
                self.show_transfer_manager = False
                self.logger.debug("Transfer manager widget hidden via View menu")
            else:
                self.transfer_manager_widget.show()
                self.transfer_manager_widget.raise_()  # Bring to front
                self.toggle_transfer_manager_action.setChecked(True)
                self.show_transfer_manager = True
                self.logger.debug("Transfer manager widget shown via View menu")
            
            # Save the setting
            current_tab = self.get_current_tab_manager().get_current_tab()
            if current_tab:
                self.save_last_dir(current_tab.current_folder)
        else:
            self.logger.warning("Transfer manager widget not found for toggle")
    
    def toggle_dual_pane(self):
        """Toggle between single and dual pane mode"""
        try:
            if self.is_dual_pane_mode:
                # Switch from dual pane to single pane
                self.switch_to_single_pane()
            else:
                # Switch from single pane to dual pane
                self.switch_to_dual_pane()
        except Exception as e:
            print(f"Error toggling dual pane mode: {e}")
    
    def switch_to_dual_pane(self):
        """Switch from single pane to dual pane mode"""
        if self.is_dual_pane_mode:
            return
        
        # Create dual pane manager
        self.dual_pane_manager = DualPaneManager(parent=self)
        
        # Migrate tabs from single pane to dual pane
        self.dual_pane_manager.migrate_from_single_pane(self.tab_manager)
        
        # Remove single pane from layout
        self.center_layout.removeWidget(self.tab_manager)
        self.tab_manager.setParent(None)
        
        # Add dual pane to layout
        self.center_layout.addWidget(self.dual_pane_manager)
        
        # Update state
        self.is_dual_pane_mode = True
        self.toggle_dual_pane_action.setChecked(True)
        self.save_dual_pane_setting()
        
        # If there were no tabs, create default tabs for both panes
        if not self.dual_pane_manager.get_all_tabs():
            self.dual_pane_manager.left_pane.new_tab()
            self.dual_pane_manager.right_pane.new_tab()
        elif len(self.dual_pane_manager.get_all_tabs()) == 1:
            # If only one tab, create another for the empty pane
            self.dual_pane_manager.right_pane.new_tab()
    
    def switch_to_single_pane(self):
        """Switch from dual pane to single pane mode"""
        if not self.is_dual_pane_mode:
            return
        
        # Migrate all tabs from dual pane to single pane
        self.dual_pane_manager.migrate_to_single_pane(self.tab_manager)
        
        # Remove dual pane from layout
        self.center_layout.removeWidget(self.dual_pane_manager)
        self.dual_pane_manager.setParent(None)
        
        # Add single pane back to layout
        self.center_layout.addWidget(self.tab_manager)
        self.tab_manager.set_tab_changed_callback(self.on_tab_changed)
        
        # Update state
        self.is_dual_pane_mode = False
        self.dual_pane_manager = None
        self.toggle_dual_pane_action.setChecked(False)
        self.save_dual_pane_setting()
        
        # If no tabs exist, create a default one
        if not self.tab_manager.tabs:
            self.tab_manager.new_tab()
    
    def get_current_tab_manager(self):
        """Get the currently active tab manager (single or dual pane)"""
        if self.is_dual_pane_mode and self.dual_pane_manager:
            return self.dual_pane_manager.get_active_pane()
        return self.tab_manager
    
    def switch_pane_focus(self):
        """Switch focus between panes in dual pane mode"""
        if self.is_dual_pane_mode and self.dual_pane_manager:
            self.dual_pane_manager.switch_active_pane()
    
    def keyPressEvent(self, event):
        """Handle key press events for dual pane functionality"""
        if event.key() == Qt.Key_F6 and self.is_dual_pane_mode:
            self.switch_pane_focus()
            event.accept()
        else:
            super().keyPressEvent(event)
    
    def save_dual_pane_setting(self):
        """Save dual pane mode preference to settings"""
        try:
            settings = {}
            if os.path.exists(self.SETTINGS_FILE):
                try:
                    with open(self.SETTINGS_FILE, 'r', encoding='utf-8') as f:
                        settings = json.load(f)
                except Exception:
                    settings = {}
            
            settings['dual_pane_mode'] = self.is_dual_pane_mode
            
            with open(self.SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(settings, f, indent=2)
        except Exception as e:
            print(f"Error saving dual pane setting: {e}")

    def toggle_icon_view_icons_only(self, checked):
        """Toggle whether Icon View uses simple icons (no previews) and persist the choice"""
        try:
            self.icon_view_use_icons_only = bool(checked)
            # Persist to settings file (merge with existing settings)
            settings = {}
            if os.path.exists(self.SETTINGS_FILE):
                try:
                    with open(self.SETTINGS_FILE, 'r', encoding='utf-8') as f:
                        settings = json.load(f)
                except Exception:
                    settings = {}
            settings['icon_view_use_icons_only'] = self.icon_view_use_icons_only
            try:
                with open(self.SETTINGS_FILE, 'w', encoding='utf-8') as f:
                    json.dump(settings, f, indent=2)
            except Exception as e:
                print(f"Error saving settings: {e}")
        except Exception:
            pass
    
    def show_clipboard_history(self):
        """Show clipboard history dialog"""
        dialog = ClipboardHistoryDialog(self.clipboard_manager, self)
        if dialog.exec_() == QDialog.Accepted:
            selected_entry = dialog.get_selected_entry()
            if selected_entry:
                # Restore the selected clipboard entry
                self.clipboard_manager.set_current_operation(
                    selected_entry['operation'], 
                    selected_entry['paths']
                )
    
    def add_current_bookmark(self):
        """Add current directory as a bookmark"""
        from PyQt5.QtWidgets import QInputDialog, QMessageBox
        
        # Get current path from the active tab
        current_path = self.get_current_path()
        
        if not current_path:
            QMessageBox.warning(self, "No Path", "Cannot determine current directory.")
            return
        
        # Check if already bookmarked
        if self.bookmark_manager.is_bookmarked(current_path):
            QMessageBox.information(self, "Already Bookmarked", 
                                  f"This directory is already bookmarked.")
            return
        
        # Get bookmark name from user
        default_name = os.path.basename(current_path) or current_path
        name, ok = QInputDialog.getText(self, "Add Bookmark", 
                                      "Enter bookmark name:", text=default_name)
        if ok and name.strip():
            if self.bookmark_manager.add_bookmark(name.strip(), current_path):
                QMessageBox.information(self, "Bookmark Added", 
                                      f"Added bookmark: {name.strip()}")
                # Update status bar if available
                if hasattr(self, 'statusBar'):
                    self.statusBar().showMessage(f"Bookmarked: {current_path}", 3000)
    
    def show_bookmarks_dropdown(self):
        """Show a dropdown menu with all bookmarks"""
        from PyQt5.QtWidgets import QMenu, QMessageBox
        from PyQt5.QtGui import QCursor
        
        menu = QMenu("Bookmarks", self)
        
        bookmarks = self.bookmark_manager.get_bookmarks()
        if not bookmarks:
            action = menu.addAction("No bookmarks available")
            action.setEnabled(False)
        else:
            for bookmark in bookmarks:
                # Check if path exists and show appropriate icon
                if os.path.exists(bookmark["path"]):
                    action = menu.addAction(f"📁 {bookmark['name']}")
                    action.triggered.connect(lambda checked, path=bookmark["path"]: self.navigate_to_bookmark(path))
                else:
                    # Gray out non-existent bookmarks
                    action = menu.addAction(f"❌ {bookmark['name']} (missing)")
                    action.setEnabled(False)
        
        # Show menu centered under the bookmarks dropdown button
        try:
            # Get the button widget from the action
            button_widget = self.bookmarks_dropdown_action.associatedWidgets()[0]
            button_rect = button_widget.rect()
            
            # Calculate center position of the button
            button_center_x = button_rect.width() // 2
            button_bottom_y = button_rect.bottom()
            
            # Get menu size to center it properly
            menu.adjustSize()  # Ensure menu has correct size
            menu_width = menu.sizeHint().width()
            
            # Calculate centered position
            center_offset_x = menu_width // 2
            center_point = button_widget.mapToGlobal(
                button_widget.rect().center()
            )
            
            # Position menu centered horizontally under the button
            menu_pos = button_widget.mapToGlobal(
                button_widget.rect().bottomLeft()
            )
            menu_pos.setX(center_point.x() - center_offset_x)
            
            menu.exec_(menu_pos)
        except Exception:
            # Fallback to cursor position
            menu.exec_(QCursor.pos())
    
    def show_bookmark_manager(self):
        """Show the bookmark management dialog"""
        from PyQt5.QtWidgets import QDialog
        
        try:
            dialog = BookmarkDialog(self.bookmark_manager, self)
            dialog.bookmark_selected.connect(self.navigate_to_bookmark)
            if hasattr(dialog, 'apply_theme'):
                # Apply current theme to dialog
                dialog.apply_theme()
            if dialog.exec_() == QDialog.Accepted:
                pass  # Bookmark manager handles its own updates
            dialog.deleteLater()
        except Exception as e:
            self.show_error_message("Bookmark Manager Error", f"Cannot open bookmark manager: {str(e)}")
    
    def navigate_to_bookmark(self, path, open_in_current_tab=None):
        """Navigate to the specified bookmark path"""
        from PyQt5.QtWidgets import QMessageBox
        
        try:
            if path and os.path.exists(path) and os.path.isdir(path):
                # Determine navigation behavior
                if open_in_current_tab is None:
                    # Check if Ctrl key is pressed
                    from PyQt5.QtWidgets import QApplication
                    from PyQt5.QtCore import Qt
                    modifiers = QApplication.keyboardModifiers()
                    open_in_current_tab = bool(modifiers & Qt.ControlModifier)
                
                if open_in_current_tab:
                    # Navigate in current tab
                    current_tab = self.tab_manager.get_current_tab()
                    if current_tab:
                        current_tab.navigate_to_path(path)
                        self.statusBar().showMessage(f"Navigated to bookmark: {path}", 2000)
                else:
                    # Create a new tab with the bookmark path
                    current_tab_manager = self.get_current_tab_manager()
                    if current_tab_manager:
                        current_tab_manager.new_tab(path)
                        self.statusBar().showMessage(f"Opened bookmark in new tab: {path}", 2000)
                    else:
                        # Fallback to current tab navigation
                        current_tab = self.tab_manager.get_current_tab()
                        if current_tab:
                            current_tab.navigate_to_path(path)
                            self.statusBar().showMessage(f"Navigated to bookmark: {path}", 2000)
            else:
                QMessageBox.warning(self, "Path Not Found", 
                                  f"The bookmarked path no longer exists:\n{path}")
        except Exception as e:
            self.show_error_message("Navigation Error", f"Cannot navigate to bookmark: {str(e)}")

    def get_current_path(self):
        """Get current path from the active tab"""
        try:
            current_tab = self.tab_manager.get_current_tab()
            if current_tab:
                if hasattr(current_tab, 'current_folder') and current_tab.current_folder:
                    return current_tab.current_folder
                elif hasattr(current_tab, 'get_current_path'):
                    path = current_tab.get_current_path()
                    if path:
                        return path
            
            # Fallback to current_folder attribute if it exists
            if hasattr(self, 'current_folder') and self.current_folder:
                return self.current_folder
            
            # Final fallback to home directory
            import os
            return os.path.expanduser("~")
            
        except Exception:
            import os
            return os.path.expanduser("~")
    
    def create_new_folder(self):
        """Create a new folder in the current directory"""
        current_tab = self.get_current_tab_manager().get_current_tab()
        if not current_tab:
            return
            
        folder_name, ok = QInputDialog.getText(
            self, 'New Folder', 'Enter folder name:', 
            text='New Folder'
        )
        if ok and folder_name.strip():
            new_folder_path = os.path.join(current_tab.current_folder, folder_name.strip())
            try:
                os.makedirs(new_folder_path, exist_ok=False)
                self.refresh_current_view()
                self.show_info_message("Success", f"Folder '{folder_name}' created successfully")
            except FileExistsError:
                self.show_error_message("Error", f"Folder '{folder_name}' already exists")
            except Exception as e:
                self.show_error_message("Error", f"Could not create folder: {str(e)}")
    
    def show_advanced_operations(self):
        """Show advanced operations dialog"""
        try:
            current_tab = self.tab_manager.get_current_tab()
            if not current_tab:
                return
            dialog = AdvancedOperationsDialog(self.selected_items, current_tab.current_folder, self)
            dialog.setAttribute(Qt.WA_DeleteOnClose)  # Ensure proper cleanup
            dialog.exec_()
        except Exception as e:
            print(f"Error showing advanced operations dialog: {e}")
            import traceback
            traceback.print_exc()
    
    def go_back(self):
        """Navigate back in history"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab and current_tab.can_go_back():
            current_tab.go_back()
        # If can't go back, fall back to going up one directory
        elif current_tab:
            self.go_up()
    
    def go_forward(self):
        """Navigate forward in history"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab and current_tab.can_go_forward():
            current_tab.go_forward()
            # Refresh view and address bar after navigation
            if hasattr(current_tab, 'refresh_current_view'):
                current_tab.refresh_current_view()
            if hasattr(self, 'address_bar'):
                self.address_bar.setText(current_tab.current_folder)
    
    def increase_thumbnail_size(self):
        """Increase thumbnail size"""
        # Allow expanding up to 768 to support large photo-style thumbnails
        new_size = min(768, self.thumbnail_size + 16)
        self.set_thumbnail_size(new_size)

    def decrease_thumbnail_size(self):
        """Decrease thumbnail size"""
        new_size = max(32, self.thumbnail_size - 16)
        self.set_thumbnail_size(new_size)
    
    def toggle_fullscreen(self):
        """Toggle fullscreen mode"""
        if self.isFullScreen():
            self.showNormal()
        else:
            self.showFullScreen()
    
    def open_file(self, file_path):
        """Open a file with the default application or built-in archive browser"""
        try:
            # Check if it's an archive file and use built-in browser
            if ArchiveManager.is_archive(file_path):
                self.browse_archive_contents(file_path)
            else:
                if not PlatformUtils.open_file_with_default_app(file_path):
                    self.show_error_message("Error", f"Cannot open file: {file_path}")
        except Exception as e:
            self.show_error_message("Error", f"Cannot open file: {str(e)}")
    
    def show_info_message(self, title, message):
        """Show an information message"""
        QMessageBox.information(self, title, message)
    
    # Enhanced clipboard methods
    # ...existing code...
    
    def paste_action_triggered(self):
        """Enhanced non-blocking paste action with concurrent transfer management"""
        # Reset conflict resolution for new paste operation
        self._paste_conflict_action = None
        self._paste_conflict_apply_all = False
        self._merge_file_action = None
        self._merge_file_apply_all = False
        
        operation, paths = self.clipboard_manager.get_current_operation()
        if not operation or not paths:
            self.logger.warning("No clipboard operation or paths available for paste")
            return

        current_tab = self.get_current_tab_manager().get_current_tab()
        if not current_tab:
            self.logger.warning("No current tab available for paste operation")
            return

        # Determine destination folder
        selection = self.get_current_selected_items()
        selected_folders = [p for p in selection if os.path.isdir(p)]
        if len(selected_folders) == 1:
            destination = Path(selected_folders[0])
        else:
            destination = Path(current_tab.current_folder)

        try:
            # Convert paths to Path objects
            source_paths = [Path(p) for p in paths]
            
            # Normalize operation type
            operation_type = 'move' if operation == 'cut' else 'copy'
            
            self.logger.info(f"About to queue {operation_type} transfer: {len(source_paths)} items to {destination}")
            
            # Create and queue the transfer
            transfer_id = transfer_manager.add_transfer(
                operation_type=operation_type,
                source_paths=source_paths,
                destination_path=destination
            )
            
            self.logger.info(f"Queued {operation_type} transfer {transfer_id}: {len(source_paths)} items to {destination}")
            
            # Clear clipboard if this was a cut operation
            if operation == 'cut':
                self.clipboard_manager.clear_current()
                
            # Show transfer manager if not visible
            # Do not auto-show transfer manager; user must enable via menu
            
            # Refresh view after a short delay to show any completed quick transfers
            QTimer.singleShot(1000, current_tab.refresh_current_view)
            
        except Exception as e:
            self.logger.error(f"Failed to queue paste transfer: {e}")
            import traceback
            self.logger.error(f"Traceback: {traceback.format_exc()}")
            try:
                from PyQt5.QtWidgets import QMessageBox
                QMessageBox.critical(self, "Paste Error", 
                                   f"Failed to start paste operation:\n{str(e)}")
            except Exception:
                print(f"Paste Error: {e}")  # Fallback if QMessageBox fails
    
    def _show_transfer_manager(self):
        """Show the transfer manager widget"""
        if hasattr(self, 'transfer_manager_widget'):
            self.transfer_manager_widget.show()
            self.transfer_manager_widget.raise_()  # Bring to front
            self.show_transfer_manager = True
            self.logger.debug("Transfer manager widget shown")
            # Update the menu toggle state
            if hasattr(self, 'toggle_transfer_manager_action'):
                self.toggle_transfer_manager_action.setChecked(True)
        else:
            self.logger.warning("Transfer manager widget not found")

    def navigate_to_path(self, path):
        """Navigate to a specific path (called from breadcrumb)"""
        try:
            if os.path.exists(path) and os.path.isdir(path):
                # Update current tab
                current_tab = self.tab_manager.get_current_tab()
                if current_tab:
                    current_tab.navigate_to(path)
                
                # Update tree view
                index = self.model.index(path)
                self.tree_view.setCurrentIndex(index)
                self.tree_view.expand(index)
                
                # Update current folder reference
                self.current_folder = path

                # Automatically pre-cache video thumbnails in the background using QThread
                if hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                    try:
                        from PyQt5.QtCore import QThread, pyqtSignal, QObject

                        class ThumbnailPrecacheWorker(QObject):
                            finished = pyqtSignal()
                            def __init__(self, directory, thumbnail_cache, size):
                                super().__init__()
                                self.directory = directory
                                self.thumbnail_cache = thumbnail_cache
                                self.size = size
                            def run(self):
                                try:
                                    precache_video_thumbnails_in_directory(self.directory, self.thumbnail_cache, size=self.size, parent=None, show_progress=True)
                                except Exception as e:
                                    pass
                                self.finished.emit()

                        self._thumb_thread = QThread()
                        self._thumb_worker = ThumbnailPrecacheWorker(path, self.thumbnail_cache, getattr(self, 'thumbnail_size', 128))
                        self._thumb_worker.moveToThread(self._thumb_thread)
                        self._thumb_thread.started.connect(self._thumb_worker.run)
                        self._thumb_worker.finished.connect(self._thumb_thread.quit)
                        self._thumb_worker.finished.connect(self._thumb_worker.deleteLater)
                        self._thumb_thread.finished.connect(self._thumb_thread.deleteLater)
                        self._thumb_thread.start()
                    except Exception as e:
                        pass
            else:
                self.show_error_message("Navigation Error", f"Path no longer exists: {path}")
        except Exception as e:
            self.show_error_message("Navigation Error", f"Cannot navigate to {path}: {str(e)}")
            
    def safe_update_status_bar(self):
        """Safely update status bar with error protection"""
        try:
            if hasattr(self, 'status_bar') and self.status_bar is not None:
                self.update_status_bar()
        except Exception as e:
            print(f"Status bar update failed: {str(e)}")  # Debug output
            
    def update_status_bar(self):
        """Update status bar with current selection and folder info"""
        try:
            if not hasattr(self, 'status_bar') or self.status_bar is None:
                return
                
            selected_count = len(self.selected_items)
            if selected_count == 0:
                # Show folder info
                try:
                    items = os.listdir(self.current_folder)
                    file_count = sum(1 for item in items if os.path.isfile(os.path.join(self.current_folder, item)))
                    folder_count = sum(1 for item in items if os.path.isdir(os.path.join(self.current_folder, item)))
                    self.status_bar.showMessage(f"{folder_count} folders, {file_count} files")
                except Exception:
                    self.status_bar.showMessage("Ready")
            elif selected_count == 1:
                # Show single item info
                item_path = self.selected_items[0]
                try:
                    if os.path.isfile(item_path):
                        size = os.path.getsize(item_path)
                        size_str = self.format_file_size(size)
                        self.status_bar.showMessage(f"1 file selected ({size_str})")
                    else:
                        self.status_bar.showMessage("1 folder selected")
                except Exception:
                    self.status_bar.showMessage("1 item selected")
            else:
                # Show multiple items info
                self.status_bar.showMessage(f"{selected_count} items selected")
        except Exception as e:
            # Fallback status message
            if hasattr(self, 'status_bar') and self.status_bar is not None:
                self.status_bar.showMessage("Ready")

    def format_file_size(self, size):
        """Format file size in human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} PB"

    def show_error_message(self, title, message, details=None):
        """Show an error message dialog with improved error handling"""
        try:
            self.error_count += 1
            if details:
                full_message = f"{message}\n\nDetails: {details}"
            else:
                full_message = message
            QMessageBox.critical(self, title, full_message)
        except Exception as e:
            # Fallback: print to console if GUI fails
            print(f"Error showing message: {title} - {message}")
            if details:
                print(f"Details: {details}")

    def eventFilter(self, obj, event):
        """Handle events on the scroll area viewport to catch clicks in blank areas"""
        # Get current tab
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            return super().eventFilter(obj, event)
        if (hasattr(current_tab, 'scroll_area') and hasattr(current_tab.scroll_area, 'viewport') and
            obj == current_tab.scroll_area.viewport() and 
            hasattr(current_tab, 'get_icon_container_safely') and
            current_tab.get_icon_container_safely() and
            self.view_mode_manager.get_mode() == 'thumbnail'):

            # Handle mouse presses, releases and platform context-menu events so
            # right-click on empty space works reliably on different platforms.
            # Diagnostic: print event info when installed on viewport so we can
            # trace why right-clicks may not be reaching the empty-space handler.
            try:
                evt_name = str(event.type())
            except Exception:
                evt_name = '<unknown>'
            # Quiet by default: use the event_filter_debug toggle so output appears only when enabled
            event_filter_debug('Received event type={} obj={}', event.type(), repr(obj))
            if event.type() == QEvent.MouseButtonPress:
                if event.button() == Qt.LeftButton:
                    # Map viewport coordinates to icon container coordinates
                    icon_container = current_tab.get_icon_container_safely()
                    if not icon_container:
                        return super().eventFilter(obj, event)

                    viewport_pos = event.pos()
                    container_global_pos = current_tab.scroll_area.viewport().mapToGlobal(viewport_pos)
                    container_pos = icon_container.mapFromGlobal(container_global_pos)

                    # Check if there's a widget at this position in the container
                    child_widget = icon_container.childAt(container_pos)

                    # If no child widget, click is outside container bounds, or not an icon widget
                    is_empty_space = (child_widget is None or 
                                      child_widget == icon_container or
                                      isinstance(child_widget, QLayout) or
                                      not hasattr(child_widget, 'full_path') or
                                      not icon_container.rect().contains(container_pos))

                    if is_empty_space:
                        # Deselect visually but allow the event to propagate so
                        # the IconContainer can start a rubber-band (drag) selection.
                        # Consuming the press event here prevents the container from
                        # receiving mousePressEvent and starting the selection rect.
                        self.deselect_icons()
                        # Return False so the event is not treated as handled and
                        # proceeds to the container widget.
                        return False

                # For MouseButtonPress right-button we'll handle here, but some
                # platforms or input methods generate MouseButtonRelease or
                # ContextMenu events instead — those are handled below.
                elif event.button() == Qt.RightButton:
                    icon_container = current_tab.get_icon_container_safely()
                    if not icon_container:
                        return super().eventFilter(obj, event)

                    viewport_pos = event.pos()
                    container_global_pos = current_tab.scroll_area.viewport().mapToGlobal(viewport_pos)
                    container_pos = icon_container.mapFromGlobal(container_global_pos)
                    child_widget = icon_container.childAt(container_pos)

                    is_empty_space = (child_widget is None or 
                                    child_widget == icon_container or
                                    isinstance(child_widget, QLayout) or
                                    not hasattr(child_widget, 'full_path') or
                                    not icon_container.rect().contains(container_pos))

                    if is_empty_space:
                        print(f"[EVENT-FILTER] RightButton Press on empty space at viewport_pos={viewport_pos} global={event.globalPos()}")
                        self.empty_space_right_clicked(event.globalPos())
                        return True  # Event handled

            elif event.type() == QEvent.MouseButtonRelease:
                # Some systems deliver context clicks on release instead of press
                if hasattr(event, 'button') and event.button() == Qt.RightButton:
                    icon_container = current_tab.get_icon_container_safely()
                    if not icon_container:
                        return super().eventFilter(obj, event)

                    viewport_pos = event.pos()
                    container_global_pos = current_tab.scroll_area.viewport().mapToGlobal(viewport_pos)
                    container_pos = icon_container.mapFromGlobal(container_global_pos)
                    child_widget = icon_container.childAt(container_pos)

                    is_empty_space = (child_widget is None or 
                                    child_widget == icon_container or
                                    isinstance(child_widget, QLayout) or
                                    not hasattr(child_widget, 'full_path') or
                                    not icon_container.rect().contains(container_pos))

                    if is_empty_space:
                        print(f"[EVENT-FILTER] RightButton Release on empty space at viewport_pos={viewport_pos} global={event.globalPos()}")
                        self.empty_space_right_clicked(event.globalPos())
                        return True

            elif event.type() == QEvent.ContextMenu:
                # QContextMenuEvent: use its globalPos() to detect empty area
                try:
                    global_pos = event.globalPos()
                except Exception:
                    return super().eventFilter(obj, event)

                icon_container = current_tab.get_icon_container_safely()
                if not icon_container:
                    return super().eventFilter(obj, event)

                # Map the global position into container coordinates
                container_pos = icon_container.mapFromGlobal(global_pos)
                child_widget = icon_container.childAt(container_pos)

                is_empty_space = (child_widget is None or 
                                child_widget == icon_container or
                                isinstance(child_widget, QLayout) or
                                not hasattr(child_widget, 'full_path') or
                                not icon_container.rect().contains(container_pos))

                if is_empty_space:
                    print(f"[EVENT-FILTER] ContextMenu event on empty space global={global_pos}")
                    self.empty_space_right_clicked(global_pos)
                    return True
        
        return super().eventFilter(obj, event)

    def closeEvent(self, event):
        """Handle application close event with proper cleanup to prevent hanging"""
        try:
            print("Starting application shutdown...")
            
            # Step 1: Save application state quickly
            self.save_application_state()
            
            # Step 2: Stop background operations and threads
            self.stop_background_operations()
            
            # Step 3: Clean up resources
            self.cleanup_resources()
            
            # Step 4: Accept the close event
            event.accept()
            
            # Step 5: Force exit for problematic environments
            self.force_exit_if_needed()
            
        except Exception as e:
            print(f"Error during closeEvent: {e}")
            event.accept()  # Always accept to prevent hanging
            
    def save_application_state(self):
        """Save application state and settings"""
        try:
            # Save the last directory from the current active tab first
            current_tab = self.tab_manager.get_current_tab()
            if current_tab:
                self.save_last_dir(current_tab.current_folder)
                
            # Save sort settings for all tabs
            self.save_all_tab_sort_settings()
            
            # Save window geometry and state if settings exists
            if hasattr(self, 'settings') and self.settings:
                self.settings.setValue("geometry", self.saveGeometry())
                self.settings.setValue("windowState", self.saveState())
                
        except Exception as e:
            print(f"Error saving application state: {e}")
            
    def stop_background_operations(self):
        """Stop all background operations and timers with proper cleanup"""
        try:
            print("Stopping background operations...")
            
            # Clean up memory manager
            if hasattr(self, 'memory_manager') and self.memory_manager:
                print("Cleaning up memory manager...")
                try:
                    self.memory_manager.cleanup()
                except Exception as e:
                    print(f"Error cleaning up memory manager: {e}")
            
            # Clean up background monitor
            if hasattr(self, 'background_monitor') and self.background_monitor:
                print("Cleaning up background monitor...")
                try:
                    self.background_monitor.cleanup()
                except Exception as e:
                    print(f"Error cleaning up background monitor: {e}")
            
            # Clean up thumbnail cache
            if hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                print("Cleaning up thumbnail cache...")
                try:
                    self.thumbnail_cache.cleanup()
                except Exception as e:
                    print(f"Error cleaning up thumbnail cache: {e}")
            
            # Clean up virtual file loader
            if hasattr(self, 'virtual_file_loader') and self.virtual_file_loader:
                print("Cleaning up virtual file loader...")
                try:
                    self.virtual_file_loader.cleanup()
                except Exception as e:
                    print(f"Error cleaning up virtual file loader: {e}")
            
            # Clean up search engine
            if hasattr(self, 'search_engine') and self.search_engine:
                print("Cleaning up search engine...")
                try:
                    self.search_engine.cleanup()
                except Exception as e:
                    print(f"Error cleaning up search engine: {e}")
            
            # Clean up search filter widget
            if hasattr(self, 'search_filter') and self.search_filter:
                print("Cleaning up search filter...")
                try:
                    self.search_filter.cleanup()
                except Exception as e:
                    print(f"Error cleaning up search filter: {e}")
            
            # Stop all active operations
            if hasattr(self, 'active_operations'):
                print(f"Stopping {len(self.active_operations)} active operations...")
                for operation in list(self.active_operations):
                    try:
                        if hasattr(operation, 'cancelled'):
                            operation.cancelled = True
                        if hasattr(operation, 'stop'):
                            operation.stop()
                    except Exception as e:
                        print(f"Error stopping operation: {e}")
                self.active_operations.clear()
            
            # Stop any other timers
            timers = self.findChildren(QTimer)
            if timers:
                print(f"Stopping {len(timers)} timers...")
                for timer in timers:
                    if timer.isActive():
                        try:
                            timer.stop()
                        except Exception as e:
                            print(f"Error stopping timer: {e}")
                            
        except Exception as e:
            print(f"Error stopping background operations: {e}")
            
    def cleanup_resources(self):
        """Clean up threads and other resources with memory leak prevention"""
        try:
            print("Cleaning up resources...")
            
            # Clean up memory management components first
            if hasattr(self, 'memory_manager') and self.memory_manager:
                try:
                    # Clear cleanup callbacks to break circular references
                    if hasattr(self.memory_manager, 'cleanup_callbacks'):
                        self.memory_manager.cleanup_callbacks.clear()
                    self.memory_manager = None
                except Exception as e:
                    print(f"Error cleaning memory manager: {e}")
            
            if hasattr(self, 'background_monitor') and self.background_monitor:
                try:
                    # Clear callbacks to break circular references
                    if hasattr(self.background_monitor, 'callbacks'):
                        self.background_monitor.callbacks.clear()
                    if hasattr(self.background_monitor, 'monitored_directories'):
                        self.background_monitor.monitored_directories.clear()
                    self.background_monitor = None
                except Exception as e:
                    print(f"Error cleaning background monitor: {e}")
            
            if hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                try:
                    # Clear all cache data
                    if hasattr(self.thumbnail_cache, 'memory_cache'):
                        self.thumbnail_cache.memory_cache.clear()
                    if hasattr(self.thumbnail_cache, 'metadata'):
                        self.thumbnail_cache.metadata.clear()
                    self.thumbnail_cache = None
                except Exception as e:
                    print(f"Error cleaning thumbnail cache: {e}")
            
            if hasattr(self, 'virtual_file_loader') and self.virtual_file_loader:
                try:
                    # Clear all loaded data
                    if hasattr(self.virtual_file_loader, 'loaded_chunks'):
                        self.virtual_file_loader.loaded_chunks.clear()
                    if hasattr(self.virtual_file_loader, 'directory_cache'):
                        self.virtual_file_loader.directory_cache.clear()
                    self.virtual_file_loader = None
                except Exception as e:
                    print(f"Error cleaning virtual file loader: {e}")
            
            # Find and terminate all QThread children
            threads = self.findChildren(QThread)
            if threads:
                print(f"Cleaning up {len(threads)} threads...")
                for thread in threads:
                    if thread.isRunning():
                        print(f"Stopping thread: {thread.__class__.__name__}")
                        thread.requestInterruption()
                        if not thread.wait(1000):  # Wait 1 second
                            print(f"Force terminating thread: {thread.__class__.__name__}")
                            thread.terminate()
                            thread.wait(500)  # Wait another 0.5 seconds
            
            # Clear operation references to prevent memory leaks
            if hasattr(self, 'active_operations'):
                self.active_operations.clear()
            if hasattr(self, 'operation_progress_dialogs'):
                self.operation_progress_dialogs.clear()
                
            # Process any pending events
            QApplication.processEvents()
            
            # Force garbage collection
            import gc
            collected = gc.collect()
            print(f"Garbage collection freed {collected} objects")
            
            print("Resource cleanup complete")
            
        except Exception as e:
            print(f"Error cleaning up resources: {e}")
            
    def force_exit_if_needed(self):
        """Force exit for problematic environments like Windows"""
        try:
            if sys.platform.startswith('win'):
                print("Windows detected - using aggressive exit strategy")
                # Give Qt a moment to clean up
                QApplication.processEvents()
                
                # Start background force exit as fallback
                import threading
                import time
                
                def delayed_force_exit():
                    time.sleep(2.0)  # Wait 2 seconds
                    print("Force exiting process...")
                    import os
                    os._exit(0)
                    
                force_thread = threading.Thread(target=delayed_force_exit, daemon=True)
                force_thread.start()
                
        except Exception as e:
            print(f"Error in force exit: {e}")

            
    def get_current_tab_session(self):
        """Get current tab session information for saving"""
        try:
            # Check if we're in dual pane mode
            if hasattr(self, 'is_dual_pane_mode') and self.is_dual_pane_mode and hasattr(self, 'dual_pane_manager') and self.dual_pane_manager:
                # Save dual pane session
                tab_session = {
                    "dual_pane_mode": True,
                    "active_pane": self.dual_pane_manager.active_pane,
                    "left_pane": {
                        "tabs": [],
                        "active_tab_index": self.dual_pane_manager.left_pane.tab_bar.currentIndex()
                    },
                    "right_pane": {
                        "tabs": [],
                        "active_tab_index": self.dual_pane_manager.right_pane.tab_bar.currentIndex()
                    }
                }
                
                # Save left pane tabs
                for i, tab in enumerate(self.dual_pane_manager.left_pane.tabs):
                    if hasattr(tab, 'current_folder') and tab.current_folder:
                        tab_info = {
                            "path": tab.current_folder,
                            "title": self.dual_pane_manager.left_pane.tab_bar.tabText(i)
                        }
                        tab_session["left_pane"]["tabs"].append(tab_info)
                
                # Save right pane tabs
                for i, tab in enumerate(self.dual_pane_manager.right_pane.tabs):
                    if hasattr(tab, 'current_folder') and tab.current_folder:
                        tab_info = {
                            "path": tab.current_folder,
                            "title": self.dual_pane_manager.right_pane.tab_bar.tabText(i)
                        }
                        tab_session["right_pane"]["tabs"].append(tab_info)
                
                return tab_session
            
            # Single pane mode
            elif hasattr(self, 'tab_manager') and self.tab_manager:
                tab_session = {
                    "dual_pane_mode": False,
                    "tabs": [],
                    "active_tab_index": self.tab_manager.tab_bar.currentIndex()
                }
                
                for i, tab in enumerate(self.tab_manager.tabs):
                    if hasattr(tab, 'current_folder') and tab.current_folder:
                        tab_info = {
                            "path": tab.current_folder,
                            "title": self.tab_manager.tab_bar.tabText(i)
                        }
                        tab_session["tabs"].append(tab_info)
                
                return tab_session
        except Exception as e:
            print(f"Error getting tab session: {e}")
        
        # Fallback: single tab with current directory
        return {
            "dual_pane_mode": False,
            "tabs": [{"path": os.path.expanduser("~"), "title": "Home"}],
            "active_tab_index": 0
        }

    def save_last_dir(self, path):
        try:
            # Get current tab session info
            tab_session = self.get_current_tab_session()
            
            # Load existing settings to preserve tab_sort_settings
            existing_data = {}
            if os.path.exists(self.SETTINGS_FILE):
                with open(self.SETTINGS_FILE, "r") as f:
                    existing_data = json.load(f)
            
            data = {
                "last_dir": path,
                "thumbnail_size": self.thumbnail_size,
                "dark_mode": self.dark_mode,
                "icons_wide": self.icons_wide,
                "view_mode": self.view_mode_manager.get_mode(),
                "show_tree_view": self.show_tree_view,
                "show_right_panel": self.show_right_panel,
                "search_visible": self.search_visible,
                "show_transfer_manager": getattr(self, 'show_transfer_manager', False),
                "tab_session": tab_session
            }
            
            # Preserve tab_sort_settings if they exist
            if "tab_sort_settings" in existing_data:
                data["tab_sort_settings"] = existing_data["tab_sort_settings"]
            
            # Save current theme settings
            theme_settings = self.get_current_theme_settings()
            if theme_settings:
                data["theme_settings"] = theme_settings
            
            with open(self.SETTINGS_FILE, "w") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            print(f"Error saving settings: {e}")

    def load_last_dir(self):
        try:
            if os.path.exists(self.SETTINGS_FILE):
                with open(self.SETTINGS_FILE, "r") as f:
                    data = json.load(f)
                    # Load thumbnail size if available
                    if "thumbnail_size" in data:
                        self.thumbnail_size = data["thumbnail_size"]
                    # Load dark mode setting if available
                    if "dark_mode" in data:
                        self.dark_mode = data["dark_mode"]
                    # Load icons wide setting if available
                    if "icons_wide" in data:
                        self.icons_wide = data["icons_wide"]
                    elif "max_icons_wide" in data:  # Backward compatibility
                        self.icons_wide = data["max_icons_wide"]
                    # Load view mode if available
                    if "view_mode" in data:
                        self.view_mode_manager.set_mode(data["view_mode"])
                    # Load view panel states if available
                    if "show_tree_view" in data:
                        self.show_tree_view = data["show_tree_view"]
                    if "show_right_panel" in data:
                        self.show_right_panel = data["show_right_panel"]
                    if "search_visible" in data:
                        self.search_visible = data["search_visible"]
                    if "show_transfer_manager" in data:
                        self.show_transfer_manager = data["show_transfer_manager"]
                    else:
                        self.show_transfer_manager = False  # Default to hidden
                    
                    # Load tab session if available
                    if "tab_session" in data:
                        self.saved_tab_session = data["tab_session"]
                    else:
                        self.saved_tab_session = None
                    
                    # Restore theme settings
                    if "theme_settings" in data:
                        self.restore_theme_settings(data["theme_settings"])
                    
                    last_dir = data.get("last_dir", None)
                    
                    # Additional validation for macOS 11.0.5
                    if last_dir and sys.platform == 'darwin':
                        # Verify the directory still exists and is accessible
                        if os.path.exists(last_dir) and os.access(last_dir, os.R_OK):
                            return last_dir
                    elif last_dir and os.path.exists(last_dir):
                        return last_dir
        except Exception as e:
            print(f"Error loading settings: {e}")
        
        # Default fallback for macOS 11.0.5
        if sys.platform == 'darwin':
            return os.path.expanduser('~')
        
        return None

    def on_tab_changed(self):
        """Handle tab changes - save session and update sort menu"""
        try:
            # Update sort menu checkmarks for new tab
            self.update_sort_menu_checkmarks()
            # Save tab session
            self.save_tab_session()
            # Ensure the newly active tab has its signals connected and
            # the viewport event filter installed so selection and
            # right-click handling continue to work after switching tabs.
            try:
                current_tab = None
                if hasattr(self, 'tab_manager') and self.tab_manager:
                    current_tab = self.tab_manager.get_current_tab()

                if current_tab:
                    # Install event filter on the viewport if available
                    try:
                        if hasattr(current_tab, 'scroll_area') and current_tab.scroll_area is not None:
                            viewport = current_tab.scroll_area.viewport()
                            if viewport is not None:
                                # Use self (the main window) as the event filter target
                                viewport.installEventFilter(self)
                    except Exception:
                        pass

                    # Reconnect icon container signals for the active tab
                    try:
                        self.connect_tab_signals(current_tab)
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception as e:
            print(f"Error handling tab change: {e}")

    def save_tab_session(self):
        """Save current tab session automatically"""
        try:
            # Re-save all settings including current tab session
            current_path = getattr(self, 'current_folder', os.path.expanduser("~"))
            self.save_last_dir(current_path)
        except Exception as e:
            print(f"Error saving tab session: {e}")

    def restore_tab_session(self):
        """Restore saved tab session"""
        if hasattr(self, 'saved_tab_session') and self.saved_tab_session:
            try:
                tab_session = self.saved_tab_session
                
                # Check if this is a dual pane session
                if tab_session.get("dual_pane_mode", False):
                    # Restore dual pane mode
                    try:
                        if not self.is_dual_pane_mode:
                            self.switch_to_dual_pane()
                        
                        if hasattr(self, 'dual_pane_manager') and self.dual_pane_manager:
                            # Skip clearing existing tabs to avoid errors, just restore over them
                        
                            # Restore left pane tabs
                            left_pane_data = tab_session.get("left_pane", {})
                            restored_left_tabs = 0
                            if hasattr(self.dual_pane_manager, 'left_pane') and self.dual_pane_manager.left_pane:
                                for tab_info in left_pane_data.get("tabs", []):
                                    path = tab_info.get("path", "")
                                    if path and os.path.exists(path) and os.path.isdir(path):
                                        try:
                                            new_tab = self.dual_pane_manager.left_pane.new_tab(path)
                                            restored_left_tabs += 1
                                        except Exception as e:
                                            print(f"Error restoring left pane tab {path}: {e}")
                            
                            # Restore right pane tabs
                            right_pane_data = tab_session.get("right_pane", {})
                            restored_right_tabs = 0
                            if hasattr(self.dual_pane_manager, 'right_pane') and self.dual_pane_manager.right_pane:
                                for tab_info in right_pane_data.get("tabs", []):
                                    path = tab_info.get("path", "")
                                    if path and os.path.exists(path) and os.path.isdir(path):
                                        try:
                                            new_tab = self.dual_pane_manager.right_pane.new_tab(path)
                                            restored_right_tabs += 1
                                        except Exception as e:
                                            print(f"Error restoring right pane tab {path}: {e}")
                            
                            # If no tabs were restored, create default ones
                            if hasattr(self.dual_pane_manager, 'left_pane') and self.dual_pane_manager.left_pane and restored_left_tabs == 0:
                                self.dual_pane_manager.left_pane.new_tab(os.path.expanduser("~"))
                            if hasattr(self.dual_pane_manager, 'right_pane') and self.dual_pane_manager.right_pane and restored_right_tabs == 0:
                                self.dual_pane_manager.right_pane.new_tab(os.path.expanduser("~"))
                            
                            # Set active tabs for each pane safely
                            if hasattr(self.dual_pane_manager, 'left_pane') and self.dual_pane_manager.left_pane:
                                left_active_index = left_pane_data.get("active_tab_index", 0)
                                if (0 <= left_active_index < len(self.dual_pane_manager.left_pane.tabs) and 
                                    left_active_index < self.dual_pane_manager.left_pane.tab_stack.count()):
                                    self.dual_pane_manager.left_pane.tab_bar.setCurrentIndex(left_active_index)
                                    target_tab = self.dual_pane_manager.left_pane.tabs[left_active_index]
                                    stack_widget_index = self.dual_pane_manager.left_pane.tab_stack.indexOf(target_tab)
                                    if stack_widget_index >= 0:
                                        self.dual_pane_manager.left_pane.tab_stack.setCurrentWidget(target_tab)
                            
                            if hasattr(self.dual_pane_manager, 'right_pane') and self.dual_pane_manager.right_pane:
                                right_active_index = right_pane_data.get("active_tab_index", 0)
                                if (0 <= right_active_index < len(self.dual_pane_manager.right_pane.tabs) and 
                                    right_active_index < self.dual_pane_manager.right_pane.tab_stack.count()):
                                    self.dual_pane_manager.right_pane.tab_bar.setCurrentIndex(right_active_index)
                                    target_tab = self.dual_pane_manager.right_pane.tabs[right_active_index]
                                    stack_widget_index = self.dual_pane_manager.right_pane.tab_stack.indexOf(target_tab)
                                    if stack_widget_index >= 0:
                                        self.dual_pane_manager.right_pane.tab_stack.setCurrentWidget(target_tab)
                            
                            # Set the active pane
                            if hasattr(self.dual_pane_manager, 'set_active_pane'):
                                active_pane = tab_session.get("active_pane", 0)
                                self.dual_pane_manager.set_active_pane(active_pane)
                            
                            print(f"Restored {restored_left_tabs} left pane tabs and {restored_right_tabs} right pane tabs from previous session")
                        
                        else:
                            print("Warning: Could not access dual pane manager during restoration, falling back to single pane")
                            # Fall back to single pane restoration
                            if self.is_dual_pane_mode:
                                self.switch_to_single_pane()
                            # Restore as single pane with first available tab
                            available_tabs = []
                            for pane_data in [tab_session.get("left_pane", {}), tab_session.get("right_pane", {})]:
                                available_tabs.extend(pane_data.get("tabs", []))
                            if available_tabs and hasattr(self, 'tab_manager') and self.tab_manager:
                                if len(self.tab_manager.tabs) > 0:
                                    self.tab_manager.close_tab(0)
                                for tab_info in available_tabs[:3]:  # Limit to first 3 tabs
                                    path = tab_info.get("path", "")
                                    if path and os.path.exists(path) and os.path.isdir(path):
                                        try:
                                            self.tab_manager.new_tab(path)
                                        except Exception as e:
                                            print(f"Error restoring fallback tab {path}: {e}")
                    
                    except Exception as e:
                        print(f"Error during dual pane restoration: {e}")
                        # Fall back to single pane mode
                        try:
                            if hasattr(self, 'is_dual_pane_mode') and self.is_dual_pane_mode:
                                self.switch_to_single_pane()
                            if hasattr(self, 'tab_manager') and self.tab_manager and not self.tab_manager.tabs:
                                self.tab_manager.new_tab(os.path.expanduser("~"))
                        except Exception as fallback_error:
                            print(f"Error during fallback to single pane: {fallback_error}")
                    
                else:
                    # Restore single pane mode
                    if self.is_dual_pane_mode:
                        self.switch_to_single_pane()
                    
                    if hasattr(self, 'tab_manager') and self.tab_manager:
                        # Clear the initial default tab
                        if len(self.tab_manager.tabs) > 0:
                            self.tab_manager.close_tab(0)
                        
                        # Restore saved tabs
                        restored_tabs = 0
                        for tab_info in tab_session.get("tabs", []):
                            path = tab_info.get("path", "")
                            if path and os.path.exists(path) and os.path.isdir(path):
                                try:
                                    new_tab = self.tab_manager.new_tab(path)
                                    restored_tabs += 1
                                except Exception as e:
                                    print(f"Error restoring tab {path}: {e}")
                        
                        # If no tabs were restored, create a default one
                        if restored_tabs == 0:
                            self.tab_manager.new_tab(os.path.expanduser("~"))
                        else:
                            # Set the active tab from saved session
                            active_index = tab_session.get("active_tab_index", 0)
                            if (0 <= active_index < len(self.tab_manager.tabs) and 
                                active_index < self.tab_manager.tab_stack.count()):
                                self.tab_manager.tab_bar.setCurrentIndex(active_index)
                                # Verify the widget is actually in the stack before setting it
                                target_tab = self.tab_manager.tabs[active_index]
                                stack_widget_index = self.tab_manager.tab_stack.indexOf(target_tab)
                                if stack_widget_index >= 0:
                                    self.tab_manager.tab_stack.setCurrentWidget(target_tab)
                                else:
                                    print(f"Warning: Tab widget not found in stack, using index 0")
                                    if len(self.tab_manager.tabs) > 0:
                                        self.tab_manager.tab_bar.setCurrentIndex(0)
                                        self.tab_manager.tab_stack.setCurrentIndex(0)
                        
                        print(f"Restored {restored_tabs} tabs from previous session")
                
                # Apply dual pane mode if it was saved
                if getattr(self, '_dual_pane_requested', False):
                    self.switch_to_dual_pane()
                    self.toggle_dual_pane_action.setChecked(True)
                
            except Exception as e:
                print(f"Error restoring tab session: {e}")
                # Fall back to creating default tabs if restoration fails
                if self.is_dual_pane_mode and hasattr(self, 'dual_pane_manager') and self.dual_pane_manager:
                    if not self.dual_pane_manager.left_pane.tabs:
                        self.dual_pane_manager.left_pane.new_tab(os.path.expanduser("~"))
                    if not self.dual_pane_manager.right_pane.tabs:
                        self.dual_pane_manager.right_pane.new_tab(os.path.expanduser("~"))
                elif hasattr(self, 'tab_manager') and self.tab_manager and not self.tab_manager.tabs:
                    self.tab_manager.new_tab(os.path.expanduser("~"))
        else:
            # No saved session found (first launch or no settings file) - create a default tab
            if hasattr(self, 'tab_manager'):
                if len(self.tab_manager.tabs) == 0:
                    default_path = self.last_dir if hasattr(self, 'last_dir') and self.last_dir else os.path.expanduser("~")
                    self.tab_manager.new_tab(default_path)

    def open_website(self):
        """Open the website in the default browser"""
        webbrowser.open("https://turkokards.com")

    def show_bulk_rename_dialog(self):
        """Show bulk rename dialog for selected files or all files in current directory"""
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            QMessageBox.warning(self, "Error", "No active tab found")
            return
            
        # Determine which files to rename
        if self.selected_items:
            files_to_rename = [path for path in self.selected_items if os.path.isfile(path)]
            dialog_title = "Bulk Rename {} Selected Files".format(len(files_to_rename))
        else:
            # Get all files in current directory (excluding folders)
            try:
                all_items = os.listdir(current_tab.current_folder)
                files_to_rename = [os.path.join(current_tab.current_folder, item) 
                                 for item in all_items 
                                 if os.path.isfile(os.path.join(current_tab.current_folder, item)) 
                                 and not item.startswith('.')]
            except (OSError, PermissionError):
                QMessageBox.warning(self, "Error", "Cannot access files in current directory")
                return
            
            if not files_to_rename:
                QMessageBox.information(self, "No Files", "No files found to rename in current directory")
                return
            
            dialog_title = "Bulk Rename {} Files in Current Directory".format(len(files_to_rename))
        
        if not files_to_rename:
            QMessageBox.information(self, "No Files", "No files selected for renaming")
            return
        
        # Create the bulk rename dialog
        dialog = QDialog(self)
        dialog.setWindowTitle(dialog_title)
        dialog.setModal(True)
        dialog.resize(700, 500)
        
        layout = QVBoxLayout()
        
        # Pattern input section
        pattern_group = QGroupBox("Rename Pattern")
        pattern_layout = QGridLayout()
        
        # Pattern type selection
        pattern_type = QComboBox()
        pattern_type.addItems([
            "Find and Replace",
            "Add Prefix", 
            "Add Suffix",
            "Number Files (1, 2, 3...)",
            "Custom Pattern"
        ])
        pattern_layout.addWidget(QLabel("Rename Type:"), 0, 0)
        pattern_layout.addWidget(pattern_type, 0, 1)
        
        # Find/Replace inputs (shown by default)
        pattern_layout.addWidget(QLabel("Find:"), 1, 0)
        find_text = QLineEdit()
        pattern_layout.addWidget(find_text, 1, 1)
        
        pattern_layout.addWidget(QLabel("Replace with:"), 2, 0)
        replace_text = QLineEdit()
        pattern_layout.addWidget(replace_text, 2, 1)
        
        # Custom pattern input (hidden by default)
        pattern_layout.addWidget(QLabel("Pattern:"), 3, 0)
        pattern_text = QLineEdit()
        pattern_text.setPlaceholderText("Use {name} for filename, {ext} for extension, {n} for number")
        pattern_layout.addWidget(pattern_text, 3, 1)
        
        pattern_group.setLayout(pattern_layout)
        layout.addWidget(pattern_group)
        
        # Preview section
        preview_group = QGroupBox("Preview")
        preview_layout = QVBoxLayout()
        
        preview_table = QTableWidget()
        preview_table.setColumnCount(2)
        preview_table.setHorizontalHeaderLabels(["Original Name", "New Name"])
        preview_table.horizontalHeader().setStretchLastSection(True)
        preview_table.setAlternatingRowColors(False)  # Use solid background color
        
        # Set solid background color based on theme mode
        if self.dark_mode:
            preview_table.setStyleSheet("QTableWidget { background-color: black; color: white; }")
        else:
            preview_table.setStyleSheet("QTableWidget { background-color: white; color: black; }")
            
        preview_layout.addWidget(preview_table)
        
        preview_group.setLayout(preview_layout)
        layout.addWidget(preview_group)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        # Cancel button
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(dialog.reject)
        button_layout.addWidget(cancel_button)
        
        button_layout.addStretch()
        
        
        # Update preview function
        def update_preview():
            """Update the preview table with new file names"""
            pattern_type_text = pattern_type.currentText()
            
            preview_table.setRowCount(len(files_to_rename))
            
            for i, file_path in enumerate(files_to_rename):
                original_name = os.path.basename(file_path)
                
                # Generate new name based on pattern type
                try:
                    if pattern_type_text == "Find and Replace":
                        new_name = original_name.replace(find_text.text(), replace_text.text())
                    elif pattern_type_text == "Add Prefix":
                        new_name = find_text.text() + original_name
                    elif pattern_type_text == "Add Suffix":
                        name, ext = os.path.splitext(original_name)
                        new_name = name + find_text.text() + ext
                    elif pattern_type_text == "Number Files (1, 2, 3...)":
                        name, ext = os.path.splitext(original_name)
                        new_name = f"{i+1:03d}{ext}"
                    elif pattern_type_text == "Custom Pattern":
                        name, ext = os.path.splitext(original_name)
                        new_name = pattern_text.text().replace("{name}", name).replace("{ext}", ext).replace("{n}", str(i+1))
                    else:
                        new_name = original_name
                except Exception:
                    new_name = original_name
                
                # Set table items
                preview_table.setItem(i, 0, QTableWidgetItem(original_name))
                preview_table.setItem(i, 1, QTableWidgetItem(new_name))
                
                # Color invalid names red
                if not new_name or new_name == original_name:
                    preview_table.item(i, 1).setBackground(QColor(255, 200, 200))
        
        # Toggle visibility function
        def toggle_controls():
            """Show/hide controls based on selected pattern type"""
            pattern_type_text = pattern_type.currentText()
            
            # Hide/show find/replace controls
            if pattern_type_text == "Find and Replace":
                find_text.setVisible(True)
                replace_text.setVisible(True)
                pattern_text.setVisible(False)
            else:
                find_text.setVisible(False) 
                replace_text.setVisible(False)
                pattern_text.setVisible(pattern_type_text == "Custom Pattern")
        
        # Connect events
        pattern_type.currentTextChanged.connect(lambda: (toggle_controls(), update_preview()))
        find_text.textChanged.connect(update_preview)
        replace_text.textChanged.connect(update_preview)
        pattern_text.textChanged.connect(update_preview)
        
        # Rename button
        rename_button = QPushButton("Rename Files")
        rename_button.clicked.connect(lambda: self.execute_bulk_rename(files_to_rename, dialog, pattern_type, find_text, replace_text, pattern_text, preview_table))
        button_layout.addWidget(rename_button)
        
        layout.addLayout(button_layout)
        
        dialog.setLayout(layout)
        
        # Initialize controls and preview
        toggle_controls()
        update_preview()
        
        # Show dialog
        dialog.exec_()

    def toggle_replacement_controls(self):
        """Show/hide controls based on selected pattern type"""
        pattern_type = self.pattern_type.currentText()
        
        # Get all the input widgets from dialog layout
        dialog = self.bulk_rename_dialog
        
        # Hide/show find/replace controls
        if pattern_type == "Find and Replace":
            self.find_text.setVisible(True)
            self.replace_text.setVisible(True)
            self.pattern_text.setVisible(False)
        else:
            self.find_text.setVisible(False) 
            self.replace_text.setVisible(False)
            self.pattern_text.setVisible(pattern_type == "Custom Pattern")

    def update_rename_preview(self, files_to_rename):
        """Update the preview table with new file names"""
        pattern_type = self.pattern_type.currentText()
        
        self.preview_table.setRowCount(len(files_to_rename))
        
        for i, file_path in enumerate(files_to_rename):
            original_name = os.path.basename(file_path)
            
            # Generate new name based on pattern type
            try:
                if pattern_type == "Find and Replace":
                    new_name = self.generate_new_filename(original_name, self.find_text.text(), self.replace_text.text())
                elif pattern_type == "Add Prefix":
                    new_name = self.find_text.text() + original_name
                elif pattern_type == "Add Suffix":
                    name, ext = os.path.splitext(original_name)
                    new_name = name + self.find_text.text() + ext
                elif pattern_type == "Number Files (1, 2, 3...)":
                    name, ext = os.path.splitext(original_name)
                    new_name = f"{i+1:03d}{ext}"
                elif pattern_type == "Custom Pattern":
                    name, ext = os.path.splitext(original_name)
                    new_name = self.pattern_text.text().replace("{name}", name).replace("{ext}", ext).replace("{n}", str(i+1))
                else:
                    new_name = original_name
            except Exception:
                new_name = original_name
            
            # Set table items
            self.preview_table.setItem(i, 0, QTableWidgetItem(original_name))
            self.preview_table.setItem(i, 1, QTableWidgetItem(new_name))
            
            # Color invalid names red
            if not new_name or new_name == original_name:
                self.preview_table.item(i, 1).setBackground(QColor(255, 200, 200))

    def generate_new_filename(self, old_name, pattern, replacement=""):
        """Generate new filename based on pattern"""
        try:
            if not pattern:
                return old_name
            
            return old_name.replace(pattern, replacement)
        except Exception:
            return old_name

    def execute_bulk_rename(self, files_to_rename, dialog, pattern_type_widget, find_text_widget, replace_text_widget, pattern_text_widget, preview_table_widget):
        """Execute the bulk rename operation"""
        pattern_type = pattern_type_widget.currentText()
        
        if not files_to_rename:
            QMessageBox.warning(dialog, "Error", "No files to rename")
            return
        
        # Confirm operation
        reply = QMessageBox.question(dialog, "Confirm Bulk Rename",
                                   f"Are you sure you want to rename {len(files_to_rename)} files?",
                                   QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)
        if reply != QMessageBox.Yes:
            return
        
        success_count = 0
        errors = []
        
        for i, file_path in enumerate(files_to_rename):
            try:
                old_name = os.path.basename(file_path)
                directory = os.path.dirname(file_path)
                
                # Generate new name
                if pattern_type == "Find and Replace":
                    new_name = self.generate_new_filename(old_name, find_text_widget.text(), replace_text_widget.text())
                elif pattern_type == "Add Prefix":
                    new_name = find_text_widget.text() + old_name
                elif pattern_type == "Add Suffix":
                    name, ext = os.path.splitext(old_name)
                    new_name = name + find_text_widget.text() + ext
                elif pattern_type == "Number Files (1, 2, 3...)":
                    name, ext = os.path.splitext(old_name)
                    new_name = f"{i+1:03d}{ext}"
                elif pattern_type == "Custom Pattern":
                    name, ext = os.path.splitext(old_name)
                    new_name = pattern_text_widget.text().replace("{name}", name).replace("{ext}", ext).replace("{n}", str(i+1))
                else:
                    continue  # Skip if no valid pattern
                
                if new_name and new_name != old_name:
                    new_path = os.path.join(directory, new_name)
                    if not os.path.exists(new_path):
                        os.rename(file_path, new_path)
                        success_count += 1
                    else:
                        errors.append(f"File already exists: {new_name}")
                        
            except Exception as e:
                errors.append(f"Error renaming {old_name}: {str(e)}")
        
        # Show results
        if errors:
            error_msg = "Renamed {} files successfully.\n\nErrors encountered:\n".format(success_count) + "\n".join(errors[:10])
            if len(errors) > 10:
                error_msg += "\n... and {} more errors".format(len(errors) - 10)
            QMessageBox.warning(dialog, "Bulk Rename Complete with Errors", error_msg)
        else:
            QMessageBox.information(dialog, "Bulk Rename Complete", "Successfully renamed {} files.".format(success_count))
        
        # Refresh the view and close dialog
        self.refresh_current_view()
        dialog.accept()

    def go_up(self):
        """Navigate to parent directory"""
        try:
            # Get current tab
            current_tab = self.tab_manager.get_current_tab()
            if not current_tab:
                return
            try:
                pass
            except Exception:
                pass
                
            current_path = current_tab.current_folder
            parent_path = os.path.dirname(current_path)

            # Use os.path.ismount to detect drive roots reliably
            try:
                is_drive_root = bool(current_path) and os.path.ismount(current_path)
            except Exception:
                is_drive_root = (current_path and os.path.normpath(current_path) == os.path.abspath(os.sep))

            if is_drive_root:
                try:
                    current_tab.navigate_to("__MY_COMPUTER__")
                except Exception:
                    try:
                        self.get_current_tab_manager().new_tab("__MY_COMPUTER__")
                    except Exception:
                        pass
                return

            # Check if we can go up (not at root)
            if parent_path and os.path.exists(parent_path) and parent_path != current_path:
                # Navigate to parent directory
                current_tab.navigate_to(parent_path)
        except Exception as e:
            self.show_error_message("Navigation Error", "Could not navigate to parent directory", str(e))

    def on_tree_item_clicked(self, index):
        try:
            file_path = self.model.filePath(index)

            # Additional validation for macOS 11.0.5
            if sys.platform == 'darwin':
                if not os.path.exists(file_path):
                    self.show_error_message("Path Error", f"Path no longer exists: {file_path}")
                    return
                if not os.access(file_path, os.R_OK):
                    self.show_error_message("Permission Error", f"Cannot access: {file_path}")
                    return

            # If it's a directory, navigate the active tab to it
            if QFileInfo(file_path).isDir():
                try:
                    # Ensure directory is listable
                    os.listdir(file_path)
                except (OSError, PermissionError) as e:
                    self.show_error_message("Access Error", f"Cannot access directory: {file_path}", str(e))
                    return

                current_tab = None
                try:
                    current_tab = self.tab_manager.get_current_tab()
                except Exception:
                    current_tab = None

                if current_tab:
                    # Navigate current tab to the selected folder and refresh
                    current_tab.navigate_to(file_path)
                else:
                    # No active tab: create a new one at this folder
                    self.get_current_tab_manager().new_tab(file_path)
            else:
                # If a file was clicked, optionally navigate to its parent in the active tab
                parent_dir = os.path.dirname(file_path)
                if parent_dir:
                    current_tab = self.get_current_tab_manager().get_current_tab()
                    if current_tab:
                        current_tab.navigate_to(parent_dir)
        except Exception as e:
            self.show_error_message("Tree Navigation Error", "Error accessing selected item", str(e))

    def update_thumbnail_view(self, folder_path):
        """Navigate current tab to folder_path and update thumbnail view"""
        try:
            current_tab = self.tab_manager.get_current_tab()
            if current_tab:
                # Let the tab handle its own navigation and thumbnail update
                current_tab.navigate_to(folder_path)
            else:
                # Fallback: create new tab if no current tab
                self.tab_manager.new_tab(folder_path)
        except Exception as e:
            print(f"Error in update_thumbnail_view navigation: {e}")
            # If tab navigation fails, try to create a new tab
            try:
                self.tab_manager.new_tab(folder_path)
            except Exception as e2:
                print(f"Error creating new tab: {e2}")
                # Final fallback: manually update thumbnail view
                self.manual_update_thumbnail_view(folder_path)

    def manual_update_thumbnail_view(self, folder_path):
        """Manual thumbnail view update when tab navigation fails"""
        self.clear_thumbnail_view()
        
        # Filter files/folders based on search criteria
        search_text = self.search_filter.search_input.text().lower()
        selected_filters = []
        filter_type = self.search_filter.type_combo.currentText()
        
        if filter_type == "Images":
            selected_filters.extend(['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp'])
        elif filter_type == "Documents":
            selected_filters.extend(['.txt', '.pdf', '.doc', '.docx', '.rtf', '.odt'])
        elif filter_type == "Videos":
            selected_filters.extend(['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm'])
        elif filter_type == "Audio":
            selected_filters.extend(['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma'])
        
        try:
            items = os.listdir(folder_path)
        except (OSError, PermissionError) as e:
            self.show_error_message("Access Error", f"Cannot read directory: {folder_path}", str(e))
            return
        
        # Clear selection when changing folders
        self.selected_items = []
        self.on_selection_changed([])  # Notify of empty selection
        
        # Sort items: directories first, then files
        items = sorted(items, key=lambda x: (not os.path.isdir(os.path.join(folder_path, x)), x.lower()))
        
        # Create icon widgets for each item
        for item_name in items:
            full_path = os.path.join(folder_path, item_name)
            
            # Skip hidden files on macOS and Linux unless show hidden is enabled
            if item_name.startswith('.') and not getattr(self, 'show_hidden', False):
                continue
            
            # Apply search filter
            if search_text and search_text not in item_name.lower():
                continue
            
            # Apply type filters (only if at least one filter is selected)
            if selected_filters:
                is_file = os.path.isfile(full_path)
                if is_file:
                    file_ext = os.path.splitext(item_name)[1].lower()
                    if file_ext not in selected_filters:
                        continue
                else:
                    # For directories, show them if any filter is selected
                    # (user might want to navigate into directories)
                    pass
            
            try:
                is_dir = os.path.isdir(full_path)
                
                # Create icon widget (respect icon-only view and thumbnail cache)
                use_icon_only = bool(self.view_mode_manager.get_mode() == ViewModeManager.ICON_VIEW)
                if hasattr(self, 'thumbnail_cache') and self.thumbnail_cache:
                    icon_widget = IconWidget(item_name, full_path, is_dir, self.thumbnail_size, self.thumbnail_cache, use_icon_only)
                else:
                    icon_widget = IconWidget(item_name, full_path, is_dir, self.thumbnail_size, None, use_icon_only)
                
                # Connect click signals
                icon_widget.clicked.connect(self.icon_clicked)
                icon_widget.doubleClicked.connect(self.icon_double_clicked)
                icon_widget.rightClicked.connect(self.icon_right_clicked)
                
                # Add to container based on current view mode
                if self.view_mode_manager.get_mode() == "icon":
                    # Icon view - use optimized grid layout
                    current_tab = self.tab_manager.get_current_tab()
                    icon_container = None
                    if current_tab and hasattr(current_tab, 'get_icon_container_safely'):
                        icon_container = current_tab.get_icon_container_safely()
                    elif current_tab and hasattr(current_tab, 'icon_container'):
                        icon_container = current_tab.icon_container
                    
                    if icon_container:
                        icon_container.add_widget_optimized(icon_widget, self.thumbnail_size, self.icons_wide)
                elif self.view_mode_manager.get_mode() == "list":
                    # List view - add to list view
                    formatted_name = format_filename_with_underscore_wrap(item_name)
                    item = QListWidgetItem(formatted_name)
                    item.setData(Qt.UserRole, full_path)  # Store full path
                    if is_dir:
                        item.setIcon(self.style().standardIcon(QStyle.SP_DirIcon))
                    else:
                        item.setIcon(self.style().standardIcon(QStyle.SP_FileIcon))
                    self.list_view.addItem(item)
                elif self.view_mode_manager.get_mode() == "detail":
                    # Detail view uses a model-view architecture, data comes from the file system model
                    # The FormattedFileSystemModel will automatically populate when we set the root path
                    # Individual files don't need to be added manually here
                    pass
                
            except Exception as e:
                print(f"Error creating icon widget for {item_name}: {e}")
                continue
                
        # After processing all items, ensure detail view is properly refreshed if we're in detail mode
        if self.view_mode_manager.get_mode() == "detail":
            current_tab = self.tab_manager.get_current_tab()
            if current_tab and hasattr(current_tab, 'refresh_detail_view'):
                current_tab.refresh_detail_view()

    def clear_thumbnail_view(self):
        """Clear all items from the current view"""
        # Get current tab and clear its thumbnail/icon view
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            icon_container = None
            if hasattr(current_tab, 'get_icon_container_safely'):
                icon_container = current_tab.get_icon_container_safely()
            elif hasattr(current_tab, 'icon_container'):
                icon_container = current_tab.icon_container
            
            if icon_container:
                # Clear grid layout by removing all widgets
                layout = icon_container.layout()
                if layout:
                    while layout.count():
                        child = layout.takeAt(0)
                        if child.widget():
                            child.widget().deleteLater()
        
        # Clear detail view rows (QTableView) - this would be in current tab if it exists
        if current_tab and hasattr(current_tab, 'detail_view') and hasattr(current_tab, 'detail_model'):
            # For QTableView with QFileSystemModel, we need to reset the model or set an empty root
            # Setting root to an empty/non-existent path effectively clears the view
            current_tab.detail_model.setRootPath("")

    def deselect_icons(self):
        """Deselect all icons in the current view"""
        self.selected_items = []
        
        # Get the current tab and clear its selection
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            icon_container = getattr(current_tab, 'icon_container', None) if hasattr(current_tab, 'get_icon_container_safely') else None
            if not icon_container and hasattr(current_tab, 'get_icon_container_safely'):
                icon_container = current_tab.get_icon_container_safely()
            
            if icon_container and hasattr(icon_container, 'clear_selection'):
                icon_container.clear_selection()
        
        self.on_selection_changed([])

    def on_selection_changed(self, selected_paths):
        """Handle selection change in icon view"""
        self.selected_items = selected_paths
        
        # Update clipboard actions
        has_selection = len(selected_paths) > 0
        self.cut_action.setEnabled(has_selection)
        self.copy_action.setEnabled(has_selection) 
        self.delete_action.setEnabled(has_selection)
        
        # Update preview pane
        if len(selected_paths) == 1:
            self.preview_pane.preview_file(selected_paths[0])
        elif len(selected_paths) > 1:
            self.preview_pane.clear_preview()
            # Could show multi-selection info here
        else:
            self.preview_pane.clear_preview()

    def icon_clicked(self, full_path, modifiers):
        """Handle single click on an icon"""
        # Get the current tab and its icon container
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            return
            
        if modifiers & Qt.ControlModifier:
            # Ctrl+click: toggle selection
            if full_path in self.selected_items:
                self.selected_items.remove(full_path)
                current_tab.icon_container.remove_from_selection_by_path(full_path)
            else:
                self.selected_items.append(full_path)
                current_tab.icon_container.add_to_selection_by_path(full_path)
        elif modifiers & Qt.ShiftModifier:
            # Shift+click: range selection (simplified)
            if full_path not in self.selected_items:
                self.selected_items.append(full_path)
                current_tab.icon_container.add_to_selection_by_path(full_path)
        else:
            # Regular click: select only this item — but if the user clicked
            # an item that is already part of a multi-selection, keep the
            # existing selection so a drag of the whole selection can start.
            if full_path in self.selected_items and len(self.selected_items) > 1:
                # Preserve existing multi-selection (likely a drag start)
                pass
            else:
                self.selected_items = [full_path]
                current_tab.icon_container.clear_selection()
                current_tab.icon_container.add_to_selection_by_path(full_path)
        
        # Notify main window of selection change
        self.on_selection_changed(self.selected_items)

    def icon_double_clicked(self, full_path):
        """Handle double-click on an icon"""
        if os.path.isdir(full_path):
            # Navigate to the folder in the current tab
            current_tab = self.tab_manager.get_current_tab()
            if current_tab:
                current_tab.navigate_to_path(full_path)
        elif full_path.lower().endswith('.gsfmt'):
            # Handle .gsfmt files specially - load them as custom themes
            self.load_theme_file(full_path)
        elif ArchiveManager.is_archive(full_path):
            # For archive files, show browse dialog instead of opening externally
            self.browse_archive_contents(full_path)
        else:
            # Open file with default application using platform utilities
            try:
                if not PlatformUtils.open_file_with_default_app(full_path):
                    self.show_error_message("Open Error", f"Cannot open file: {full_path}", "No suitable application found")
            except Exception as e:
                self.show_error_message("Open Error", f"Cannot open file: {full_path}", str(e))

    def icon_right_clicked(self, full_path, global_pos):
        """Handle right-click on an icon"""
        # Get the current tab and its icon container
        current_tab = self.get_current_tab_manager().get_current_tab()
        if not current_tab:
            return
            
        # Ensure the clicked item is selected (use main window's selected_items)
        if full_path not in self.selected_items:
            self.selected_items = [full_path]
            current_tab.icon_container.clear_selection()
            current_tab.icon_container.add_to_selection_by_path(full_path)
            # Notify main window of selection change
            self.on_selection_changed(self.selected_items)
        
        context_menu = QMenu(self)
        
        # Single item actions
        if len(self.selected_items) == 1:
            item_path = self.selected_items[0]
            is_dir = os.path.isdir(item_path)
            if is_dir:
                open_action = context_menu.addAction("Open")
                open_action.triggered.connect(lambda: current_tab.navigate_to(item_path))
                # Add 'Open in New Tab' for folders
                open_new_tab_action = context_menu.addAction("Open in New Tab")
                open_new_tab_action.triggered.connect(lambda: self.get_current_tab_manager().new_tab(item_path))
            else:
                open_action = context_menu.addAction("Open")
                open_action.triggered.connect(lambda: current_tab.handle_double_click(item_path))
                # Add 'Open with...' option for files
                open_with_action = context_menu.addAction("Open with...")
                open_with_action.triggered.connect(lambda: self.open_with_dialog(item_path))
            context_menu.addSeparator()
        
        # Multi-selection or single item actions
        cut_action = context_menu.addAction("Cut")
        cut_action.triggered.connect(self.cut_action_triggered)
        cut_action.setEnabled(len(self.selected_items) > 0)
        
        copy_action = context_menu.addAction("Copy")
        copy_action.triggered.connect(self.copy_action_triggered)
        copy_action.setEnabled(len(self.selected_items) > 0)
        
        # Paste (always available in folder context)
        if self.clipboard_manager.get_current_operation()[0]:  # Has something to paste
            paste_action = context_menu.addAction("Paste")
            paste_action.triggered.connect(self.paste_action_triggered)
        
        context_menu.addSeparator()
        
        # Single item actions
        if len(self.selected_items) == 1:
            rename_action = context_menu.addAction("Rename")
            rename_action.triggered.connect(lambda: self.rename_file(self.selected_items[0]))
            
            copy_path_action = context_menu.addAction("Copy Path")
            copy_path_action.triggered.connect(lambda: self.copy_path_to_clipboard(self.selected_items))
            
            # Add MD5 checksum for files only
            if not os.path.isdir(self.selected_items[0]):
                checksum_action = context_menu.addAction("Calculate Checksums")
                checksum_action.triggered.connect(lambda: self.calculate_and_show_md5(self.selected_items[0]))
            
            # Add "Reveal in File Manager" option for single items
            reveal_action = context_menu.addAction("Reveal in File Manager")
            reveal_action.triggered.connect(lambda: self.show_reveal_in_file_manager_option(self.selected_items[0]))
            
            # Archive operations for single items
            if ArchiveManager.is_archive(self.selected_items[0]):
                context_menu.addSeparator()
                
                # Browse archive contents
                browse_action = context_menu.addAction("Browse Archive")
                browse_action.triggered.connect(lambda: self.browse_archive_contents(self.selected_items[0]))
                
                # Extract archive
                extract_action = context_menu.addAction("Extract Archive...")
                extract_action.triggered.connect(lambda: self.extract_archive_dialog(self.selected_items[0]))
        
        # Archive operations for multiple selections
        if len(self.selected_items) > 0:
            context_menu.addSeparator()
            create_archive_action = context_menu.addAction("Create Archive...")
            create_archive_action.triggered.connect(lambda: self.create_archive_dialog(self.selected_items))
        
        context_menu.addSeparator()
        
        delete_action = context_menu.addAction("Delete")
        delete_action.triggered.connect(lambda: self.delete_multiple_files(self.selected_items))
        delete_action.setEnabled(len(self.selected_items) > 0)
        
        # Always add "Open Terminal Here" option
        context_menu.addSeparator()
        terminal_action = context_menu.addAction("Open Terminal Here")
        
        # Add Properties option
        if len(self.selected_items) == 1:
            properties_action = context_menu.addAction("Properties")
            properties_action.triggered.connect(lambda: self.show_properties(self.selected_items[0]))
        
        # Determine the path to open terminal in
        if len(self.selected_items) == 1:
            selected_path = self.selected_items[0]
            if os.path.isdir(selected_path):
                # If it's a directory, open terminal in that directory
                terminal_action.triggered.connect(lambda: self.open_terminal_here(selected_path))
            else:
                # If it's a file, open terminal in the parent directory
                terminal_action.triggered.connect(lambda: self.open_terminal_here(os.path.dirname(selected_path)))
        else:
            # Multiple items selected, open terminal in current folder
            terminal_action.triggered.connect(lambda: self.open_terminal_here(current_tab.current_folder))

        # Use popup instead of exec_ so the menu is non-blocking and clicks outside
        # the application are still received while the menu is visible.
        context_menu.popup(global_pos)

    def open_with_dialog(self, file_path):
        """Show a custom dialog to select an application to open the file with, then launch it."""
        dlg = OpenWithDialog(self)
        if dlg.exec_() == QDialog.Accepted:
            app_path = dlg.get_app_path()
            if app_path:
                try:
                    import subprocess
                    import sys
                    import os
                    ext = os.path.splitext(app_path)[1].lower()
                    if sys.platform.startswith('win'):
                        # Windows: pass exe and file path
                        subprocess.Popen([app_path, file_path], shell=False)
                    elif sys.platform == 'darwin':
                        # macOS: if .app bundle, use 'open -a', else run directly
                        if app_path.endswith('.app'):
                            subprocess.Popen(['open', '-a', app_path, file_path])
                        else:
                            subprocess.Popen([app_path, file_path])
                    else:
                        # Linux/Unix: handle .desktop files with gtk-launch if possible
                        if ext == '.desktop':
                            # Try to extract the desktop file name and use gtk-launch
                            desktop_file = os.path.basename(app_path)
                            try:
                                subprocess.Popen(['gtk-launch', desktop_file, file_path])
                            except Exception:
                                subprocess.Popen([app_path, file_path])
                        else:
                            subprocess.Popen([app_path, file_path])
                except Exception as e:
                    from PyQt5.QtWidgets import QMessageBox
                    QMessageBox.critical(self, "Open with... Error", f"Could not open file with selected application:\n{str(e)}")

    def rename_file(self, path):
        """Rename a single file or folder"""
        old_name = os.path.basename(path)
        new_name, ok = QInputDialog.getText(self, "Rename", "New name:", text=old_name)
        
        if ok and new_name and new_name != old_name:
            try:
                new_path = os.path.join(os.path.dirname(path), new_name)
                if os.path.exists(new_path):
                    QMessageBox.warning(self, "Error", "A file or folder with that name already exists.")
                    return
                    
                os.rename(path, new_path)
                # Refresh the current tab
                current_tab = self.tab_manager.get_current_tab()
                if current_tab:
                    current_tab.refresh_current_view()
                
            except Exception as e:
                self.show_error_message("Rename Error", f"Could not rename: {old_name}", str(e))

    def show_properties(self, file_path):
        """Show properties dialog for a file or folder"""
        try:
            properties_dialog = PropertiesDialog(file_path, self)
            properties_dialog.exec_()
        except Exception as e:
            QMessageBox.critical(self, "Properties Error", f"Could not show properties: {str(e)}")

    def copy_path_to_clipboard(self, paths):
        """Copy file/folder paths to clipboard"""
        if paths:
            clipboard = QApplication.clipboard()
            if len(paths) == 1:
                clipboard.setText(paths[0])
            else:
                clipboard.setText('\n'.join(paths))
            
            # Show temporary status message
            count = len(paths)
            item_word = "path" if count == 1 else "paths"
            self.statusBar().showMessage(f"Copied {count} {item_word} to clipboard", 2000)
    
    def calculate_and_show_md5(self, file_path):
        """Calculate and display hash checksums for a file"""
        if not os.path.isfile(file_path):
            QMessageBox.warning(self, "File Checksum", "Cannot calculate checksum for directories or non-existent files.")
            return
        
        # Show progress dialog for large files
        progress_dialog = QProgressDialog("Calculating checksums...", "Cancel", 0, 100, self)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.setAutoClose(False)
        progress_dialog.setAutoReset(False)
        progress_dialog.show()
        
        try:
            import hashlib
            md5_hash = hashlib.md5()
            sha1_hash = hashlib.sha1()
            sha256_hash = hashlib.sha256()
            
            file_size = os.path.getsize(file_path)
            bytes_read = 0
            
            with open(file_path, 'rb') as f:
                while True:
                    if progress_dialog.wasCanceled():
                        return
                    
                    chunk = f.read(8192)  # Read in 8KB chunks
                    if not chunk:
                        break
                    
                    md5_hash.update(chunk)
                    sha1_hash.update(chunk)
                    sha256_hash.update(chunk)
                    bytes_read += len(chunk)
                    
                    # Update progress
                    if file_size > 0:
                        progress = int((bytes_read / file_size) * 100)
                        progress_dialog.setValue(progress)
                    
                    # Process events to keep UI responsive
                    QApplication.processEvents()
            
            md5_result = md5_hash.hexdigest()
            sha1_result = sha1_hash.hexdigest()
            sha256_result = sha256_hash.hexdigest()
            progress_dialog.close()
            
            # Create result dialog
            dialog = QDialog(self)
            dialog.setWindowTitle("File Checksums")
            dialog.setModal(True)
            dialog.resize(600, 300)
            
            layout = QVBoxLayout(dialog)
            
            # File info
            file_label = QLabel(f"File: {os.path.basename(file_path)}")
            file_label.setWordWrap(True)
            layout.addWidget(file_label)
            
            path_label = QLabel(f"Path: {file_path}")
            path_label.setWordWrap(True)
            layout.addWidget(path_label)
            
            size_label = QLabel(f"Size: {self._format_file_size(file_size)}")
            layout.addWidget(size_label)
            
            layout.addWidget(QLabel(""))  # Spacer
            
            # Hash results
            checksums = [
                ("MD5:", md5_result),
                ("SHA-1:", sha1_result), 
                ("SHA-256:", sha256_result)
            ]
            
            for label_text, hash_value in checksums:
                hash_label = QLabel(label_text)
                layout.addWidget(hash_label)
                
                hash_text = QLineEdit(hash_value)
                hash_text.setReadOnly(True)
                hash_text.setFont(QApplication.font())  # Monospace would be better
                layout.addWidget(hash_text)
            
            # Buttons
            button_layout = QHBoxLayout()
            
            copy_md5_button = QPushButton("Copy MD5")
            copy_md5_button.clicked.connect(lambda: self._copy_hash_to_clipboard("MD5", md5_result))
            button_layout.addWidget(copy_md5_button)
            
            copy_sha1_button = QPushButton("Copy SHA-1")
            copy_sha1_button.clicked.connect(lambda: self._copy_hash_to_clipboard("SHA-1", sha1_result))
            button_layout.addWidget(copy_sha1_button)
            
            copy_sha256_button = QPushButton("Copy SHA-256")
            copy_sha256_button.clicked.connect(lambda: self._copy_hash_to_clipboard("SHA-256", sha256_result))
            button_layout.addWidget(copy_sha256_button)
            
            button_layout.addStretch()
            
            close_button = QPushButton("Close")
            close_button.clicked.connect(dialog.accept)
            button_layout.addWidget(close_button)
            
            layout.addLayout(button_layout)
            
            dialog.exec_()
            
        except Exception as e:
            progress_dialog.close()
            QMessageBox.critical(self, "Checksum Error", f"Failed to calculate checksums:\n{str(e)}")
    
    def _copy_hash_to_clipboard(self, hash_type, hash_value):
        """Copy hash value to clipboard"""
        clipboard = QApplication.clipboard()
        clipboard.setText(hash_value)
        self.statusBar().showMessage(f"{hash_type} checksum copied to clipboard", 2000)
    
    def _format_file_size(self, size_bytes):
        """Format file size in human readable format"""
        if size_bytes == 0:
            return "0 B"
        size_names = ["B", "KB", "MB", "GB", "TB"]
        import math
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"
    
    def browse_archive_contents(self, archive_path):
        """Browse the contents of an archive file"""
        try:
            dialog = ArchiveBrowserDialog(archive_path, self)
            result = dialog.exec_()
            
            if result == QDialog.Accepted:
                selected_items = dialog.get_selected_items()
                if selected_items:
                    # Ask where to extract using built-in dialog
                    pass
                    dir_dialog = DirectorySelectionDialog(
                        "Select Extract Location",
                        os.path.dirname(archive_path),
                        self
                    )
                    if dir_dialog.exec_() == QDialog.Accepted:
                        extract_dir = dir_dialog.get_selected_directory()
                        if extract_dir:
                            self.extract_archive_items(archive_path, extract_dir, selected_items)
        
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to browse archive: {str(e)}")
    
    def extract_archive_dialog(self, archive_path):
        """Show dialog to extract an archive"""
        try:
            # Ask where to extract using built-in dialog
            default_extract_dir = os.path.dirname(archive_path)
            pass
            dir_dialog = DirectorySelectionDialog(
                "Select Extract Location",
                default_extract_dir,
                self
            )
            
            if dir_dialog.exec_() == QDialog.Accepted:
                extract_dir = dir_dialog.get_selected_directory()
                if extract_dir:
                    self.extract_archive_with_progress(archive_path, extract_dir)
        
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to extract archive: {str(e)}")
    
    def extract_archive_with_progress(self, archive_path, extract_dir):
        """Extract archive with progress dialog"""
        progress_dialog = QProgressDialog("Extracting archive...", "Cancel", 0, 100, self)
        progress_dialog.setWindowTitle("Extracting")
        progress_dialog.setModal(True)
        progress_dialog.show()
        
        def update_progress(current, total):
            if progress_dialog.wasCanceled():
                return False
            
            progress = int((current / total) * 100) if total > 0 else 0
            progress_dialog.setValue(progress)
            progress_dialog.setLabelText(f"Extracting... {current}/{total} files")
            QApplication.processEvents()
            return True
        
        try:
            res = ArchiveManager.extract_archive(
                archive_path,
                extract_dir,
                progress_callback=update_progress
            )

            progress_dialog.close()

            if res is None:
                QMessageBox.critical(self, "Error", "Extraction failed: internal error (no response from extractor)")
                return

            # Expect a (success:boolean, message:str) tuple
            if isinstance(res, tuple) and len(res) == 2:
                success, message = res
            else:
                QMessageBox.critical(self, "Error", f"Extraction failed: unexpected return from extractor: {res}")
                return

            if success:
                QMessageBox.information(self, "Success", message)
                # Refresh any open tab whose folder is the extract destination
                try:
                    norm_extract = os.path.normcase(os.path.abspath(extract_dir))
                    tm = getattr(self, 'tab_manager', None)
                    refreshed_any = False
                    if tm is not None:
                        # If the tab manager exposes a list of tabs, iterate it
                        tabs = getattr(tm, 'tabs', None)
                        if tabs:
                            for t in tabs:
                                try:
                                    tab_folder = getattr(t, 'current_folder', None)
                                    if not tab_folder:
                                        continue
                                    norm_tab = os.path.normcase(os.path.abspath(tab_folder))
                                    # If extract dir equals tab folder or is inside tab folder, refresh that tab
                                    if norm_extract == norm_tab or norm_extract.startswith(norm_tab + os.path.sep):
                                        try:
                                            if hasattr(t, 'refresh_current_view'):
                                                t.refresh_current_view()
                                            if hasattr(t, 'refresh_thumbnail_view'):
                                                t.refresh_thumbnail_view()
                                            refreshed_any = True
                                        except Exception:
                                            pass
                                except Exception:
                                    # Skip problematic tab entries rather than aborting the refresh loop
                                    pass
                        else:
                            # Fallback: only refresh current tab if it matches
                            try:
                                ct = tm.get_current_tab()
                                if ct:
                                    tab_folder = getattr(ct, 'current_folder', None)
                                    if tab_folder:
                                        norm_tab = os.path.normcase(os.path.abspath(tab_folder))
                                        if norm_extract == norm_tab or norm_extract.startswith(norm_tab + os.path.sep):
                                            try:
                                                ct.refresh_current_view()
                                            except Exception:
                                                pass
                                            refreshed_any = True
                            except Exception:
                                pass
                    # As a last resort, refresh the visible/current tab
                    if not refreshed_any:
                        try:
                            current_tab = getattr(self.tab_manager, 'get_current_tab') and self.tab_manager.get_current_tab()
                            if current_tab and hasattr(current_tab, 'refresh_current_view'):
                                current_tab.refresh_current_view()
                        except Exception:
                            pass
                except Exception:
                    # If any unexpected error occurs while deciding which tabs to refresh,
                    # swallow it to avoid crashing the extraction flow.
                    pass
            else:
                QMessageBox.warning(self, "Error", message)
        
        except Exception as e:
            progress_dialog.close()
            QMessageBox.critical(self, "Error", f"Extraction failed: {str(e)}")
    
    def extract_archive_items(self, archive_path, extract_dir, selected_items):
        """Extract specific items from archive (placeholder for now)"""
        # For now, just extract the entire archive
        # TODO: Implement selective extraction
        self.extract_archive_with_progress(archive_path, extract_dir)
    
    def create_archive_dialog(self, source_paths):
        """Show dialog to create an archive from selected files/folders"""
        try:
            # Ask for output location and name
            suggested_name = "archive.zip"
            if len(source_paths) == 1:
                base_name = os.path.basename(source_paths[0])
                suggested_name = f"{base_name}.zip"
            
            current_tab = self.tab_manager.get_current_tab()
            default_dir = current_tab.current_folder if current_tab else os.path.expanduser("~")
            
            archive_path, _ = QFileDialog.getSaveFileName(
                self,
                "Create Archive",
                os.path.join(default_dir, suggested_name),
                "ZIP Archives (*.zip);;TAR Archives (*.tar);;Gzipped TAR (*.tar.gz)"
            )
            
            if archive_path:
                self.create_archive_with_progress(source_paths, archive_path)
        
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to create archive: {str(e)}")
    
    def create_archive_with_progress(self, source_paths, archive_path):
        """Create archive with progress dialog"""
        progress_dialog = QProgressDialog("Creating archive...", "Cancel", 0, 100, self)
        progress_dialog.setWindowTitle("Creating Archive")
        progress_dialog.setModal(True)
        progress_dialog.show()
        
        def update_progress(current, total):
            if progress_dialog.wasCanceled():
                return False
            
            progress = int((current / total) * 100) if total > 0 else 0
            progress_dialog.setValue(progress)
            progress_dialog.setLabelText(f"Adding files... {current}/{total}")
            QApplication.processEvents()
            return True
        
        try:
            success, message = ArchiveManager.create_zip_archive(
                source_paths,
                archive_path,
                progress_callback=update_progress
            )
            
            progress_dialog.close()
            
            if success:
                QMessageBox.information(self, "Success", message)
                # Refresh current view to show the new archive
                current_tab = self.tab_manager.get_current_tab()
                if current_tab:
                    current_tab.refresh_current_view()
            else:
                QMessageBox.warning(self, "Error", message)
        
        except Exception as e:
            progress_dialog.close()
            QMessageBox.critical(self, "Error", f"Archive creation failed: {str(e)}")
    
    def create_archive_from_selection(self):
        """Create archive from current selection (menu action)"""
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            QMessageBox.warning(self, "Warning", "No active tab")
            return
            
        selected_items = getattr(self, 'selected_items', [])
        if not selected_items:
            QMessageBox.information(self, "Information", "No files or folders selected")
            return
            
        self.create_archive_dialog(selected_items)
    
    def extract_archive_from_selection(self):
        """Extract archive from current selection (menu action)"""
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            QMessageBox.warning(self, "Warning", "No active tab")
            return
            
        selected_items = getattr(self, 'selected_items', [])
        if len(selected_items) != 1:
            QMessageBox.information(self, "Information", "Please select exactly one archive file")
            return
            
        archive_path = selected_items[0]
        if not ArchiveManager.is_archive(archive_path):
            QMessageBox.warning(self, "Warning", "Selected file is not a supported archive")
            return
            
        self.extract_archive_dialog(archive_path)
    
    def browse_archive_from_selection(self):
        """Browse archive from current selection (menu action)"""
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            QMessageBox.warning(self, "Warning", "No active tab")
            return
            
        selected_items = getattr(self, 'selected_items', [])
        if len(selected_items) != 1:
            QMessageBox.information(self, "Information", "Please select exactly one archive file")
            return
            
        archive_path = selected_items[0]
        if not ArchiveManager.is_archive(archive_path):
            QMessageBox.warning(self, "Warning", "Selected file is not a supported archive")
            return
            
        self.browse_archive_contents(archive_path)

    def empty_space_right_clicked(self, global_pos):
        """Handle right-click on empty space"""
        context_menu = QMenu(self)

        # Create new actions
        new_folder_action = context_menu.addAction("New Folder")
        new_folder_action.triggered.connect(self.create_new_folder)

        new_file_action = context_menu.addAction("New File")
        new_file_action.triggered.connect(self.create_new_file)

        context_menu.addSeparator()

        # Paste action
        try:
            if self.clipboard_manager.get_current_operation()[0]:  # Has something to paste
                paste_action = context_menu.addAction("Paste")
                paste_action.triggered.connect(self.paste_action_triggered)
        except Exception:
            pass

        context_menu.addSeparator()

        # Open Terminal Here action
        terminal_action = context_menu.addAction("Open Terminal Here")
        current_tab = self.get_current_tab_manager().get_current_tab()
        if current_tab:
            terminal_action.triggered.connect(lambda: self.open_terminal_here(current_tab.current_folder))

        # Use popup instead of exec_ so the menu is non-blocking and clicks outside
        # the application are still received while the menu is visible.
        context_menu.popup(global_pos)

    def create_new_file(self):
        """Create a new file in current directory"""
        current_tab = self.get_current_tab_manager().get_current_tab()
        if not current_tab:
            return
            
        name, ok = QInputDialog.getText(self, "New File", "File name:")
        if ok and name:
            try:
                file_path = os.path.join(current_tab.current_folder, name)
                if os.path.exists(file_path):
                    QMessageBox.warning(self, "Error", "A file with that name already exists.")
                    return
                    
                # Create empty file
                with open(file_path, 'w') as f:
                    pass
                    
                self.refresh_current_view()
            except Exception as e:
                self.show_error_message("Error", f"Could not create file: {str(e)}")

    def create_new_folder(self):
        """Create a new folder in current directory"""
        current_tab = self.get_current_tab_manager().get_current_tab()
        if not current_tab:
            return
            
        name, ok = QInputDialog.getText(self, "New Folder", "Folder name:")
        if ok and name:
            try:
                folder_path = os.path.join(current_tab.current_folder, name)
                if os.path.exists(folder_path):
                    QMessageBox.warning(self, "Error", "A folder with that name already exists.")
                    return
                    
                os.makedirs(folder_path)
                self.refresh_current_view()
            except Exception as e:
                self.show_error_message("Error", f"Could not create folder: {str(e)}")

    def paste_to(self, dest_path):
        """Paste clipboard contents to destination"""
        # Reset conflict resolution for new paste operation
        self._paste_conflict_action = None
        self._paste_conflict_apply_all = False
        # Reset file merge conflict resolution
        self._merge_file_action = None
        self._merge_file_apply_all = False
        
        operation, paths = self.clipboard_manager.get_current_operation()

        if not operation or not paths:
            return

        # Normalize 'cut' to 'move' for AsyncFileOperation
        op = 'move' if operation == 'cut' else operation

        # Always use the async operation for consistency
        self.paste_multiple_items(paths, dest_path, op)

        # Clear clipboard after move operation
        if operation == "cut":
            self.clipboard_manager.clear_current()

        # Refresh view after paste operation
        current_tab = self.get_current_tab_manager().get_current_tab()
        if current_tab:
            current_tab.refresh_current_view()

    def paste_single_item(self, src_path, dest_path, operation):
        """Paste a single item"""
        import shutil  # Import shutil at the beginning of the function
        try:
            # Static variables to remember 'do for all' choice
            if not hasattr(self, '_paste_conflict_action'):
                self._paste_conflict_action = None
                self._paste_conflict_apply_all = False
            if not os.path.exists(src_path):
                QMessageBox.warning(self, "Error", f"Source file no longer exists: {os.path.basename(src_path)}")
                return
            src_name = os.path.basename(src_path)
            final_dest = os.path.join(dest_path, src_name)
            # Folder merge/overwrite/rename/skip dialog
            if os.path.isdir(src_path) and os.path.exists(final_dest) and os.path.isdir(final_dest):
                action = None
                if self._paste_conflict_apply_all and self._paste_conflict_action is not None:
                    action = self._paste_conflict_action
                else:
                    from PyQt5.QtWidgets import QCheckBox, QVBoxLayout
                    msg_box = QMessageBox(self)
                    msg_box.setWindowTitle("Folder Already Exists")
                    msg_box.setText(f"The folder '{src_name}' already exists in the destination.")
                    msg_box.setInformativeText("Choose what to do with the conflicting folder:")
                    merge_btn = msg_box.addButton("Merge", QMessageBox.YesRole)
                    merge_btn.setToolTip("Combine contents of both folders")
                    overwrite_btn = msg_box.addButton("Replace", QMessageBox.DestructiveRole)
                    overwrite_btn.setToolTip("Delete existing folder and replace with new one")
                    rename_btn = msg_box.addButton("Rename", QMessageBox.ActionRole)
                    rename_btn.setToolTip("Keep both folders by renaming the new one")
                    skip_btn = msg_box.addButton("Skip", QMessageBox.RejectRole)
                    skip_btn.setToolTip("Skip this folder and don't copy it")
                    msg_box.setIcon(QMessageBox.Question)
                    checkbox = QCheckBox("Apply to all folder conflicts")
                    layout = msg_box.layout()
                    layout.addWidget(checkbox, layout.rowCount(), 0, 1, layout.columnCount())
                    msg_box.exec_()
                    clicked = msg_box.clickedButton()
                    if clicked == skip_btn:
                        action = 'skip'
                    elif clicked == rename_btn:
                        action = 'rename'
                    elif clicked == overwrite_btn:
                        action = 'overwrite'
                    else:
                        action = 'merge'
                    if checkbox.isChecked():
                        self._paste_conflict_action = action
                        self._paste_conflict_apply_all = True
                if action == 'skip':
                    return
                elif action == 'rename':
                    from PyQt5.QtWidgets import QInputDialog
                    new_name, ok = QInputDialog.getText(self, "Rename Folder", "Enter new folder name:", text=src_name)
                    if not ok or not new_name:
                        return
                    final_dest = os.path.join(dest_path, new_name)
                    if os.path.exists(final_dest):
                        QMessageBox.warning(self, "Folder Exists", f"{final_dest} already exists. Please choose a different name.")
                        return
                elif action == 'overwrite':
                    shutil.rmtree(final_dest)
                # If merge, do nothing (merge logic below)
            # Handle name conflicts for files and non-merge folders
            elif os.path.exists(final_dest):
                action = None
                if self._paste_conflict_apply_all and self._paste_conflict_action is not None:
                    action = self._paste_conflict_action
                else:
                    from PyQt5.QtWidgets import QCheckBox, QVBoxLayout
                    msg_box = QMessageBox(self)
                    msg_box.setWindowTitle("File Already Exists")
                    msg_box.setText(f"The file '{src_name}' already exists in the destination.")
                    msg_box.setInformativeText("Choose what to do with the conflicting file:")
                    overwrite_btn = msg_box.addButton("Replace", QMessageBox.YesRole)
                    overwrite_btn.setToolTip("Replace the existing file with the new one")
                    rename_btn = msg_box.addButton("Rename", QMessageBox.ActionRole)
                    rename_btn.setToolTip("Keep both files by renaming the new one")
                    skip_btn = msg_box.addButton("Skip", QMessageBox.RejectRole)
                    skip_btn.setToolTip("Skip this file and don't copy it")
                    msg_box.setIcon(QMessageBox.Question)
                    checkbox = QCheckBox("Apply to all file conflicts")
                    layout = msg_box.layout()
                    layout.addWidget(checkbox, layout.rowCount(), 0, 1, layout.columnCount())
                    msg_box.exec_()
                    clicked = msg_box.clickedButton()
                    if clicked == skip_btn:
                        action = 'skip'
                    elif clicked == rename_btn:
                        action = 'rename'
                    elif clicked == overwrite_btn:
                        action = 'overwrite'
                    if checkbox.isChecked():
                        self._paste_conflict_action = action
                        self._paste_conflict_apply_all = True
                if action == 'skip':
                    return
                elif action == 'rename':
                    from PyQt5.QtWidgets import QInputDialog
                    name, ext = os.path.splitext(src_name)
                    new_name, ok = QInputDialog.getText(self, "Rename Item", "Enter new name:", text=src_name)
                    if not ok or not new_name:
                        return
                    final_dest = os.path.join(dest_path, new_name)
                    if os.path.exists(final_dest):
                        QMessageBox.warning(self, "Item Exists", f"{final_dest} already exists. Please choose a different name.")
                        return
                elif action == 'overwrite':
                    if os.path.isdir(final_dest):
                        shutil.rmtree(final_dest)
                    else:
                        os.remove(final_dest)
    # ...existing code...
            # Copy/move logic
            if operation == "copy":
                if os.path.isdir(src_path):
                    # Initialize file conflict resolution variables if not already set
                    if not hasattr(self, '_merge_file_action'):
                        self._merge_file_action = None
                        self._merge_file_apply_all = False
                    
                    def merge_folders(src, dst):
                        os.makedirs(dst, exist_ok=True)
                        items_copied = 0
                        skipped_items = 0
                        for item in os.listdir(src):
                            s = os.path.join(src, item)
                            d = os.path.join(dst, item)
                            if os.path.isdir(s):
                                copied, skipped = merge_folders(s, d)
                                items_copied += copied
                                skipped_items += skipped
                            else:
                                # Handle file conflicts during merge
                                if os.path.exists(d):
                                    action = None
                                    if self._merge_file_apply_all and self._merge_file_action is not None:
                                        action = self._merge_file_action
                                    else:
                                        from PyQt5.QtWidgets import QCheckBox, QVBoxLayout
                                        msg_box = QMessageBox(self)
                                        msg_box.setWindowTitle("File Conflict During Merge")
                                        msg_box.setText(f"The file '{item}' already exists in the destination folder.")
                                        msg_box.setInformativeText("What do you want to do with this file?")
                                        overwrite_btn = msg_box.addButton("Overwrite", QMessageBox.YesRole)
                                        overwrite_btn.setToolTip("Replace the existing file")
                                        skip_btn = msg_box.addButton("Skip", QMessageBox.RejectRole)
                                        skip_btn.setToolTip("Skip this file and continue")
                                        msg_box.setIcon(QMessageBox.Question)
                                        checkbox = QCheckBox("Apply to all file conflicts in this merge")
                                        layout = msg_box.layout()
                                        layout.addWidget(checkbox, layout.rowCount(), 0, 1, layout.columnCount())
                                        msg_box.exec_()
                                        clicked = msg_box.clickedButton()
                                        if clicked == skip_btn:
                                            action = 'skip'
                                        else:
                                            action = 'overwrite'
                                        if checkbox.isChecked():
                                            self._merge_file_action = action
                                            self._merge_file_apply_all = True
                                    
                                    if action == 'skip':
                                        skipped_items += 1
                                        continue
                                    # else: overwrite (default behavior)
                                
                                shutil.copy2(s, d)
                                items_copied += 1
                        return items_copied, skipped_items
                        
                    if os.path.exists(final_dest) and os.path.isdir(final_dest):
                        items_copied, skipped_items = merge_folders(src_path, final_dest)
                        if skipped_items > 0:
                            self.statusBar().showMessage(f"Merged folder: {src_name} ({items_copied} copied, {skipped_items} skipped)", 4000)
                        else:
                            self.statusBar().showMessage(f"Merged folder: {src_name} ({items_copied} items)", 3000)
                    else:
                        shutil.copytree(src_path, final_dest)
                        self.statusBar().showMessage(f"Copied: {src_name}", 3000)
                else:
                    shutil.copy2(src_path, final_dest)
                    self.statusBar().showMessage(f"Copied: {src_name}", 3000)
            else:  # cut/move
                if os.path.isdir(src_path):
                    # Initialize file conflict resolution variables if not already set
                    if not hasattr(self, '_merge_file_action'):
                        self._merge_file_action = None
                        self._merge_file_apply_all = False
                    
                    def move_merge_folders(src, dst):
                        """Move folder with merge capability"""
                        os.makedirs(dst, exist_ok=True)
                        items_moved = 0
                        skipped_items = 0
                        
                        for item in os.listdir(src):
                            s = os.path.join(src, item)
                            d = os.path.join(dst, item)
                            if os.path.isdir(s):
                                if os.path.exists(d) and os.path.isdir(d):
                                    # Merge subdirectories
                                    moved, skipped = move_merge_folders(s, d)
                                    items_moved += moved
                                    skipped_items += skipped
                                    try:
                                        os.rmdir(s)  # Remove empty source directory
                                    except OSError:
                                        pass  # Directory not empty (shouldn't happen, but just in case)
                                else:
                                    # Move directory directly
                                    shutil.move(s, d)
                                    items_moved += 1
                            else:
                                # Handle file conflicts during merge
                                if os.path.exists(d):
                                    action = None
                                    if self._merge_file_apply_all and self._merge_file_action is not None:
                                        action = self._merge_file_action
                                    else:
                                        from PyQt5.QtWidgets import QCheckBox, QVBoxLayout
                                        msg_box = QMessageBox(self)
                                        msg_box.setWindowTitle("File Conflict During Merge")
                                        msg_box.setText(f"The file '{item}' already exists in the destination folder.")
                                        msg_box.setInformativeText("What do you want to do with this file?")
                                        overwrite_btn = msg_box.addButton("Overwrite", QMessageBox.YesRole)
                                        overwrite_btn.setToolTip("Replace the existing file")
                                        skip_btn = msg_box.addButton("Skip", QMessageBox.RejectRole)
                                        skip_btn.setToolTip("Skip this file and continue")
                                        msg_box.setIcon(QMessageBox.Question)
                                        checkbox = QCheckBox("Apply to all file conflicts in this merge")
                                        layout = msg_box.layout()
                                        layout.addWidget(checkbox, layout.rowCount(), 0, 1, layout.columnCount())
                                        msg_box.exec_()
                                        clicked = msg_box.clickedButton()
                                        if clicked == skip_btn:
                                            action = 'skip'
                                        else:
                                            action = 'overwrite'
                                        if checkbox.isChecked():
                                            self._merge_file_action = action
                                            self._merge_file_apply_all = True
                                    
                                    if action == 'skip':
                                        skipped_items += 1
                                        continue
                                    # else: overwrite - remove existing file first
                                    os.remove(d)
                                
                                shutil.move(s, d)
                                items_moved += 1
                        # Remove empty source directory
                        try:
                            os.rmdir(src)
                        except OSError:
                            pass  # Directory not empty (shouldn't happen, but just in case)
                        return items_moved, skipped_items
                    
                    if os.path.exists(final_dest) and os.path.isdir(final_dest):
                        items_moved, skipped_items = move_merge_folders(src_path, final_dest)
                        if skipped_items > 0:
                            self.statusBar().showMessage(f"Merged folder: {src_name} ({items_moved} moved, {skipped_items} skipped)", 4000)
                        else:
                            self.statusBar().showMessage(f"Merged folder: {src_name} ({items_moved} items)", 3000)
                    else:
                        shutil.move(src_path, final_dest)
                        self.statusBar().showMessage(f"Moved: {src_name}", 3000)
                else:
                    # For files, use direct move
                    shutil.move(src_path, final_dest)
                    self.statusBar().showMessage(f"Moved: {src_name}", 3000)
            
            # Refresh the current view to show the newly pasted item
            current_tab = self.tab_manager.get_current_tab()
            if current_tab:
                current_tab.refresh_current_view()
                
        except Exception as e:
            self.show_error_message("Paste Error", f"Could not paste: {src_name}", str(e))

    def paste_multiple_items(self, src_paths, dest_path, operation):
        """Paste multiple items with enhanced async progress"""
        # Synchronous: just call paste_single_item for each path
        for src_path in src_paths:
            self.paste_single_item(src_path, dest_path, operation)

    def delete_file(self, path):
        """Delete a single file or folder"""
        try:
            name = os.path.basename(path)
            reply = QMessageBox.question(self, "Confirm Delete", 
                                       f"Are you sure you want to delete '{name}'?",
                                       QMessageBox.Yes | QMessageBox.No,
                                       QMessageBox.No)
            
            if reply == QMessageBox.Yes:
                if os.path.isdir(path):
                    shutil.rmtree(path)
                else:
                    os.remove(path)
                
                self.refresh_current_view()
                self.statusBar().showMessage(f"Deleted: {name}", 3000)
                
        except Exception as e:
            self.show_error_message("Delete Error", f"Could not delete: {os.path.basename(path)}", str(e))

    def delete_multiple_files(self, paths):
        """Delete multiple files/folders with confirmation and enhanced progress"""
        if not paths:
            return
        
        count = len(paths)
        item_word = "item" if count == 1 else "items"
        
        reply = QMessageBox.question(self, "Confirm Delete",
                                   f"Are you sure you want to delete {count} {item_word}?",
                                   QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)
        
        if reply != QMessageBox.Yes:
            return
        
        # Use async operation for better progress tracking on large operations
        if count > 10:  # Use async for larger operations
            async_operation = AsyncFileOperation(paths, None, "delete")
            progress_dialog = EnhancedProgressDialog("Delete Operation", count, self)
            worker = AsyncFileOperationWorker(async_operation)
            
            # Connect progress signals
            worker.progress.connect(progress_dialog.update_progress)
            worker.fileProgress.connect(progress_dialog.update_file_progress)
            worker.statusChanged.connect(progress_dialog.update_status)
            
            def on_finished(success, message, stats):
                progress_dialog.accept()
                self.refresh_current_view()
                status_msg = f"Deleted {count} items" if success else f"Delete operation failed"
                self.statusBar().showMessage(status_msg, 3000)
            
            def on_error(error_message):
                QMessageBox.warning(self, "Delete Error", f"Delete operation failed:\n{error_message}")
                progress_dialog.accept()
                self.refresh_current_view()
            
            worker.finished.connect(on_finished)
            worker.error.connect(on_error)
            
            worker.start()
            progress_dialog.exec_()
        else:
            # For small operations, use direct deletion
            success_count = 0
            errors = []
            
            for path in paths:
                try:
                    if os.path.isdir(path):
                        shutil.rmtree(path)
                    else:
                        os.remove(path)
                    success_count += 1
                except Exception as e:
                    errors.append(f"Error deleting {os.path.basename(path)}: {str(e)}")
            
            # Refresh view
            self.refresh_current_view()
            
            # Show results
            if errors:
                error_msg = f"Deleted {success_count} items successfully.\n\nErrors:\n" + "\n".join(errors[:5])
                if len(errors) > 5:
                    error_msg += f"\n... and {len(errors) - 5} more errors"
                QMessageBox.warning(self, "Delete Complete with Errors", error_msg)
            else:
                self.statusBar().showMessage(f"Deleted {success_count} items", 3000)

    def open_terminal_here(self, path):
        """Open terminal in the specified path"""
        try:
            if not PlatformUtils.open_terminal_at_path(path):
                QMessageBox.warning(self, "Error", "Could not open terminal at the specified location")
            else:
                self.statusBar().showMessage("Terminal opened", 2000)
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open terminal: {str(e)}")

    def on_double_click(self, index):
        """Handle double-click events from tree or other views"""
        try:
            if hasattr(index, 'data'):
                file_path = index.data(Qt.UserRole)
                if file_path and os.path.isdir(file_path):
                    # Navigate to directory in current tab
                    current_tab = self.tab_manager.get_current_tab()
                    if current_tab:
                        current_tab.navigate_to_path(file_path)
                elif file_path and ArchiveManager.is_archive(file_path):
                    # For archive files, show browse dialog instead of opening externally
                    self.browse_archive_contents(file_path)
                elif file_path:
                    self.icon_double_clicked(file_path)
        except Exception as e:
            self.show_error_message("Navigation Error", "Could not navigate to selected item", str(e))

    def cut_action_triggered(self):
        """Handle cut action (enhanced for dual pane mode)"""
        # Get selected items from the current active pane
        selected_items = self.get_current_selected_items()
        if selected_items:
            self.clipboard_manager.set_current_operation("cut", selected_items.copy())
            self.clipboard_manager.add_to_history("cut", selected_items.copy())
            self.statusBar().showMessage(f"Cut {len(selected_items)} items", 2000)

    def copy_action_triggered(self):
        """Handle copy action (enhanced for dual pane mode)"""
        # Get selected items from the current active pane
        selected_items = self.get_current_selected_items()
        if selected_items:
            self.clipboard_manager.set_current_operation("copy", selected_items.copy())
            self.clipboard_manager.add_to_history("copy", selected_items.copy())
            self.statusBar().showMessage(f"Copied {len(selected_items)} items", 2000)

    def get_current_selected_items(self):
        """Get selected items from the currently active pane"""
        # In both single and dual pane mode, the selection is tracked globally
        # The active pane switching ensures we're always working with the right selection
        return getattr(self, 'selected_items', [])

    # These are duplicate methods from earlier - removing since they're already defined above
    # def on_double_click(self, index):
    #     """Handle double-click events from tree or other views"""
    #     try:
    #         if hasattr(index, 'data'):
    #             file_path = index.data(Qt.UserRole)
    #             if file_path and os.path.isdir(file_path):
    #                 self.update_thumbnail_view(file_path)
    #             elif file_path:
    #                 self.icon_double_clicked(file_path)
    #     except Exception as e:
    #         self.show_error_message("Navigation Error", "Could not navigate to selected item", str(e))

    def refresh_current_view(self):
        """Refresh the current view"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            current_tab.refresh_current_view()

    def deselect_icons(self):
        """Deselect all icons"""
        self.selected_items = []
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            icon_container = getattr(current_tab, 'icon_container', None) if hasattr(current_tab, 'get_icon_container_safely') else None
            if not icon_container and hasattr(current_tab, 'get_icon_container_safely'):
                icon_container = current_tab.get_icon_container_safely()
            
            if icon_container and hasattr(icon_container, 'clear_selection'):
                icon_container.clear_selection()
        self.on_selection_changed([])

    def select_all_items(self):
        """Select all items in current view"""
        try:
            current_tab = self.tab_manager.get_current_tab()
            if not current_tab:
                return
                
            all_items = []
            for item_name in os.listdir(current_tab.current_folder):
                if not item_name.startswith('.') or getattr(self, 'show_hidden', False):
                    all_items.append(os.path.join(current_tab.current_folder, item_name))
            
            self.selected_items = all_items
            # Update UI selection state
            icon_container = getattr(current_tab, 'icon_container', None) if hasattr(current_tab, 'get_icon_container_safely') else None
            if not icon_container and hasattr(current_tab, 'get_icon_container_safely'):
                icon_container = current_tab.get_icon_container_safely()
            
            if icon_container:
                if hasattr(icon_container, 'clear_selection'):
                    icon_container.clear_selection()
                if hasattr(icon_container, 'add_to_selection_by_path'):
                    for path in all_items:
                        icon_container.add_to_selection_by_path(path)
            
            self.on_selection_changed(all_items)
            self.statusBar().showMessage(f"Selected {len(all_items)} items", 2000)
            
        except Exception as e:
            self.show_error_message("Selection Error", "Could not select all items", str(e))

    def delete_selected_items(self):
        """Delete currently selected items"""
        if self.selected_items:
            self.delete_multiple_files(self.selected_items)

    def rename_selected_item(self):
        """Rename the selected item (only works with single selection)"""
        if len(self.selected_items) == 1:
            self.rename_file(self.selected_items[0])
        elif len(self.selected_items) > 1:
            # For multiple selection, offer bulk rename
            reply = QMessageBox.question(self, "Bulk Rename", 
                                       f"You have {len(self.selected_items)} items selected. Would you like to bulk rename them?",
                                       QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                self.show_bulk_rename_dialog()
        else:
            QMessageBox.information(self, "No Selection", "Please select an item to rename.")

    def show_properties_selected_item(self):
        """Show properties for the selected item (only works with single selection)"""
        if len(self.selected_items) == 1:
            self.show_properties(self.selected_items[0])
        elif len(self.selected_items) > 1:
            QMessageBox.information(self, "Multiple Selection", "Properties can only be shown for a single item.")
        else:
            QMessageBox.information(self, "No Selection", "Please select an item to view properties.")

    def set_thumbnail_size(self, size):
        """Set the thumbnail size and refresh the view"""
        self.thumbnail_size = size
        
        # Update checkmarks
        self.update_thumbnail_menu_checkmarks()
        
        # Save the setting
        current_path = getattr(self, 'current_folder', os.path.expanduser("~"))
        self.save_last_dir(current_path)
        
        # Refresh all tabs with new thumbnail size
        for tab in self.tab_manager.tabs:
            tab.refresh_current_view()
            
        # If we're in auto-width mode, trigger relayout to recalculate with new thumbnail size
        if self.icons_wide == 0:  # Auto-width mode
            for tab in self.tab_manager.tabs:
                if hasattr(tab, 'icon_container') and tab.icon_container:
                    # Use a timer to ensure the refresh completes first
                    if not hasattr(tab, '_thumbnail_size_timer'):
                        from PyQt5.QtCore import QTimer
                        tab._thumbnail_size_timer = QTimer()
                        tab._thumbnail_size_timer.setSingleShot(True)
                        tab._thumbnail_size_timer.timeout.connect(lambda t=tab: t.get_icon_container_safely() and t.get_icon_container_safely().relayout_icons())
                    
                    tab._thumbnail_size_timer.stop()
                    tab._thumbnail_size_timer.start(200)  # Delay to let refresh complete first

    def update_thumbnail_menu_checkmarks(self):
        """Update menu checkmarks based on current thumbnail size"""
        self.small_thumb_action.setChecked(self.thumbnail_size == 48)
        self.medium_thumb_action.setChecked(self.thumbnail_size == 64)
        self.large_thumb_action.setChecked(self.thumbnail_size == 96)
        self.xlarge_thumb_action.setChecked(self.thumbnail_size == 128)
        # New sizes
        try:
            self.thumb_80_action.setChecked(self.thumbnail_size == 80)
            self.thumb_160_action.setChecked(self.thumbnail_size == 160)
            self.thumb_192_action.setChecked(self.thumbnail_size == 192)
            self.thumb_224_action.setChecked(self.thumbnail_size == 224)
            self.thumb_256_action.setChecked(self.thumbnail_size == 256)
            self.thumb_384_action.setChecked(self.thumbnail_size == 384)
            self.thumb_512_action.setChecked(self.thumbnail_size == 512)
            self.thumb_640_action.setChecked(self.thumbnail_size == 640)
            self.thumb_768_action.setChecked(self.thumbnail_size == 768)
        except AttributeError:
            # In case actions don't exist (older version), ignore
            pass

    def set_icons_wide(self, width):
        """Set the number of icons wide and refresh the view"""
        self.icons_wide = width
        
        # Update checkmarks
        self.update_layout_menu_checkmarks()
        
        # Save the setting
        current_path = getattr(self, 'current_folder', os.path.expanduser("~"))
        self.save_last_dir(current_path)
        
        # Refresh all tabs with new layout setting
        for tab in self.tab_manager.tabs:
            tab.refresh_current_view()

    def update_layout_menu_checkmarks(self):
        """Update layout menu checkmarks based on current icons wide setting"""
        self.auto_width_action.setChecked(self.icons_wide == 0)
        self.fixed_4_wide_action.setChecked(self.icons_wide == 4)
        self.fixed_6_wide_action.setChecked(self.icons_wide == 6)
        self.fixed_8_wide_action.setChecked(self.icons_wide == 8)
        self.fixed_10_wide_action.setChecked(self.icons_wide == 10)
        self.fixed_12_wide_action.setChecked(self.icons_wide == 12)

    def update_dark_mode_checkmark(self):
        """Update dark mode menu checkmark"""
        self.dark_mode_action.setChecked(self.dark_mode)

    def toggle_dark_mode(self):
        """Toggle between dark and light mode"""
        # On macOS, try to detect system theme preference
        if PlatformUtils.is_macos():
            try:
                # Check if system is in dark mode
                result = subprocess.run([
                    'defaults', 'read', '-g', 'AppleInterfaceStyle'
                ], capture_output=True, text=True)
                
                if result.returncode == 0 and 'Dark' in result.stdout:
                    # System is in dark mode, user might want to override
                    pass  # Continue with manual toggle
                else:
                    # System is in light mode
                    pass  # Continue with manual toggle
            except Exception:
                # If detection fails, just continue with manual toggle
                pass
        
        # Toggle and preserve/restore last light color theme when switching modes
        prev_dark = bool(getattr(self, 'dark_mode', False))
        self.dark_mode = not prev_dark

        try:
            settings = QSettings('garysfm', 'garysfm')
            # If switching FROM light TO dark, save the current colored theme
            if not prev_dark and self.dark_mode:
                try:
                    last_theme = getattr(self, 'color_theme', None)
                    if last_theme:
                        settings.setValue('last_light_theme', str(last_theme))
                except Exception:
                    pass
            # If switching FROM dark TO light, restore previously saved colored theme
            if prev_dark and not self.dark_mode:
                try:
                    restored = settings.value('last_light_theme', None)
                    # Ensure we have a plain Python string and normalize it
                    try:
                        if restored is None:
                            restored_str = None
                        else:
                            restored_str = str(restored).strip()
                    except Exception:
                        restored_str = None

                    # If restored value looks valid and matches a known theme, apply it
                    if restored_str and hasattr(self, 'COLOR_THEMES') and restored_str in self.COLOR_THEMES:
                        try:
                            self.set_color_theme(restored_str)
                        except Exception:
                            # Fallback: set attribute and reapply
                            self.color_theme = restored_str
                            self.apply_theme()
                            self.refresh_all_themes()
                    else:
                        # Try a looser match: compare case-insensitively to known keys
                        if restored_str and hasattr(self, 'COLOR_THEMES'):
                            lowered = restored_str.lower()
                            for key in self.COLOR_THEMES.keys():
                                if key.lower() == lowered:
                                    try:
                                        self.set_color_theme(key)
                                    except Exception:
                                        self.color_theme = key
                                        self.apply_theme()
                                        self.refresh_all_themes()
                                    break
                except Exception:
                    pass
            # Persist dark mode choice
            settings.setValue('dark_mode', bool(self.dark_mode))
        except Exception:
            pass
        self.apply_dark_mode()
        self.update_dark_mode_checkmark()
        
        # Save the setting immediately - use current tab's folder if available
        try:
            current_tab = self.tab_manager.get_current_tab()
            if current_tab and hasattr(current_tab, 'current_folder'):
                folder_path = current_tab.current_folder
            else:
                # Fallback: use home directory
                folder_path = os.path.expanduser("~")
            
            self.save_last_dir(folder_path)
        except Exception as e:
            print(f"Error saving settings during theme switch: {e}")
            # Continue with theme update even if save fails
        
        # Update all UI components instantly
        self.refresh_all_themes()

    def apply_dark_mode(self):
        """Apply dark mode styling"""
        # Centralized theme application: call the unified applier which
        # handles both dark mode and named light themes. This prevents
        # inconsistent clearing of a light color theme when toggling modes.
        try:
            self.apply_theme()
        except Exception:
            try:
                self.setStyleSheet("")
            except Exception:
                pass

    def open_theme_color_customization(self):
        """Open a dialog to customize theme colors and styling properties."""
        from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QLabel, QComboBox, QColorDialog, 
                                     QPushButton, QHBoxLayout, QLineEdit, QMessageBox, 
                                     QRadioButton, QButtonGroup, QSpinBox, QTabWidget, 
                                     QWidget, QGridLayout, QGroupBox, QSlider, QCheckBox,
                                     QScrollArea, QFrame)
        from PyQt5.QtCore import Qt
        
        dlg = QDialog(self)
        dlg.setWindowTitle('Advanced Theme Customization')
        dlg.resize(600, 700)
        
        # Create scroll area for the dialog content
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_widget = QWidget()
        layout = QVBoxLayout(scroll_widget)
        
        # Theme type selection
        type_layout = QHBoxLayout()
        type_label = QLabel('Theme Type:')
        regular_radio = QRadioButton('Regular')
        subdued_radio = QRadioButton('Subdued') 
        strong_radio = QRadioButton('Strong')
        regular_radio.setChecked(True)  # Default to regular
        
        type_group = QButtonGroup()
        type_group.addButton(regular_radio)
        type_group.addButton(subdued_radio)
        type_group.addButton(strong_radio)
        
        type_layout.addWidget(type_label)
        type_layout.addWidget(regular_radio)
        type_layout.addWidget(subdued_radio)
        type_layout.addWidget(strong_radio)
        type_layout.addStretch()
        layout.addLayout(type_layout)
        
        # Theme selection
        label = QLabel('Select a theme to customize:')
        layout.addWidget(label)
        theme_combo = QComboBox()
        layout.addWidget(theme_combo)
        
        # Create tab widget for different customization categories
        tab_widget = QTabWidget()
        
        # Colors Tab
        colors_tab = QWidget()
        colors_layout = QVBoxLayout(colors_tab)
        
        color_btns = {}
        color_labels = ['window_bg', 'panel_bg', 'text', 'accent']
        color_group = QGroupBox("Colors")
        color_grid = QGridLayout(color_group)
        
        for i, c in enumerate(color_labels):
            label = QLabel(c.replace('_', ' ').title() + ':')
            btn = QPushButton('Pick Color')
            btn.setObjectName(c)
            btn.setMinimumHeight(35)
            color_btns[c] = btn
            color_grid.addWidget(label, i, 0)
            color_grid.addWidget(btn, i, 1)
        
        colors_layout.addWidget(color_group)
        colors_layout.addStretch()
        tab_widget.addTab(colors_tab, "Colors")
        
        # Borders & Spacing Tab
        borders_tab = QWidget()
        borders_layout = QVBoxLayout(borders_tab)
        
        # Border settings
        border_group = QGroupBox("Border Settings")
        border_grid = QGridLayout(border_group)
        
        # Border width
        border_width_label = QLabel("Border Width:")
        border_width_spin = QSpinBox()
        border_width_spin.setRange(0, 10)
        border_width_spin.setValue(1)
        border_width_spin.setSuffix(" px")
        border_grid.addWidget(border_width_label, 0, 0)
        border_grid.addWidget(border_width_spin, 0, 1)
        
        # Border radius
        border_radius_label = QLabel("Border Radius:")
        border_radius_spin = QSpinBox()
        border_radius_spin.setRange(0, 20)
        border_radius_spin.setValue(3)
        border_radius_spin.setSuffix(" px")
        border_grid.addWidget(border_radius_label, 1, 0)
        border_grid.addWidget(border_radius_spin, 1, 1)
        
        # Border style
        border_style_label = QLabel("Border Style:")
        border_style_combo = QComboBox()
        border_style_combo.addItems(["solid", "dashed", "dotted", "double", "groove", "ridge", "inset", "outset"])
        border_grid.addWidget(border_style_label, 2, 0)
        border_grid.addWidget(border_style_combo, 2, 1)
        
        borders_layout.addWidget(border_group)
        
        # Spacing settings
        spacing_group = QGroupBox("Spacing & Margins")
        spacing_grid = QGridLayout(spacing_group)
        
        # Padding
        padding_label = QLabel("Padding:")
        padding_spin = QSpinBox()
        padding_spin.setRange(0, 50)
        padding_spin.setValue(5)
        padding_spin.setSuffix(" px")
        spacing_grid.addWidget(padding_label, 0, 0)
        spacing_grid.addWidget(padding_spin, 0, 1)
        
        # Margin
        margin_label = QLabel("Margin:")
        margin_spin = QSpinBox()
        margin_spin.setRange(0, 50)
        margin_spin.setValue(2)
        margin_spin.setSuffix(" px")
        spacing_grid.addWidget(margin_label, 1, 0)
        spacing_grid.addWidget(margin_spin, 1, 1)
        
        borders_layout.addWidget(spacing_group)
        borders_layout.addStretch()
        tab_widget.addTab(borders_tab, "Borders & Spacing")
        
        # Typography Tab
        typography_tab = QWidget()
        typography_layout = QVBoxLayout(typography_tab)
        
        font_group = QGroupBox("Font Settings")
        font_grid = QGridLayout(font_group)
        
        # Font size
        font_size_label = QLabel("Font Size:")
        font_size_spin = QSpinBox()
        font_size_spin.setRange(8, 24)
        font_size_spin.setValue(9)
        font_size_spin.setSuffix(" pt")
        font_grid.addWidget(font_size_label, 0, 0)
        font_grid.addWidget(font_size_spin, 0, 1)
        
        # Font weight
        font_weight_label = QLabel("Font Weight:")
        font_weight_combo = QComboBox()
        font_weight_combo.addItems(["normal", "bold", "lighter", "bolder"])
        font_grid.addWidget(font_weight_label, 1, 0)
        font_grid.addWidget(font_weight_combo, 1, 1)
        
        # Font family
        font_family_label = QLabel("Font Family:")
        font_family_combo = QComboBox()
        font_family_combo.addItems(["default", "Arial", "Helvetica", "Times New Roman", "Courier New", "Verdana", "Tahoma"])
        font_grid.addWidget(font_family_label, 2, 0)
        font_grid.addWidget(font_family_combo, 2, 1)
        
        typography_layout.addWidget(font_group)
        typography_layout.addStretch()
        tab_widget.addTab(typography_tab, "Typography")
        
        # Effects Tab
        effects_tab = QWidget()
        effects_layout = QVBoxLayout(effects_tab)
        
        effects_group = QGroupBox("Visual Effects")
        effects_grid = QGridLayout(effects_group)
        
        # Opacity
        opacity_label = QLabel("Opacity:")
        opacity_slider = QSlider(Qt.Horizontal)
        opacity_slider.setRange(50, 100)
        opacity_slider.setValue(100)
        opacity_value_label = QLabel("100%")
        opacity_slider.valueChanged.connect(lambda v: opacity_value_label.setText(f"{v}%"))
        effects_grid.addWidget(opacity_label, 0, 0)
        effects_grid.addWidget(opacity_slider, 0, 1)
        effects_grid.addWidget(opacity_value_label, 0, 2)
        
        # Shadow
        shadow_checkbox = QCheckBox("Enable Drop Shadow")
        effects_grid.addWidget(shadow_checkbox, 1, 0, 1, 3)
        
        # Shadow settings (initially disabled)
        shadow_blur_label = QLabel("Shadow Blur:")
        shadow_blur_spin = QSpinBox()
        shadow_blur_spin.setRange(0, 20)
        shadow_blur_spin.setValue(5)
        shadow_blur_spin.setSuffix(" px")
        shadow_blur_spin.setEnabled(False)
        effects_grid.addWidget(shadow_blur_label, 2, 0)
        effects_grid.addWidget(shadow_blur_spin, 2, 1)
        
        shadow_offset_label = QLabel("Shadow Offset:")
        shadow_offset_spin = QSpinBox()
        shadow_offset_spin.setRange(0, 10)
        shadow_offset_spin.setValue(2)
        shadow_offset_spin.setSuffix(" px")
        shadow_offset_spin.setEnabled(False)
        effects_grid.addWidget(shadow_offset_label, 3, 0)
        effects_grid.addWidget(shadow_offset_spin, 3, 1)
        
        # Enable/disable shadow controls
        def toggle_shadow_controls(checked):
            shadow_blur_spin.setEnabled(checked)
            shadow_offset_spin.setEnabled(checked)
        
        shadow_checkbox.toggled.connect(toggle_shadow_controls)
        
        effects_layout.addWidget(effects_group)
        effects_layout.addStretch()
        tab_widget.addTab(effects_tab, "Effects")
        
        layout.addWidget(tab_widget)
        
        # Save as new theme section
        save_group = QGroupBox("Save Theme")
        save_layout = QVBoxLayout(save_group)
        
        # Add info about save location
        themes_dir = self.get_themes_directory()
        save_info_label = QLabel(f'Themes will be saved to: {themes_dir}')
        save_info_label.setStyleSheet('color: #666; font-size: 10px;')
        save_info_label.setWordWrap(True)
        save_layout.addWidget(save_info_label)
        
        # Theme name input layout
        name_layout = QHBoxLayout()
        save_label = QLabel('Theme name:')
        save_name_input = QLineEdit()
        save_name_input.setPlaceholderText('Enter new theme name...')
        save_btn = QPushButton('Save Theme')
        name_layout.addWidget(save_label)
        name_layout.addWidget(save_name_input)
        name_layout.addWidget(save_btn)
        save_layout.addLayout(name_layout)
        layout.addWidget(save_group)
        
        # Set scroll widget and add to main dialog layout
        scroll_area.setWidget(scroll_widget)
        main_layout = QVBoxLayout(dlg)
        main_layout.addWidget(scroll_area)
        
        # Button layout at bottom of dialog
        button_layout = QHBoxLayout()
        reset_btn = QPushButton('Reset')
        preview_btn = QPushButton('Preview')
        ok_btn = QPushButton('Close')
        button_layout.addWidget(reset_btn)
        button_layout.addWidget(preview_btn)
        button_layout.addStretch()
        button_layout.addWidget(ok_btn)
        main_layout.addLayout(button_layout)
        
        # Current theme data storage
        current_theme_data = {}
        
        def get_current_theme_dict():
            """Get the current theme dictionary based on selected type."""
            if subdued_radio.isChecked():
                return getattr(self, 'SUBDUED_COLOR_THEMES', {})
            elif strong_radio.isChecked():
                return getattr(self, 'STRONG_COLOR_THEMES', {})
            else:
                return self.COLOR_THEMES
        
        def update_theme_combo():
            """Update theme combo box based on selected type, preserving current selection."""
            # Remember the currently selected theme name
            current_selection = theme_combo.currentText()
            
            theme_combo.clear()
            current_dict = get_current_theme_dict()
            theme_names = sorted(current_dict.keys())
            theme_combo.addItems(theme_names)
            
            # Always try to restore the previous selection, even if it doesn't exist yet
            if current_selection:
                # If the theme exists in the new category, select it
                if current_selection in theme_names:
                    index = theme_names.index(current_selection)
                    theme_combo.setCurrentIndex(index)
                else:
                    # If it doesn't exist, add it as an editable option and select it
                    theme_combo.addItem(current_selection)
                    theme_combo.setCurrentIndex(len(theme_names))  # Select the newly added item
            elif theme_names:
                # Only default to first item if there was no previous selection
                theme_combo.setCurrentIndex(0)
            
            update_all_controls()
        
        def update_all_controls():
            """Update all controls with current theme data."""
            theme_dict = get_current_theme_dict()
            theme_name = theme_combo.currentText()
            theme = theme_dict.get(theme_name, {})
            current_theme_data.clear()
            
            # Update colors
            for c in color_labels:
                color = theme.get(c, '#ffffff')
                current_theme_data[c] = color
                btn = color_btns[c]
                btn.setStyleSheet(f'background-color:{color}; border: 1px solid #ccc; padding: 5px;')
            
            # Set default values for new properties
            current_theme_data.update({
                'border_width': int(theme.get('border_width', 1)),
                'border_radius': int(theme.get('border_radius', 3)),
                'border_style': str(theme.get('border_style', 'solid')),
                'padding': int(theme.get('padding', 5)),
                'margin': int(theme.get('margin', 2)),
                'font_size': int(theme.get('font_size', 9)),
                'font_weight': str(theme.get('font_weight', 'normal')),
                'font_family': str(theme.get('font_family', 'default')),
                'opacity': int(theme.get('opacity', 100)),
                'shadow_enabled': bool(theme.get('shadow_enabled', False)),
                'shadow_blur': int(theme.get('shadow_blur', 5)),
                'shadow_offset': int(theme.get('shadow_offset', 2)),
            })
            
            # Update controls with proper type conversion
            border_width_spin.setValue(int(current_theme_data.get('border_width', 1)))
            border_radius_spin.setValue(int(current_theme_data.get('border_radius', 3)))
            border_style_combo.setCurrentText(str(current_theme_data.get('border_style', 'solid')))
            padding_spin.setValue(int(current_theme_data.get('padding', 5)))
            margin_spin.setValue(int(current_theme_data.get('margin', 2)))
            font_size_spin.setValue(int(current_theme_data.get('font_size', 9)))
            font_weight_combo.setCurrentText(str(current_theme_data.get('font_weight', 'normal')))
            font_family_combo.setCurrentText(str(current_theme_data.get('font_family', 'default')))
            opacity_slider.setValue(int(current_theme_data.get('opacity', 100)))
            shadow_checkbox.setChecked(bool(current_theme_data.get('shadow_enabled', False)))
            shadow_blur_spin.setValue(int(current_theme_data.get('shadow_blur', 5)))
            shadow_offset_spin.setValue(int(current_theme_data.get('shadow_offset', 2)))
            
            # Default the save name to current theme name
            if theme_name:
                save_name_input.setText(theme_name)
        
        def pick_color(c):
            initial_color = current_theme_data.get(c, '#ffffff')
            from PyQt5.QtGui import QColor
            col = QColorDialog.getColor(QColor(initial_color))
            if col.isValid():
                current_theme_data[c] = col.name()
                btn = color_btns[c]
                btn.setStyleSheet(f'background-color:{col.name()}; border: 1px solid #ccc; padding: 5px;')
        
        def update_value(key, value):
            """Update a value in current theme data."""
            current_theme_data[key] = value
        
        def preview_theme():
            """Apply current settings as a temporary preview."""
            # Create a temporary theme with current settings
            temp_theme = current_theme_data.copy()
            theme_dict = get_current_theme_dict()
            theme_name = theme_combo.currentText()
            if theme_name in theme_dict:
                # Backup original and apply temporary
                original_theme = theme_dict[theme_name].copy()
                theme_dict[theme_name] = temp_theme
                self.apply_theme()
                QMessageBox.information(dlg, 'Preview', 'Theme preview applied! You can see the changes in the background.')
        
        def save_theme():
            new_name = save_name_input.text().strip()
            if not new_name:
                QMessageBox.warning(dlg, 'Warning', 'Please enter a theme name.')
                return
                
            # Check if name exists in any theme dictionary
            name_exists = (new_name in self.COLOR_THEMES or 
                          new_name in getattr(self, 'SUBDUED_COLOR_THEMES', {}) or
                          new_name in getattr(self, 'STRONG_COLOR_THEMES', {}))
            
            if name_exists:
                reply = QMessageBox.question(dlg, 'Confirm', f'Theme "{new_name}" already exists. Overwrite?')
                if reply != QMessageBox.Yes:
                    return
            
            # Save to regular themes (always save to regular for base)
            self.COLOR_THEMES[new_name] = current_theme_data.copy()
            
            # Also save to the selected theme type if different
            current_dict = get_current_theme_dict()
            if current_dict is not self.COLOR_THEMES:
                current_dict[new_name] = current_theme_data.copy()
            
            # Save theme to .gsfmt file with current mode information
            current_mode = "regular"
            if subdued_radio.isChecked():
                current_mode = "subdued"
            elif strong_radio.isChecked():
                current_mode = "strong"
            
            if self.save_theme_to_file_with_mode(new_name, current_theme_data.copy(), current_mode):
                # Also save custom themes to settings for backward compatibility
                self.save_custom_themes()
            else:
                # Fallback to settings only if file save fails
                self.save_custom_themes()
            
            # Use the new populate function to ensure this theme is available in all modes
            self.populate_all_theme_modes()
            
            QMessageBox.information(dlg, 'Success', f'Theme "{new_name}" saved successfully and is now available in all modes!')
            save_name_input.clear()
            
            # Save all theme settings immediately
            self.save_theme_settings()
            
            # Refresh the theme menu to show the new theme
            self.refresh_theme_menu()
        
        # Connect all controls
        def on_radio_changed():
            """Handle radio button changes, only update when a radio is selected."""
            if (regular_radio.isChecked() or 
                subdued_radio.isChecked() or 
                strong_radio.isChecked()):
                update_theme_combo()
        
        regular_radio.toggled.connect(on_radio_changed)
        subdued_radio.toggled.connect(on_radio_changed)
        strong_radio.toggled.connect(on_radio_changed)
        
        for c in color_labels:
            color_btns[c].clicked.connect(lambda _, cc=c: pick_color(cc))
        
        theme_combo.currentIndexChanged.connect(update_all_controls)
        
        # Connect styling controls
        border_width_spin.valueChanged.connect(lambda v: update_value('border_width', v))
        border_radius_spin.valueChanged.connect(lambda v: update_value('border_radius', v))
        border_style_combo.currentTextChanged.connect(lambda v: update_value('border_style', v))
        padding_spin.valueChanged.connect(lambda v: update_value('padding', v))
        margin_spin.valueChanged.connect(lambda v: update_value('margin', v))
        font_size_spin.valueChanged.connect(lambda v: update_value('font_size', v))
        font_weight_combo.currentTextChanged.connect(lambda v: update_value('font_weight', v))
        font_family_combo.currentTextChanged.connect(lambda v: update_value('font_family', v))
        opacity_slider.valueChanged.connect(lambda v: update_value('opacity', v))
        shadow_checkbox.toggled.connect(lambda v: update_value('shadow_enabled', v))
        shadow_blur_spin.valueChanged.connect(lambda v: update_value('shadow_blur', v))
        shadow_offset_spin.valueChanged.connect(lambda v: update_value('shadow_offset', v))
        
        # Connect buttons
        save_btn.clicked.connect(save_theme)
        reset_btn.clicked.connect(update_all_controls)
        preview_btn.clicked.connect(preview_theme)
        ok_btn.clicked.connect(dlg.accept)
        
        # Initialize the dialog
        update_theme_combo()
        
        dlg.exec_()

    def save_custom_themes(self):
        """Save custom themes to QSettings for persistence."""
        try:
            settings = QSettings('garysfm', 'garysfm')
            
            # Find custom themes (those not in the original built-in set)
            original_themes = {
                'Default Light'  # Only built-in theme remaining
            }
            
            custom_themes = {}
            for name, theme in self.COLOR_THEMES.items():
                if name not in original_themes:
                    custom_themes[name] = theme
            
            # Save as JSON string
            import json
            settings.setValue('custom_themes', json.dumps(custom_themes))
        except Exception:
            pass

    def get_qss_directory(self):
        """Get the QSS directory path, creating it if it doesn't exist.
        Works for both development (.py) and compiled executable (.exe) environments."""
        import os
        import sys
        
        # Determine the correct base directory for both development and compiled exe
        if getattr(sys, 'frozen', False):
            # Running as compiled executable (PyInstaller, cx_Freeze, etc.)
            if hasattr(sys, '_MEIPASS'):
                # PyInstaller temporary folder
                base_dir = sys._MEIPASS
            else:
                # Other compiled environments - use executable location
                base_dir = os.path.dirname(sys.executable)
        else:
            # Running as Python script - use script location
            base_dir = os.path.dirname(os.path.abspath(__file__))
        
        # Look for qss folder in multiple locations for robustness
        possible_locations = [
            os.path.join(base_dir, 'qss'),                    # Next to exe/script
            os.path.join(os.getcwd(), 'qss'),                 # Current working directory
            os.path.join(os.path.dirname(base_dir), 'qss'),   # Parent directory
        ]
        
        # If running as exe, also check next to the actual executable
        if getattr(sys, 'frozen', False):
            exe_dir = os.path.dirname(sys.executable)
            possible_locations.insert(0, os.path.join(exe_dir, 'qss'))
        
        # Find existing qss directory
        for qss_dir in possible_locations:
            if os.path.exists(qss_dir) and os.path.isdir(qss_dir):
                # Check if it actually contains QSS files
                if any(f.endswith('.qss') for f in os.listdir(qss_dir)):
                    return qss_dir
        
        # If no existing directory found, create one in the best location
        if getattr(sys, 'frozen', False):
            # For compiled exe, create next to the executable
            preferred_dir = os.path.join(os.path.dirname(sys.executable), 'qss')
        else:
            # For development, create next to the script
            preferred_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'qss')
        
        try:
            os.makedirs(preferred_dir, exist_ok=True)
            return preferred_dir
        except OSError:
            # If we can't create the preferred directory, fall back to the script directory
            fallback_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'qss')
            try:
                os.makedirs(fallback_dir, exist_ok=True)
                return fallback_dir
            except OSError:
                # Last resort - return the script directory even if we can't create qss subfolder
                return os.path.dirname(os.path.abspath(__file__))

    def get_themes_directory(self):
        """Get the themes directory path, creating it if it doesn't exist.
        Works for both development (.py) and compiled executable (.exe) environments."""
        import os
        import sys
        
        # Determine the correct base directory for both development and compiled exe
        if getattr(sys, 'frozen', False):
            # Running as compiled executable (PyInstaller, cx_Freeze, etc.)
            if hasattr(sys, '_MEIPASS'):
                # PyInstaller temporary folder
                base_dir = sys._MEIPASS
            else:
                # Other compiled environments - use executable location
                base_dir = os.path.dirname(sys.executable)
        else:
            # Running as Python script - use script location
            base_dir = os.path.dirname(os.path.abspath(__file__))
        
        # Look for gsfmt folder in multiple locations for robustness
        possible_locations = [
            os.path.join(base_dir, 'gsfmt'),                    # Next to exe/script
            os.path.join(os.getcwd(), 'gsfmt'),                 # Current working directory
            os.path.join(os.path.dirname(base_dir), 'gsfmt'),   # Parent directory
        ]
        
        # If running as exe, also check next to the actual executable
        if getattr(sys, 'frozen', False):
            exe_dir = os.path.dirname(sys.executable)
            possible_locations.insert(0, os.path.join(exe_dir, 'gsfmt'))
        
        # Find existing gsfmt directory
        for themes_dir in possible_locations:
            if os.path.exists(themes_dir) and os.path.isdir(themes_dir):
                # Check if it actually contains theme files
                if any(f.endswith('.gsfmt') for f in os.listdir(themes_dir)):
                    return themes_dir
        
        # If no existing directory found, create one in the best location
        if getattr(sys, 'frozen', False):
            # For compiled exe, create next to the executable
            preferred_dir = os.path.join(os.path.dirname(sys.executable), 'gsfmt')
        else:
            # For development, create next to the script
            preferred_dir = os.path.join(base_dir, 'gsfmt')
        
        # Create the directory if it doesn't exist
        if not os.path.exists(preferred_dir):
            try:
                os.makedirs(preferred_dir)
                print(f"Created themes directory: {preferred_dir}")
            except Exception as e:
                print(f"Error creating themes directory: {e}")
                # Fallback to base directory if we can't create gsfmt folder
                return base_dir
                
        return preferred_dir

    def debug_theme_paths(self):
        """Debug function to show where the application is looking for themes.
        Useful for troubleshooting compiled executable issues."""
        import os
        import sys
        
        print("🔍 Theme Directory Debug Information")
        print("=" * 50)
        
        # Show runtime environment
        if getattr(sys, 'frozen', False):
            print(f"✅ Running as: Compiled executable")
            print(f"📁 Executable path: {sys.executable}")
            if hasattr(sys, '_MEIPASS'):
                print(f"📁 PyInstaller temp path: {sys._MEIPASS}")
        else:
            print(f"✅ Running as: Python script")
            print(f"📁 Script path: {os.path.abspath(__file__)}")
        
        print(f"📁 Current working directory: {os.getcwd()}")
        
        # Show the chosen themes directory
        themes_dir = self.get_themes_directory()
        print(f"📁 Selected themes directory: {themes_dir}")
        
        # Check if directory exists and list contents
        if os.path.exists(themes_dir):
            print(f"✅ Themes directory exists")
            theme_files = [f for f in os.listdir(themes_dir) if f.endswith('.gsfmt')]
            print(f"📊 Found {len(theme_files)} theme files:")
            for i, filename in enumerate(theme_files[:10], 1):  # Show first 10
                print(f"   {i:2d}. {filename}")
            if len(theme_files) > 10:
                print(f"   ... and {len(theme_files) - 10} more")
        else:
            print(f"❌ Themes directory does not exist")
        
        print("=" * 50)

    def migrate_existing_theme_files(self):
        """Migrate any existing .gsfmt files from script directory to themes directory."""
        try:
            import os
            import shutil
            
            # Get directories
            script_dir = os.path.dirname(os.path.abspath(__file__))
            themes_dir = self.get_themes_directory()
            
            # Skip if themes_dir is the same as script_dir (fallback case)
            if script_dir == themes_dir:
                return
                
            # Look for .gsfmt files in script directory
            migrated_count = 0
            for filename in os.listdir(script_dir):
                if filename.endswith('.gsfmt'):
                    source_path = os.path.join(script_dir, filename)
                    dest_path = os.path.join(themes_dir, filename)
                    
                    # Only move if destination doesn't exist
                    if not os.path.exists(dest_path):
                        try:
                            shutil.move(source_path, dest_path)
                            migrated_count += 1
                            print(f"Migrated theme file: {filename}")
                        except Exception as e:
                            print(f"Error migrating {filename}: {e}")
                            
            if migrated_count > 0:
                print(f"Migrated {migrated_count} theme files to gsfmt folder")
                
        except Exception as e:
            print(f"Error during theme file migration: {e}")

    def manual_theme_cleanup(self):
        """Manual theme cleanup triggered by user from menu."""
        try:
            from PyQt5.QtWidgets import QMessageBox
            
            # Count themes before cleanup
            before_count = len(self.COLOR_THEMES)
            
            # Perform cleanup
            self.scan_and_cleanup_themes()
            
            # Count themes after cleanup
            after_count = len(self.COLOR_THEMES)
            removed_count = before_count - after_count
            
            # Show result to user
            if removed_count > 0:
                QMessageBox.information(
                    self,
                    "Theme Cleanup Complete",
                    f"Successfully removed {removed_count} orphaned theme(s).\n\n"
                    f"Themes before cleanup: {before_count}\n"
                    f"Themes after cleanup: {after_count}\n\n"
                    "Theme menus will be refreshed automatically."
                )
                # Refresh the theme menu to reflect changes
                if hasattr(self, 'theme_menu'):
                    self.refresh_theme_menu()
            else:
                QMessageBox.information(
                    self,
                    "Theme Cleanup Complete", 
                    "No orphaned themes found. All themes have corresponding .gsfmt files or are built-in themes."
                )
                
        except Exception as e:
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.warning(
                self,
                "Theme Cleanup Error",
                f"An error occurred during theme cleanup:\n\n{str(e)}"
            )

    def scan_and_cleanup_themes(self):
        """Scan for existing .gsfmt files and remove any themes from dictionaries that don't have corresponding files."""
        try:
            import os
            
            # Get the themes directory
            themes_dir = self.get_themes_directory()
            
            # Get list of existing .gsfmt files and their theme names
            existing_theme_files = set()
            theme_name_mapping = {}  # filename -> actual theme name from file
            
            if os.path.exists(themes_dir):
                for filename in os.listdir(themes_dir):
                    if filename.endswith('.gsfmt'):
                        try:
                            import json
                            theme_path = os.path.join(themes_dir, filename)
                            with open(theme_path, 'r', encoding='utf-8') as f:
                                theme_data = json.load(f)
                            
                            # Extract actual theme name from file content
                            if isinstance(theme_data, dict):
                                if "theme_info" in theme_data and "theme_data" in theme_data:
                                    # New format with mode information
                                    theme_name = theme_data["theme_info"]["name"]
                                    existing_theme_files.add(theme_name)
                                    theme_name_mapping[filename[:-6]] = theme_name
                                else:
                                    # Legacy format - could have multiple themes
                                    for theme_name in theme_data.keys():
                                        if isinstance(theme_data[theme_name], dict):
                                            existing_theme_files.add(theme_name)
                                            theme_name_mapping[filename[:-6]] = theme_name
                        except Exception:
                            # If we can't read the file, just use filename
                            base_name = filename[:-6].replace('_', ' ').title()
                            existing_theme_files.add(base_name)
            
            # Define built-in themes that should always be kept
            built_in_themes = {'Default Light'}
            
            # Keep track of removed themes for reporting
            removed_themes = []
            
            # Clean up COLOR_THEMES (keep Default Light, built-ins, and any with existing files)
            themes_to_remove = []
            for theme_name in list(self.COLOR_THEMES.keys()):
                if (theme_name not in built_in_themes and 
                    theme_name not in existing_theme_files):
                    themes_to_remove.append(theme_name)

            for theme_name in themes_to_remove:
                del self.COLOR_THEMES[theme_name]
                removed_themes.append(f"Regular: {theme_name}")

            # Clean up STRONG_COLOR_THEMES for the same orphaned themes
            strong_themes_to_remove = []
            for theme_name in list(self.STRONG_COLOR_THEMES.keys()):
                if (theme_name not in built_in_themes and 
                    theme_name not in existing_theme_files):
                    strong_themes_to_remove.append(theme_name)

            for theme_name in strong_themes_to_remove:
                del self.STRONG_COLOR_THEMES[theme_name]
                removed_themes.append(f"Strong: {theme_name}")

            # Clean up SUBDUED_COLOR_THEMES for the same orphaned themes
            subdued_themes_to_remove = []
            for theme_name in list(self.SUBDUED_COLOR_THEMES.keys()):
                if (theme_name not in built_in_themes and 
                    theme_name not in existing_theme_files):
                    subdued_themes_to_remove.append(theme_name)

            for theme_name in subdued_themes_to_remove:
                del self.SUBDUED_COLOR_THEMES[theme_name]
                removed_themes.append(f"Subdued: {theme_name}")

            # For DARK_COLOR_THEMES, also clean up orphaned themes
            dark_themes_to_remove = []
            for theme_name in list(self.DARK_COLOR_THEMES.keys()):
                if (theme_name not in built_in_themes and 
                    theme_name not in existing_theme_files):
                    dark_themes_to_remove.append(theme_name)

            for theme_name in dark_themes_to_remove:
                del self.DARK_COLOR_THEMES[theme_name]
                removed_themes.append(f"Dark: {theme_name}")

            # Note: We clean up all theme dictionaries for consistency            # Report cleanup results (only show significant cleanups)
            if removed_themes:
                if len(removed_themes) >= 5:  # Only report when cleaning up 5+ themes
                    print(f"Cleaned up {len(removed_themes)} orphaned themes from all theme dictionaries:")
                    for theme in removed_themes[:3]:  # Show first 3
                        print(f"  - {theme}")
                    if len(removed_themes) > 3:
                        print(f"  ... and {len(removed_themes) - 3} more")
                # Silent cleanup for fewer themes
            else:
                # Silent when no cleanup needed
                pass
                
        except Exception as e:
            print(f"Error during theme cleanup: {e}")

    def load_custom_themes(self):
        """Load custom themes from .gsfmt files only (no more QSettings)."""
        # First migrate any existing theme files to the new location
        self.migrate_existing_theme_files()
        
        # Clean up themes that don't have corresponding files
        self.scan_and_cleanup_themes()
        
        # Clear legacy QSettings themes (one-time cleanup for orphaned themes)
        try:
            settings = QSettings('garysfm', 'garysfm')
            legacy_themes = settings.value('custom_themes', '{}')
            if legacy_themes and legacy_themes != '{}':
                # Clear the old themes to prevent orphaned theme creation
                settings.setValue('custom_themes', '{}')
                print(f"Cleared legacy themes from QSettings to prevent orphaned themes")
        except Exception as e:
            print(f"Error clearing legacy themes: {e}")
        
        # Load themes from .gsfmt files only
        self.load_theme_files()
        
        # Populate all theme modes to ensure every theme is available in all modes
        self.populate_all_theme_modes()
        
        # Refresh theme menu after loading all custom themes
        if hasattr(self, 'theme_menu'):
            self.refresh_theme_menu()

    def load_theme_files(self):
        """Load themes from .gsfmt files in the themes directory."""
        try:
            import os
            import json
            import sys
            
            # Get the themes directory
            themes_dir = self.get_themes_directory()
            
            # Debug information for compiled executables
            if getattr(sys, 'frozen', False):
                print(f"[THEME-DEBUG] Running as compiled executable")
                print(f"[THEME-DEBUG] Looking for themes in: {themes_dir}")
            
            # Count loaded themes for feedback
            themes_loaded = 0
            
            # Find all .gsfmt files in the themes directory
            if os.path.exists(themes_dir):
                theme_files = [f for f in os.listdir(themes_dir) if f.endswith('.gsfmt')]
                
                if getattr(sys, 'frozen', False):
                    print(f"[THEME-DEBUG] Found {len(theme_files)} .gsfmt files")
                
                for filename in theme_files:
                    if filename.endswith('.gsfmt'):
                        theme_path = os.path.join(themes_dir, filename)
                        try:
                            with open(theme_path, 'r', encoding='utf-8') as f:
                                theme_data = json.load(f)
                            
                            # Handle new format with mode information
                            if isinstance(theme_data, dict):
                                if "theme_info" in theme_data and "theme_data" in theme_data:
                                    # New format with mode information
                                    theme_info = theme_data["theme_info"]
                                    theme_colors = theme_data["theme_data"]
                                    theme_name = theme_info["name"]
                                    theme_mode = theme_info.get("mode", "regular")
                                    
                                    # Check if theme_colors contains multiple modes or a single mode
                                    if isinstance(theme_colors, dict) and all(key in ['regular', 'strong', 'subdued', 'dark'] for key in theme_colors.keys()):
                                        # Multi-mode theme file - load each mode separately
                                        for mode_name, mode_colors in theme_colors.items():
                                            if self.validate_theme_colors(mode_colors):
                                                if mode_name == "subdued" and hasattr(self, 'SUBDUED_COLOR_THEMES'):
                                                    self.SUBDUED_COLOR_THEMES[theme_name] = mode_colors
                                                elif mode_name == "strong" and hasattr(self, 'STRONG_COLOR_THEMES'):
                                                    self.STRONG_COLOR_THEMES[theme_name] = mode_colors
                                                elif mode_name == "dark" and hasattr(self, 'DARK_COLOR_THEMES'):
                                                    self.DARK_COLOR_THEMES[theme_name] = mode_colors
                                                elif mode_name == "regular":
                                                    self.COLOR_THEMES[theme_name] = mode_colors
                                    elif self.validate_theme_colors(theme_colors):
                                        # Single-mode theme file - use specified mode
                                        if theme_mode == "subdued" and hasattr(self, 'SUBDUED_COLOR_THEMES'):
                                            self.SUBDUED_COLOR_THEMES[theme_name] = theme_colors
                                        elif theme_mode == "strong" and hasattr(self, 'STRONG_COLOR_THEMES'):
                                            self.STRONG_COLOR_THEMES[theme_name] = theme_colors
                                        elif theme_mode == "dark" and hasattr(self, 'DARK_COLOR_THEMES'):
                                            self.DARK_COLOR_THEMES[theme_name] = theme_colors
                                        else:
                                            # Default to regular themes
                                            self.COLOR_THEMES[theme_name] = theme_colors
                                else:
                                    # Legacy format - load into regular themes
                                    for theme_name, theme_colors in theme_data.items():
                                        if isinstance(theme_colors, dict) and self.validate_theme_colors(theme_colors):
                                            # Add to regular themes
                                            self.COLOR_THEMES[theme_name] = theme_colors
                                            
                                            # Auto-generate dark variant
                                            if hasattr(self, 'DARK_COLOR_THEMES'):
                                                dark_variant = self.generate_dark_variant(theme_colors)
                                                self.DARK_COLOR_THEMES[theme_name] = dark_variant
                                        
                        except Exception as e:
                            if getattr(sys, 'frozen', False):
                                print(f"[THEME-DEBUG] Error loading {filename}: {e}")
                            continue
                
                # Provide feedback about loaded themes
                if getattr(sys, 'frozen', False):
                    total_themes = len(self.COLOR_THEMES) + len(self.STRONG_COLOR_THEMES) + len(self.SUBDUED_COLOR_THEMES) + len(self.DARK_COLOR_THEMES)
                    print(f"[THEME-DEBUG] Successfully loaded {total_themes} theme instances across all modes")
                    if len(self.COLOR_THEMES) > 1:  # More than just Default Light
                        print(f"[THEME-DEBUG] Regular themes: {list(self.COLOR_THEMES.keys())}")
            else:
                if getattr(sys, 'frozen', False):
                    print(f"[THEME-DEBUG] Themes directory does not exist: {themes_dir}")
                        
        except Exception as e:
            print(f"Error loading theme files: {e}")
            if getattr(sys, 'frozen', False):
                print(f"[THEME-DEBUG] Full error details: {e}")
                self.debug_theme_paths()  # Show debug info on error        # Populate all theme modes to ensure every theme is available in all modes
        self.populate_all_theme_modes()
            
        # Refresh theme menu after loading themes to ensure they appear in correct categories
        if hasattr(self, 'theme_menu'):
            self.refresh_theme_menu()

    def load_theme_file(self, theme_file_path):
        """Load and apply a theme from a .gsfmt file when clicked in file manager."""
        try:
            import json
            import os
            print(f"[DEBUG] load_theme_file called with: {theme_file_path}")
            if not os.path.exists(theme_file_path):
                print(f"[DEBUG] Theme file not found: {theme_file_path}")
                self.show_error_message("Theme Error", "Theme file not found", f"Cannot find {theme_file_path}")
                return
            with open(theme_file_path, 'r', encoding='utf-8') as f:
                theme_data = json.load(f)
            print(f"[DEBUG] Theme data loaded: {type(theme_data)} keys: {list(theme_data.keys()) if isinstance(theme_data, dict) else 'not a dict'}")
            # Handle new format with mode information
            if isinstance(theme_data, dict):
                if "theme_info" in theme_data and "theme_data" in theme_data:
                    # New format with mode information
                    theme_info = theme_data["theme_info"]
                    theme_colors = theme_data["theme_data"]
                    theme_name = theme_info["name"]
                    theme_mode = theme_info.get("mode", "regular")
                    print(f"[DEBUG] theme_name: {theme_name}, theme_mode: {theme_mode}")
                    # Check if theme_colors contains multiple modes or a single mode
                    if isinstance(theme_colors, dict) and any(key in ['regular', 'strong', 'subdued', 'dark'] for key in theme_colors.keys()):
                        print(f"[DEBUG] Multi-mode theme detected. Modes: {list(theme_colors.keys())}")
                        # Always force strong mode if present
                        strong_colors = theme_colors.get('strong')
                        regular_colors = theme_colors.get('regular')
                        fallback_colors = None
                        for mode_name, mode_colors in theme_colors.items():
                            print(f"[DEBUG] Checking mode: {mode_name}")
                            if self.validate_theme_colors(mode_colors):
                                print(f"[DEBUG] Valid mode: {mode_name}")
                                if mode_name == "subdued" and hasattr(self, 'SUBDUED_COLOR_THEMES'):
                                    self.SUBDUED_COLOR_THEMES[theme_name] = mode_colors
                                elif mode_name == "strong" and hasattr(self, 'STRONG_COLOR_THEMES'):
                                    self.STRONG_COLOR_THEMES[theme_name] = mode_colors
                                elif mode_name == "dark" and hasattr(self, 'DARK_COLOR_THEMES'):
                                    self.DARK_COLOR_THEMES[theme_name] = mode_colors
                                elif mode_name == "regular":
                                    self.COLOR_THEMES[theme_name] = mode_colors
                                if fallback_colors is None:
                                    fallback_colors = mode_colors
                        # Force strong mode if present, else regular, else fallback
                        to_apply = strong_colors or regular_colors or fallback_colors
                        print(f"[DEBUG] Mode to apply: {'strong' if strong_colors else 'regular' if regular_colors else 'other'}")
                        if to_apply:
                            print(f"[DEBUG] Applying theme dict for mode: {to_apply}")
                            self.apply_theme_dict(to_apply)
                            self.color_theme = theme_name
                            self.refresh_theme_menu()
                            self.show_status_message(f"Applied theme: {theme_name} (mode: {'strong' if strong_colors else 'regular' if regular_colors else 'other'})")
                            return
                            
                    elif self.validate_theme_colors(theme_colors):
                        # Single-mode theme file - load and apply as specified
                        if theme_mode == "subdued" and hasattr(self, 'SUBDUED_COLOR_THEMES'):
                            self.SUBDUED_COLOR_THEMES[theme_name] = theme_colors
                            self.subdued_mode = True
                            self.strong_mode = False
                        elif theme_mode == "strong" and hasattr(self, 'STRONG_COLOR_THEMES'):
                            self.STRONG_COLOR_THEMES[theme_name] = theme_colors
                            self.strong_mode = True
                            self.subdued_mode = False
                        elif theme_mode == "dark" and hasattr(self, 'DARK_COLOR_THEMES'):
                            self.DARK_COLOR_THEMES[theme_name] = theme_colors
                            self.dark_mode = True
                        else:
                            # Default to regular themes
                            self.COLOR_THEMES[theme_name] = theme_colors
                            self.subdued_mode = False
                            self.strong_mode = False
                            
                        # Apply the theme immediately
                        self.set_color_theme(theme_name)
                        
                        # Populate all theme modes to ensure this new theme is available in all modes
                        self.populate_all_theme_modes()
                        
                        # Refresh the theme menu to show the new theme
                        self.refresh_theme_menu()
                        
                        # Show success message
                        self.show_info_message("Theme Loaded", f"Successfully loaded and applied theme '{theme_name}' ({theme_mode} mode)")
                        
                    else:
                        self.show_error_message("Theme Error", "Invalid theme file", "Theme file contains invalid color data")
                        
                else:
                    # Legacy format - load into regular themes
                    for theme_name, theme_colors in theme_data.items():
                        if isinstance(theme_colors, dict) and self.validate_theme_colors(theme_colors):
                            # Add to regular themes
                            self.COLOR_THEMES[theme_name] = theme_colors
                            self.subdued_mode = False
                            self.strong_mode = False
                            
                            # Apply the theme immediately
                            self.set_color_theme(theme_name)
                            
                            # Populate all theme modes to ensure this new theme is available in all modes
                            self.populate_all_theme_modes()
                            
                            # Refresh the theme menu
                            self.refresh_theme_menu()
                            
                            # Show success message
                            self.show_info_message("Theme Loaded", f"Successfully loaded and applied theme '{theme_name}' (regular mode)")
                            break
                        else:
                            self.show_error_message("Theme Error", "Invalid theme file", "Theme file contains invalid color data")
            else:
                self.show_error_message("Theme Error", "Invalid theme file format", "Theme file is not a valid JSON object")
                
        except json.JSONDecodeError:
            self.show_error_message("Theme Error", "Invalid JSON", "Theme file contains invalid JSON syntax")
        except Exception as e:
            self.show_error_message("Theme Error", "Error loading theme", str(e))

    def validate_theme_colors(self, theme_colors):
        """Validate that theme colors contain required keys and valid color values."""
        required_keys = ['window_bg', 'panel_bg', 'text', 'accent']
        
        # Check if all required keys are present
        if not all(key in theme_colors for key in required_keys):
            return False
            
        # Define which keys should be color values
        color_keys = ['window_bg', 'panel_bg', 'text', 'accent', 'border', 'header_bg', 
                     'selected_bg', 'hover_bg', 'button_bg', 'tab_bg', 'status_bg']
        
        # Validate color format only for color keys
        for key, value in theme_colors.items():
            if key in color_keys:
                if not isinstance(value, str) or not value.startswith('#') or len(value) not in [4, 7]:
                    return False
                
        return True

    def load_qss_file(self, qss_file_path):
        """Load and apply a QSS stylesheet file when clicked in file manager."""
        try:
            import os
            print(f"[DEBUG] load_qss_file called with: {qss_file_path}")
            
            if not os.path.exists(qss_file_path):
                print(f"[DEBUG] QSS file not found: {qss_file_path}")
                self.show_error_message("QSS Error", "QSS file not found", f"Cannot find {qss_file_path}")
                return
                
            # Read the QSS file
            with open(qss_file_path, 'r', encoding='utf-8') as f:
                qss_content = f.read()
                
            print(f"[DEBUG] QSS content loaded, length: {len(qss_content)} characters")
            
            # Apply the QSS stylesheet to the main application
            self.setStyleSheet(qss_content)
            
            # Update palette for themes that require it (like Dracula)
            self._update_palette_for_qss_theme(qss_file_path, qss_content)
            
            # Update existing dialogs with new theme
            self._update_child_dialogs_theme()
            
            # Save the QSS file path to settings for persistence
            try:
                settings = QSettings('garysfm', 'garysfm')
                settings.setValue('last_qss_file', qss_file_path)
                settings.setValue('qss_enabled', True)
                print(f"[DEBUG] Saved QSS file path to settings: {qss_file_path}")
            except Exception as e:
                print(f"[DEBUG] Failed to save QSS settings: {e}")
            
            # Get filename for success message
            filename = os.path.basename(qss_file_path)
            self.show_status_message(f"QSS stylesheet '{filename}' applied successfully.")
            
        except UnicodeDecodeError:
            self.show_error_message("QSS Error", "Encoding Error", "Could not read QSS file. Please ensure it's saved with UTF-8 encoding.")
        except Exception as e:
            self.show_error_message("QSS Error", "Error loading QSS", str(e))

    def _extract_theme_colors(self, qss_content):
        """Extract background, text, button, and accent colors from QSS content."""
        import re
        
        colors = {
            'background': '#ffffff',  # Default white
            'text': '#000000',        # Default black
            'button': '#f0f0f0',      # Default light gray
            'accent': '#0078d4',      # Default blue
            'border': '#cccccc',      # Default light gray border
            'hover': '#e1e1e1'       # Default hover
        }
        
        try:
            # Extract colors from various QSS patterns
            qss_lower = qss_content.lower()
            
            # Look for background-color patterns
            bg_patterns = [
                r'background-color\s*:\s*(#[0-9a-f]{6})',
                r'background\s*:\s*(#[0-9a-f]{6})',
                r'qwidget\s*\{[^}]*background-color\s*:\s*(#[0-9a-f]{6})',
                r'qmainwindow\s*\{[^}]*background-color\s*:\s*(#[0-9a-f]{6})'
            ]
            
            # Look for button color patterns
            button_patterns = [
                r'qpushbutton\s*\{[^}]*background-color\s*:\s*(#[0-9a-f]{6})',
                r'button[^}]*background-color\s*:\s*(#[0-9a-f]{6})'
            ]
            
            # Look for accent/highlight colors
            accent_patterns = [
                r'selection-background-color\s*:\s*(#[0-9a-f]{6})',
                r'highlight[^}]*background-color\s*:\s*(#[0-9a-f]{6})',
                r':hover[^}]*background-color\s*:\s*(#[0-9a-f]{6})'
            ]
            
            # Look for border colors
            border_patterns = [
                r'border-color\s*:\s*(#[0-9a-f]{6})',
                r'border\s*:\s*[^;]*\s(#[0-9a-f]{6})'
            ]
            
            # Extract background color
            for pattern in bg_patterns:
                match = re.search(pattern, qss_lower, re.IGNORECASE | re.DOTALL)
                if match:
                    colors['background'] = match.group(1).upper()
                    break
            
            # Extract text color - find all color properties and filter out selection colors
            text_color_found = False
            
            # Method 1: Look for specific widget color declarations (most reliable)
            widget_color_patterns = [
                r'qwidget\s*\{[^}]*?\bcolor\s*:\s*(#[0-9a-f]{6})',
                r'qmainwindow\s*\{[^}]*?\bcolor\s*:\s*(#[0-9a-f]{6})'
            ]
            
            for pattern in widget_color_patterns:
                # Find all matches for this pattern
                matches = re.findall(pattern, qss_lower, re.IGNORECASE | re.DOTALL)
                if matches:
                    # Take the first color that's not white (as white is often selection-color)
                    for color in matches:
                        if color.upper() not in ['#FFFFFF', '#FFFFFFFF']:
                            colors['text'] = color.upper()
                            text_color_found = True
                            break
                if text_color_found:
                    break
            
            # Method 2: If no specific widget color found, look for generic color declarations
            if not text_color_found:
                # Get all color declarations and filter out selection colors
                all_color_matches = re.findall(r'(?<!selection-)(?<!border-)color\s*:\s*(#[0-9a-f]{6})', qss_lower, re.IGNORECASE)
                if all_color_matches:
                    # Take the first non-white color
                    for color in all_color_matches:
                        if color.upper() not in ['#FFFFFF', '#FFFFFFFF']:
                            colors['text'] = color.upper()
                            break
            
            # Extract button color
            for pattern in button_patterns:
                match = re.search(pattern, qss_lower, re.IGNORECASE | re.DOTALL)
                if match:
                    colors['button'] = match.group(1).upper()
                    break
            
            # Extract accent color
            for pattern in accent_patterns:
                match = re.search(pattern, qss_lower, re.IGNORECASE | re.DOTALL)
                if match:
                    colors['accent'] = match.group(1).upper()
                    break
            
            # Extract border color
            for pattern in border_patterns:
                match = re.search(pattern, qss_lower, re.IGNORECASE | re.DOTALL)
                if match:
                    colors['border'] = match.group(1).upper()
                    break
            
            # If no button color found, use a slightly different shade of background
            if colors['button'] == '#f0f0f0':
                bg_color = colors['background']
                if bg_color.startswith('#'):
                    try:
                        # Convert to RGB and make slightly darker/lighter
                        r = int(bg_color[1:3], 16)
                        g = int(bg_color[3:5], 16) 
                        b = int(bg_color[5:7], 16)
                        
                        # If it's a light background, make button slightly darker
                        if r + g + b > 384:  # Light theme
                            r = max(0, r - 20)
                            g = max(0, g - 20)
                            b = max(0, b - 20)
                        else:  # Dark theme
                            r = min(255, r + 30)
                            g = min(255, g + 30)
                            b = min(255, b + 30)
                        
                        colors['button'] = f"#{r:02x}{g:02x}{b:02x}".upper()
                    except:
                        pass
            
            # Generate hover color (slightly lighter/darker than accent)
            if colors['accent'] != '#0078d4':
                try:
                    accent = colors['accent']
                    r = int(accent[1:3], 16)
                    g = int(accent[3:5], 16)
                    b = int(accent[5:7], 16)
                    
                    # Make hover color slightly different
                    r = min(255, r + 15) if r < 240 else max(0, r - 15)
                    g = min(255, g + 15) if g < 240 else max(0, g - 15)
                    b = min(255, b + 15) if b < 240 else max(0, b - 15)
                    
                    colors['hover'] = f"#{r:02x}{g:02x}{b:02x}".upper()
                except:
                    colors['hover'] = colors['accent']
            
            print(f"[DEBUG] Extracted theme colors: {colors}")
            return colors
            
        except Exception as e:
            print(f"[DEBUG] Error extracting theme colors: {e}")
            return colors

    def _generate_dialog_enhancement_css(self, theme_colors):
        """Generate dialog enhancement CSS using extracted theme colors."""
        return f"""
                        
/* Dialog enhancements for themes without QDialog rules - Dynamic theme colors */
QDialog {{
    background-color: {theme_colors['background']};
    color: {theme_colors['text']};
    border: 2px solid {theme_colors['border']};
    border-radius: 8px;
    padding: 4px;
}}

QDialog QPushButton {{
    background-color: {theme_colors['button']};
    color: {theme_colors['text']};
    border: 1px solid {theme_colors['border']};
    border-radius: 4px;
    min-width: 80px;
    padding: 6px 12px;
    font-weight: bold;
}}

QDialog QPushButton:hover {{
    background-color: {theme_colors['accent']};
    color: {theme_colors['background']};
    border: 1px solid {theme_colors['accent']};
}}

QDialog QPushButton:pressed {{
    background-color: {theme_colors['hover']};
    color: {theme_colors['background']};
    border: 1px solid {theme_colors['hover']};
}}

QDialog QGroupBox {{
    font-weight: bold;
    border: 2px solid {theme_colors['border']};
    border-radius: 6px;
    margin: 8px 0px;
    padding-top: 12px;
    background-color: {theme_colors['background']};
    color: {theme_colors['text']};
}}

QDialog QGroupBox::title {{
    subcontrol-origin: margin;
    subcontrol-position: top left;
    padding: 2px 8px;
    background-color: {theme_colors['accent']};
    color: {theme_colors['background']};
    border-radius: 3px;
    margin-left: 8px;
}}

QDialog QRadioButton {{
    color: {theme_colors['text']};
    spacing: 6px;
}}

QDialog QRadioButton::indicator {{
    width: 16px;
    height: 16px;
    border-radius: 8px;
    border: 2px solid {theme_colors['border']};
    background-color: {theme_colors['button']};
}}

QDialog QRadioButton::indicator:checked {{
    background-color: {theme_colors['accent']};
    border: 2px solid {theme_colors['accent']};
}}

QDialog QCheckBox {{
    color: {theme_colors['text']};
    spacing: 6px;
}}

QDialog QCheckBox::indicator {{
    width: 16px;
    height: 16px;
    border-radius: 3px;
    border: 2px solid {theme_colors['border']};
    background-color: {theme_colors['button']};
}}

QDialog QCheckBox::indicator:checked {{
    background-color: {theme_colors['accent']};
    border: 2px solid {theme_colors['accent']};
}}

QDialog QLineEdit {{
    background-color: {theme_colors['button']};
    color: {theme_colors['text']};
    border: 1px solid {theme_colors['border']};
    border-radius: 3px;
    padding: 4px;
}}

QDialog QLineEdit:focus {{
    border: 2px solid {theme_colors['accent']};
}}

QDialog QLabel {{
    color: {theme_colors['text']};
    background-color: transparent;
}}
"""

    def _update_palette_for_qss_theme(self, qss_file_path, qss_content):
        """Update the application palette for QSS themes that require it."""
        try:
            import os
            from PyQt5.QtGui import QPalette, QColor
            
            filename = os.path.basename(qss_file_path).lower()
            
            # Check if this is a Headache theme file
            if 'headache' in filename or '#cc0000' in qss_content:
                print(f"[DEBUG] Detected Headache theme, updating palette")
                
                # Create a custom Headache palette (white background, red highlights)
                headache_palette = QPalette()
                
                # Set Headache colors
                headache_palette.setColor(QPalette.Window, QColor("#ffffff"))         # Background (white)
                headache_palette.setColor(QPalette.WindowText, QColor("#cc0000"))     # Text (red)
                headache_palette.setColor(QPalette.Base, QColor("#ffffff"))           # Input background
                headache_palette.setColor(QPalette.AlternateBase, QColor("#f5f5f5"))  # Alternate rows
                headache_palette.setColor(QPalette.ToolTipBase, QColor("#ffffff"))    # Tooltip background
                headache_palette.setColor(QPalette.ToolTipText, QColor("#cc0000"))    # Tooltip text
                headache_palette.setColor(QPalette.Text, QColor("#cc0000"))           # Input text
                headache_palette.setColor(QPalette.Button, QColor("#ffffff"))         # Button background
                headache_palette.setColor(QPalette.ButtonText, QColor("#cc0000"))     # Button text
                headache_palette.setColor(QPalette.BrightText, QColor("#990000"))     # Error/warning text
                headache_palette.setColor(QPalette.Link, QColor("#cc0000"))           # Links
                headache_palette.setColor(QPalette.Highlight, QColor("#cc0000"))      # Selection
                headache_palette.setColor(QPalette.HighlightedText, QColor("#ffffff")) # Selected text
                
                # Apply the Headache palette
                self.setPalette(headache_palette)
                print(f"[DEBUG] Applied Headache palette to main window")
                
            # Check if this is a Dracula theme file
            elif 'dracula' in filename or '#282a36' in qss_content:
                print(f"[DEBUG] Detected Dracula theme, updating palette")
                
                # Create a custom Dracula palette
                dracula_palette = QPalette()
                
                # Set Dracula colors
                dracula_palette.setColor(QPalette.Window, QColor("#282a36"))         # Background
                dracula_palette.setColor(QPalette.WindowText, QColor("#f8f8f2"))     # Text
                dracula_palette.setColor(QPalette.Base, QColor("#282a36"))           # Input background
                dracula_palette.setColor(QPalette.AlternateBase, QColor("#44475a"))  # Alternate rows
                dracula_palette.setColor(QPalette.ToolTipBase, QColor("#282a36"))    # Tooltip background
                dracula_palette.setColor(QPalette.ToolTipText, QColor("#f8f8f2"))    # Tooltip text
                dracula_palette.setColor(QPalette.Text, QColor("#f8f8f2"))           # Input text
                dracula_palette.setColor(QPalette.Button, QColor("#44475a"))         # Button background
                dracula_palette.setColor(QPalette.ButtonText, QColor("#f8f8f2"))     # Button text
                dracula_palette.setColor(QPalette.BrightText, QColor("#ff5555"))     # Error/warning text
                dracula_palette.setColor(QPalette.Link, QColor("#8be9fd"))           # Links
                dracula_palette.setColor(QPalette.Highlight, QColor("#bd93f9"))      # Selection
                dracula_palette.setColor(QPalette.HighlightedText, QColor("#282a36")) # Selected text
                
                # Apply the Dracula palette
                self.setPalette(dracula_palette)
                print(f"[DEBUG] Applied Dracula palette to main window")
                
            elif 'dark' in filename or 'night' in filename or 'black' in filename:
                print(f"[DEBUG] Detected dark theme, applying generic dark palette")
                
                # Create a generic dark palette for other dark themes
                dark_palette = QPalette()
                dark_palette.setColor(QPalette.Window, QColor("#2b2b2b"))
                dark_palette.setColor(QPalette.WindowText, QColor("#ffffff"))
                dark_palette.setColor(QPalette.Base, QColor("#2b2b2b"))
                dark_palette.setColor(QPalette.AlternateBase, QColor("#404040"))
                dark_palette.setColor(QPalette.ToolTipBase, QColor("#2b2b2b"))
                dark_palette.setColor(QPalette.ToolTipText, QColor("#ffffff"))
                dark_palette.setColor(QPalette.Text, QColor("#ffffff"))
                dark_palette.setColor(QPalette.Button, QColor("#404040"))
                dark_palette.setColor(QPalette.ButtonText, QColor("#ffffff"))
                dark_palette.setColor(QPalette.BrightText, QColor("#ff4444"))
                dark_palette.setColor(QPalette.Link, QColor("#4da6ff"))
                dark_palette.setColor(QPalette.Highlight, QColor("#6666cc"))
                dark_palette.setColor(QPalette.HighlightedText, QColor("#ffffff"))
                
                self.setPalette(dark_palette)
                print(f"[DEBUG] Applied generic dark palette to main window")
                
            else:
                print(f"[DEBUG] Light/default theme detected, using system palette")
                # For light themes, reset to system default palette
                self.setPalette(QPalette())
                
        except Exception as e:
            print(f"[DEBUG] Error updating palette for QSS theme: {e}")

    def _update_child_dialogs_theme(self):
        """Update existing child dialogs to use the new theme."""
        try:
            from PyQt5.QtWidgets import QApplication
            
            # Find all ConflictResolutionDialog and MergeFileConflictDialog instances
            dialogs_updated = 0
            
            # Get all top-level widgets (including dialogs)
            for widget in QApplication.allWidgets():
                # Check if it's one of our dialog types
                if (widget.__class__.__name__ in ['ConflictResolutionDialog', 'MergeFileConflictDialog'] 
                    and hasattr(widget, '_apply_dialog_styling')):
                    
                    print(f"[DEBUG] Updating theme for {widget.__class__.__name__}")
                    
                    # Re-apply dialog styling with current theme
                    try:
                        widget._apply_dialog_styling()
                        dialogs_updated += 1
                    except Exception as e:
                        print(f"[DEBUG] Error updating dialog theme: {e}")
            
            if dialogs_updated > 0:
                print(f"[DEBUG] Updated theme for {dialogs_updated} existing dialogs")
            else:
                print(f"[DEBUG] No existing dialogs found to update")
                
        except Exception as e:
            print(f"[DEBUG] Error updating child dialogs theme: {e}")

    def load_saved_qss_on_startup(self):
        """Load the previously saved QSS file on application startup if QSS is enabled."""
        try:
            import os
            settings = QSettings('garysfm', 'garysfm')
            qss_enabled = settings.value('qss_enabled', False)
            last_qss_file = settings.value('last_qss_file', None)
            
            if GLOBAL_DEBUG_ENABLED:
                print(f"[DEBUG] QSS startup check - enabled: {qss_enabled}, last file: {last_qss_file}")
            
            # Only load QSS if it was enabled and we have a saved file path
            if qss_enabled and last_qss_file:
                # Convert to boolean properly
                qss_enabled_bool = str(qss_enabled).lower() in ('1', 'true', 'yes')
                if qss_enabled_bool and os.path.exists(last_qss_file):
                    if GLOBAL_DEBUG_ENABLED:
                        print(f"[DEBUG] Loading saved QSS file on startup: {last_qss_file}")
                    
                    # Read and apply the QSS file silently (no popup messages)
                    with open(last_qss_file, 'r', encoding='utf-8') as f:
                        qss_content = f.read()
                    
                    self.setStyleSheet(qss_content)
                    
                    # Update palette for themes that require it (like Dracula)
                    self._update_palette_for_qss_theme(last_qss_file, qss_content)
                    
                    # Show status message only
                    filename = os.path.basename(last_qss_file)
                    self.show_status_message(f"Restored QSS stylesheet '{filename}' from previous session.")
                    if GLOBAL_DEBUG_ENABLED:
                        print(f"[DEBUG] Successfully restored QSS stylesheet: {filename}")
                    
                elif qss_enabled_bool and not os.path.exists(last_qss_file):
                    if GLOBAL_DEBUG_ENABLED:
                        print(f"[DEBUG] Saved QSS file no longer exists: {last_qss_file}")
                    # Clear the invalid saved path
                    settings.setValue('qss_enabled', False)
                    settings.setValue('last_qss_file', '')
                    
        except Exception as e:
            if GLOBAL_DEBUG_ENABLED:
                print(f"[DEBUG] Error loading saved QSS on startup: {e}")

    def clear_qss_stylesheet(self):
        """Clear the current QSS stylesheet and disable QSS persistence."""
        try:
            # Clear the stylesheet
            self.setStyleSheet("")
            
            # Clear the saved QSS settings
            settings = QSettings('garysfm', 'garysfm')
            settings.setValue('qss_enabled', False)
            settings.setValue('last_qss_file', '')
            
            # Show status message
            self.show_status_message("QSS stylesheet cleared and reset to default theme.")
            print("[DEBUG] QSS stylesheet cleared and settings reset")
            
        except Exception as e:
            print(f"[DEBUG] Error clearing QSS stylesheet: {e}")

    def load_qss_files_from_folder(self):
        """Load all QSS files from the qss folder and populate menu."""
        import os
        qss_folder = self.get_qss_directory()
        
        if not os.path.exists(qss_folder):
            print(f"[DEBUG] QSS folder not found: {qss_folder}")
            return []
            
        qss_files = []
        try:
            for filename in os.listdir(qss_folder):
                if filename.lower().endswith('.qss'):
                    qss_path = os.path.join(qss_folder, filename)
                    qss_files.append({
                        'name': os.path.splitext(filename)[0],
                        'path': qss_path,
                        'filename': filename
                    })
                    print(f"[DEBUG] Found QSS file: {filename}")
        except Exception as e:
            print(f"[DEBUG] Error scanning QSS folder: {e}")
            
        return qss_files

    def extract_qss_colors(self, qss_file_path):
        """Extract representative colors from a QSS file for swatch creation."""
        try:
            import re
            with open(qss_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Extract hex colors using regex
            color_pattern = r'#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
            colors = re.findall(color_pattern, content)
            
            if not colors:
                return {'accent': '#888888', 'window_bg': '#ffffff'}
            
            # Convert to full 6-digit format
            full_colors = []
            for color in colors:
                if len(color) == 3:
                    # Convert #abc to #aabbcc
                    full_colors.append('#' + ''.join([c*2 for c in color]))
                else:
                    full_colors.append('#' + color)
            
            # Find most common colors for different purposes
            color_counts = {}
            for color in full_colors:
                color_counts[color] = color_counts.get(color, 0) + 1
            
            # Sort by frequency
            sorted_colors = sorted(color_counts.items(), key=lambda x: x[1], reverse=True)
            
            # Try to identify background and accent colors
            window_bg = '#ffffff'  # default
            accent = '#888888'     # default
            
            if sorted_colors:
                # First, look for selection/accent colors (often green, blue, etc.)
                accent_keywords = ['selection', 'hover', 'focus', 'accent', 'highlight']
                accent_colors = []
                
                for keyword in accent_keywords:
                    pattern = rf'{keyword}[^:]*:\s*[^;]*?#([a-fA-F0-9]{{6}}|[a-fA-F0-9]{{3}})'
                    matches = re.findall(pattern, content, re.IGNORECASE)
                    for match in matches:
                        if len(match) == 3:
                            accent_colors.append('#' + ''.join([c*2 for c in match]))
                        else:
                            accent_colors.append('#' + match)
                
                if accent_colors:
                    accent = accent_colors[0]
                else:
                    # Fallback: use a less common color (likely accent)
                    if len(sorted_colors) > 1:
                        accent = sorted_colors[1][0]
                    else:
                        accent = sorted_colors[0][0]
                
                # Look for background colors
                bg_keywords = ['background-color', 'background:']
                bg_colors = []
                
                for keyword in bg_keywords:
                    pattern = rf'{keyword}[^:]*:\s*[^;]*?#([a-fA-F0-9]{{6}}|[a-fA-F0-9]{{3}})'
                    matches = re.findall(pattern, content, re.IGNORECASE)
                    for match in matches:
                        if len(match) == 3:
                            bg_colors.append('#' + ''.join([c*2 for c in match]))
                        else:
                            bg_colors.append('#' + match)
                
                if bg_colors:
                    window_bg = bg_colors[0]
                else:
                    # Use most common color as background
                    window_bg = sorted_colors[0][0]
            
            return {'accent': accent, 'window_bg': window_bg}
            
        except Exception:
            # Return defaults on any error
            return {'accent': '#888888', 'window_bg': '#ffffff'}

    def setup_qss_menu(self, qss_menu):
        """Set up the QSS stylesheets submenu."""
        # Clear existing actions
        qss_menu.clear()
        
        # Add "Default Theme" action
        reset_action = QAction('Default Theme', self)
        reset_action.triggered.connect(self.clear_qss_stylesheet)
        qss_menu.addAction(reset_action)
        
        qss_menu.addSeparator()
        
        # Load available QSS files
        qss_files = self.load_qss_files_from_folder()
        
        if not qss_files:
            no_files_action = QAction('No QSS files found', self)
            no_files_action.setEnabled(False)
            qss_menu.addAction(no_files_action)
            return
            
        # Add actions for each QSS file with color swatches
        for qss_file in qss_files:
            action = QAction(qss_file['name'], self)
            action.setToolTip(f"Apply QSS stylesheet: {qss_file['filename']}")
            
            # Extract colors and create swatch
            try:
                qss_colors = self.extract_qss_colors(qss_file['path'])
                swatch_icon = self.create_theme_swatch(qss_colors, 'regular')
                action.setIcon(swatch_icon)
            except Exception:
                # Continue without icon if swatch creation fails
                pass
            
            # Create a lambda that captures the path
            def make_qss_handler(qss_path):
                return lambda: self.load_qss_file(qss_path)
            
            action.triggered.connect(make_qss_handler(qss_file['path']))
            qss_menu.addAction(action)

    def generate_dark_variant(self, theme_colors):
        """Generate a dark variant of a theme."""
        dark_variant = {}
        
        try:
            from PyQt5.QtGui import QColor
            
            for key, color in theme_colors.items():
                if key in ['window_bg', 'panel_bg']:
                    # Darken backgrounds significantly
                    qc = QColor(color)
                    h, s, l, a = qc.getHsl()
                    qc.setHsl(h, s, max(20, l - 180), a)
                    dark_variant[key] = qc.name()
                elif key == 'text':
                    # Light text for dark mode
                    dark_variant[key] = '#ffffff'
                elif key in ['accent']:
                    # Keep accent similar but maybe brighter
                    qc = QColor(color)
                    h, s, l, a = qc.getHsl()
                    qc.setHsl(h, s, min(255, l + 50), a)
                    dark_variant[key] = qc.name()
                else:
                    # Copy non-color properties as-is, ensuring proper types
                    if key in ['border_width', 'border_radius', 'padding', 'margin', 'font_size', 'shadow_blur', 'shadow_offset', 'opacity']:
                        dark_variant[key] = int(color) if isinstance(color, (str, float)) else color
                    elif key in ['border_style', 'font_weight', 'font_family']:
                        dark_variant[key] = str(color)
                    elif key in ['shadow_enabled']:
                        dark_variant[key] = bool(color)
                    else:
                        dark_variant[key] = color
                    
        except Exception:
            # Fallback dark variant
            dark_variant = {
                'window_bg': '#2b2b2b',
                'panel_bg': '#363636', 
                'text': '#ffffff',
                'accent': theme_colors.get('accent', '#3daee9')
            }
            # Copy other properties with proper types
            for key, value in theme_colors.items():
                if key not in ['window_bg', 'panel_bg', 'text', 'accent']:
                    if key in ['border_width', 'border_radius', 'padding', 'margin', 'font_size', 'shadow_blur', 'shadow_offset', 'opacity']:
                        dark_variant[key] = int(value) if isinstance(value, (str, float)) else value
                    elif key in ['border_style', 'font_weight', 'font_family']:
                        dark_variant[key] = str(value)
                    elif key in ['shadow_enabled']:
                        dark_variant[key] = bool(value)
                    else:
                        dark_variant[key] = value
            
        return dark_variant

    def generate_subdued_variant(self, theme_colors):
        """Generate a subdued variant of a theme."""
        subdued_variant = {}
        
        try:
            from PyQt5.QtGui import QColor
            
            for key, color in theme_colors.items():
                if key in ['window_bg', 'panel_bg', 'text', 'accent']:
                    qc = QColor(color)
                    h, s, l, a = qc.getHsl()
                    
                    if key in ['window_bg', 'panel_bg']:
                        # Keep backgrounds similar but slightly muted
                        qc.setHsl(h, max(0, s - 20), l, a)
                        subdued_variant[key] = qc.name()
                    elif key == 'accent':
                        # Reduce saturation and brightness for subdued accent
                        qc.setHsl(h, max(0, s - 40), max(0, l - 30), a)
                        subdued_variant[key] = qc.name()
                    else:
                        # Reduce saturation for other elements
                        qc.setHsl(h, max(0, s - 25), l, a)
                        subdued_variant[key] = qc.name()
                else:
                    # Copy non-color properties as-is, ensuring proper types
                    if key in ['border_width', 'border_radius', 'padding', 'margin', 'font_size', 'shadow_blur', 'shadow_offset', 'opacity']:
                        subdued_variant[key] = int(color) if isinstance(color, (str, float)) else color
                    elif key in ['border_style', 'font_weight', 'font_family']:
                        subdued_variant[key] = str(color)
                    elif key in ['shadow_enabled']:
                        subdued_variant[key] = bool(color)
                    else:
                        subdued_variant[key] = color
                    
        except Exception:
            # Fallback to original with slight modifications
            subdued_variant = theme_colors.copy()
            
        return subdued_variant

    def generate_strong_variant(self, theme_colors):
        """Generate a strong variant of a theme."""
        strong_variant = {}
        
        try:
            from PyQt5.QtGui import QColor
            
            for key, color in theme_colors.items():
                if key in ['window_bg', 'panel_bg', 'text', 'accent']:
                    qc = QColor(color)
                    h, s, l, a = qc.getHsl()
                    
                    if key in ['window_bg', 'panel_bg']:
                        # Keep backgrounds but slightly more saturated
                        qc.setHsl(h, min(255, s + 10), l, a)
                        strong_variant[key] = qc.name()
                    elif key == 'accent':
                        # Increase saturation and brightness for strong accent
                        qc.setHsl(h, min(255, s + 60), min(255, l + 20), a)
                        strong_variant[key] = qc.name()
                    else:
                        # Increase saturation for other elements
                        qc.setHsl(h, min(255, s + 30), l, a)
                        strong_variant[key] = qc.name()
                else:
                    # Copy non-color properties as-is, ensuring proper types
                    if key in ['border_width', 'border_radius', 'padding', 'margin', 'font_size', 'shadow_blur', 'shadow_offset', 'opacity']:
                        strong_variant[key] = int(color) if isinstance(color, (str, float)) else color
                    elif key in ['border_style', 'font_weight', 'font_family']:
                        strong_variant[key] = str(color)
                    elif key in ['shadow_enabled']:
                        strong_variant[key] = bool(color)
                    else:
                        strong_variant[key] = color
                    
        except Exception:
            # Fallback to original with slight modifications
            strong_variant = theme_colors.copy()
            
        return strong_variant

    def populate_all_theme_modes(self):
        """Ensure all themes are available in all modes by generating variants."""
        try:
            # Get list of valid themes from .gsfmt files
            themes_dir = self.get_themes_directory()
            valid_theme_names = {'Default Light'}  # Always include built-in
            
            if os.path.exists(themes_dir):
                for filename in os.listdir(themes_dir):
                    if filename.endswith('.gsfmt'):
                        try:
                            import json
                            theme_path = os.path.join(themes_dir, filename)
                            with open(theme_path, 'r', encoding='utf-8') as f:
                                theme_data = json.load(f)
                            
                            if isinstance(theme_data, dict):
                                if "theme_info" in theme_data and "theme_data" in theme_data:
                                    theme_name = theme_data["theme_info"]["name"]
                                    valid_theme_names.add(theme_name)
                                else:
                                    # Legacy format - add theme names
                                    for theme_name in theme_data.keys():
                                        if isinstance(theme_data[theme_name], dict):
                                            valid_theme_names.add(theme_name)
                        except Exception:
                            continue
            
            # Only populate modes for valid themes
            for theme_name in valid_theme_names:
                # Get the base theme (prefer regular, then any available)
                base_theme = None
                if theme_name in self.COLOR_THEMES:
                    base_theme = self.COLOR_THEMES[theme_name]
                elif hasattr(self, 'SUBDUED_COLOR_THEMES') and theme_name in self.SUBDUED_COLOR_THEMES:
                    base_theme = self.SUBDUED_COLOR_THEMES[theme_name]
                elif hasattr(self, 'STRONG_COLOR_THEMES') and theme_name in self.STRONG_COLOR_THEMES:
                    base_theme = self.STRONG_COLOR_THEMES[theme_name]
                elif hasattr(self, 'DARK_COLOR_THEMES') and theme_name in self.DARK_COLOR_THEMES:
                    base_theme = self.DARK_COLOR_THEMES[theme_name]
                
                if base_theme:
                    # Ensure theme exists in regular COLOR_THEMES
                    if theme_name not in self.COLOR_THEMES:
                        self.COLOR_THEMES[theme_name] = base_theme
                    
                    # Ensure theme exists in SUBDUED_COLOR_THEMES
                    if hasattr(self, 'SUBDUED_COLOR_THEMES') and theme_name not in self.SUBDUED_COLOR_THEMES:
                        self.SUBDUED_COLOR_THEMES[theme_name] = self.generate_subdued_variant(base_theme)
                    
                    # Ensure theme exists in STRONG_COLOR_THEMES
                    if hasattr(self, 'STRONG_COLOR_THEMES') and theme_name not in self.STRONG_COLOR_THEMES:
                        self.STRONG_COLOR_THEMES[theme_name] = self.generate_strong_variant(base_theme)
                    
                    # Ensure theme exists in DARK_COLOR_THEMES
                    if hasattr(self, 'DARK_COLOR_THEMES') and theme_name not in self.DARK_COLOR_THEMES:
                        self.DARK_COLOR_THEMES[theme_name] = self.generate_dark_variant(base_theme)
                        
        except Exception as e:
            print(f"Error populating theme modes: {e}")

    def save_theme_to_file_with_mode(self, theme_name, theme_colors, mode):
        """Save a theme to a .gsfmt file with specific mode information."""
        try:
            import os
            import json
            
            # Get the themes directory
            themes_dir = self.get_themes_directory()
            
            # Create a safe filename from theme name
            safe_name = "".join(c for c in theme_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
            safe_name = safe_name.replace(' ', '_').lower()
            filename = f"{safe_name}.gsfmt"
            theme_path = os.path.join(themes_dir, filename)
            
            # Create theme file content with specific mode information
            theme_file_data = {
                "theme_info": {
                    "name": theme_name,
                    "mode": mode,
                    "version": "1.3.0"
                },
                "theme_data": theme_colors
            }
            
            with open(theme_path, 'w', encoding='utf-8') as f:
                json.dump(theme_file_data, f, indent=2)
                
            return True
        except Exception as e:
            print(f"Error saving theme to file: {e}")
            return False

    def save_theme_to_file(self, theme_name, theme_colors):
        """Save a theme to a .gsfmt file with mode information."""
        try:
            import os
            import json
            
            # Get the themes directory
            themes_dir = self.get_themes_directory()
            
            # Create a safe filename from theme name
            safe_name = "".join(c for c in theme_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
            safe_name = safe_name.replace(' ', '_').lower()
            filename = f"{safe_name}.gsfmt"
            theme_path = os.path.join(themes_dir, filename)
            
            # Determine which mode this theme belongs to
            theme_mode = "regular"  # default
            if hasattr(self, 'SUBDUED_COLOR_THEMES') and theme_name in self.SUBDUED_COLOR_THEMES:
                theme_mode = "subdued"
            elif hasattr(self, 'STRONG_COLOR_THEMES') and theme_name in self.STRONG_COLOR_THEMES:
                theme_mode = "strong"
            elif hasattr(self, 'DARK_COLOR_THEMES') and theme_name in self.DARK_COLOR_THEMES:
                theme_mode = "dark"
            
            # Create theme file content with mode information
            theme_file_data = {
                "theme_info": {
                    "name": theme_name,
                    "mode": theme_mode,
                    "version": "1.3.0"
                },
                "theme_data": theme_colors
            }
            
            with open(theme_path, 'w', encoding='utf-8') as f:
                json.dump(theme_file_data, f, indent=2)
                
            return True
        except Exception as e:
            print(f"Error saving theme to file: {e}")
            return False

    def setup_theme_file_watcher(self):
        """Set up file system watcher for .gsfmt files."""
        try:
            from PyQt5.QtCore import QFileSystemWatcher
            import os
            
            themes_dir = self.get_themes_directory()
            
            if hasattr(self, 'theme_watcher'):
                # Remove existing watcher
                del self.theme_watcher
                
            self.theme_watcher = QFileSystemWatcher()
            self.theme_watcher.addPath(themes_dir)
            self.theme_watcher.directoryChanged.connect(self.on_theme_directory_changed)
            
        except Exception as e:
            print(f"Could not set up theme file watcher: {e}")

    def on_theme_directory_changed(self):
        """Handle changes in the theme directory."""
        # Reload themes when directory changes
        old_themes = set(self.COLOR_THEMES.keys())
        self.load_theme_files()
        new_themes = set(self.COLOR_THEMES.keys())
        
        # If themes changed, refresh menu if it exists
        if old_themes != new_themes and hasattr(self, 'theme_menu'):
            self.refresh_theme_menu()

    def create_theme_swatch(self, theme, swatch_type='regular'):
        """Create a color swatch icon for a theme.
        
        Args:
            theme: Dictionary containing theme colors
            swatch_type: 'regular', 'strong', 'subdued', or 'dark'
        
        Returns:
            QIcon with the theme's color swatch
        """
        try:
            from PyQt5.QtGui import QPixmap, QPainter, QColor, QIcon, QPen, QBrush
            from PyQt5.QtCore import QRectF
            
            # Get colors from theme
            accent = theme.get('accent') or theme.get('panel_bg') or '#888888'
            window_bg = theme.get('window_bg', '#ffffff')
            
            # Create 16x16 swatch
            sw = QPixmap(16, 16)
            sw.fill(QColor(0, 0, 0, 0))  # Transparent background
            p = QPainter(sw)
            p.setRenderHint(QPainter.Antialiasing)
            
            if swatch_type == 'regular':
                # Simple rounded rectangle with accent color and smart border
                rect = QRectF(1.0, 1.0, 14.0, 14.0)
                fill_col = QColor(accent)
                
                # Smart border color based on luminance
                r, g, b, _ = fill_col.getRgb()
                lum = (0.2126 * (r / 255.0) + 0.7152 * (g / 255.0) + 0.0722 * (b / 255.0))
                if lum > 0.7:
                    border_col = QColor(0, 0, 0, 120)  # Light fill -> dark border
                elif lum < 0.3:
                    border_col = QColor(255, 255, 255, 130)  # Dark fill -> light border
                else:
                    border_col = fill_col.darker(115)  # Mid-tone -> darker border
                
                p.setBrush(QBrush(fill_col))
                p.setPen(QPen(border_col, 1.0))
                p.drawRoundedRect(rect, 3.0, 3.0)
                
            elif swatch_type == 'subdued':
                # Background with small accent rectangle for subdued look
                bg_rect = QRectF(0, 0, 16, 16)
                p.setBrush(QBrush(QColor(window_bg)))
                p.setPen(QPen(QColor(0, 0, 0, 0)))  # No border
                p.drawRoundedRect(bg_rect, 2, 2)
                
                # Small accent rectangle
                accent_rect = QRectF(3, 3, 10, 10)
                p.setBrush(QBrush(QColor(accent)))
                p.drawRoundedRect(accent_rect, 1, 1)
                
            elif swatch_type == 'strong':
                # Background with prominent accent rectangle for strong look
                bg_rect = QRectF(0, 0, 16, 16)
                p.setBrush(QBrush(QColor(window_bg)))
                p.setPen(QPen(QColor(0, 0, 0, 0)))  # No border
                p.drawRoundedRect(bg_rect, 3, 3)
                
                # Larger accent rectangle
                accent_rect = QRectF(2, 2, 12, 12)
                p.setBrush(QBrush(QColor(accent)))
                p.drawRoundedRect(accent_rect, 2, 2)
                
            elif swatch_type == 'dark':
                # Dark theme style with light accent on dark background
                bg_rect = QRectF(0, 0, 16, 16)
                dark_bg = QColor(window_bg).darker(200) if QColor(window_bg).lightness() > 128 else QColor(window_bg)
                p.setBrush(QBrush(dark_bg))
                p.setPen(QPen(QColor(255, 255, 255, 50), 1))
                p.drawRoundedRect(bg_rect, 2, 2)
                
                # Accent colored center
                accent_rect = QRectF(3, 3, 10, 10)
                p.setBrush(QBrush(QColor(accent)))
                p.setPen(QPen(QColor(0, 0, 0, 0)))
                p.drawRoundedRect(accent_rect, 1, 1)
            
            p.end()
            return QIcon(sw)
            
        except Exception:
            # Return empty icon on failure
            try:
                from PyQt5.QtGui import QIcon
                return QIcon()
            except Exception:
                return None

    def refresh_theme_menu(self):
        """Refresh the theme menu to include newly saved themes."""
        if not hasattr(self, '_theme_menu_added') or not hasattr(self, 'theme_menu'):
            return
            
        # Clear only theme-related actions and submenus, preserve QSS actions
        actions_to_remove = []
        for action in self.theme_menu.actions():
            # Remove only theme actions and theme-related submenus, keep QSS actions
            if (hasattr(action, '_is_theme_action') or 
                action.text() in ['Subdued Themes', 'Strong Themes', 'Standard Themes', 'Classic Themes'] or
                (action.menu() is not None and action.text() in ['Classic Themes'])):  # Remove only theme submenus
                actions_to_remove.append(action)
        
        for action in actions_to_remove:
            self.theme_menu.removeAction(action)
        
        # Rebuild theme actions
        self._theme_actions = {}
        
        # Add separator before Classic Themes (QSS items should already be at the top)
        sep1 = self.theme_menu.addSeparator()
        sep1._is_theme_action = True
        
        # Create Classic Themes submenu containing all theme variants
        classic_menu = self.theme_menu.addMenu('Classic Themes')
        classic_menu._is_theme_action = True
        
        # Add Theme Color Customization action to Classic Themes submenu
        theme_customize_action = QAction('Theme Color Customization...', self)
        theme_customize_action.triggered.connect(self.open_theme_color_customization)
        classic_menu.addAction(theme_customize_action)
        
        # Add Dark Mode toggle to Classic Themes submenu
        if not hasattr(self, '_dark_mode_action_added'):
            self.dark_mode_action = QAction("Dark Mode", self, checkable=True)
            self.dark_mode_action.triggered.connect(self.toggle_dark_mode)
            classic_menu.addAction(self.dark_mode_action)
            self._dark_mode_action_added = True
        
        # Add separator before theme variants
        classic_menu.addSeparator()
        
        # Create Standard Themes submenu within Classic Themes
        all_theme_names = sorted(self.COLOR_THEMES.keys())
        
        if all_theme_names:
            standard_menu = classic_menu.addMenu('Standard Themes')
            standard_menu._is_theme_action = True
            
            for name in all_theme_names:
                a = QAction(name, self, checkable=True)
                a._is_theme_action = True
                
                theme = self.COLOR_THEMES.get(name, {})
                
                # Create a swatch icon using the helper function
                swatch_icon = self.create_theme_swatch(theme, 'regular')
                if swatch_icon:
                    a.setIcon(swatch_icon)
                    
                # Create a proper closure for the theme name
                def make_standard_callback(theme_name):
                    def _set_standard_theme():
                        try:
                            # Clear mode flags when selecting standard themes
                            self.subdued_mode = False
                            self.strong_mode = False
                            try:
                                settings = QSettings('garysfm', 'garysfm')
                                settings.setValue('subdued_mode', False)
                                settings.setValue('strong_mode', False)
                                settings.setValue('color_theme', theme_name)
                            except Exception:
                                pass
                            self.set_color_theme(theme_name)
                            # Update checkmarks
                            for act_name, act in self._theme_actions.items():
                                act.setChecked(act_name == theme_name)
                        except Exception:
                            pass
                    return _set_standard_theme
                    
                a.triggered.connect(make_standard_callback(name))
                standard_menu.addAction(a)
                self._theme_actions[name] = a
        
        # Create subdued themes submenu within Classic Themes if themes exist
        subdued_names = sorted(self.SUBDUED_COLOR_THEMES.keys()) if hasattr(self, 'SUBDUED_COLOR_THEMES') else []
        if subdued_names:
            subdued_menu = classic_menu.addMenu('Subdued Themes')
            subdued_menu._is_theme_action = True
            for name in subdued_names:
                a = QAction(name, self, checkable=True)
                
                # Add swatch icon for subdued theme
                theme = self.SUBDUED_COLOR_THEMES.get(name, {})
                swatch_icon = self.create_theme_swatch(theme, 'subdued')
                if swatch_icon:
                    a.setIcon(swatch_icon)
                
                def make_subdued_callback(theme_name):
                    def _set_subdued_theme():
                        try:
                            self.subdued_mode = True
                            self.strong_mode = False  # Disable strong mode
                            try:
                                settings = QSettings('garysfm', 'garysfm')
                                settings.setValue('subdued_mode', True)
                                settings.setValue('strong_mode', False)
                                settings.setValue('color_theme', theme_name)
                            except Exception:
                                pass
                            self.set_color_theme(theme_name)
                            self.apply_theme()
                            self.refresh_all_themes()
                        except Exception:
                            pass
                    return _set_subdued_theme
                    
                a.triggered.connect(make_subdued_callback(name))
                subdued_menu.addAction(a)
                self._theme_actions[f"subdued_{name}"] = a
                
        # Create strong themes submenu within Classic Themes if themes exist
        strong_names = sorted(self.STRONG_COLOR_THEMES.keys()) if hasattr(self, 'STRONG_COLOR_THEMES') else []
        if strong_names:
            strong_menu = classic_menu.addMenu('Strong Themes')
            strong_menu._is_theme_action = True
            for name in strong_names:
                a = QAction(name, self, checkable=True)
                
                # Add swatch icon for strong theme
                theme = self.STRONG_COLOR_THEMES.get(name, {})
                swatch_icon = self.create_theme_swatch(theme, 'strong')
                if swatch_icon:
                    a.setIcon(swatch_icon)
                
                def make_strong_callback(theme_name):
                    def _set_strong_theme():
                        try:
                            self.strong_mode = True
                            self.subdued_mode = False  # Disable subdued mode
                            try:
                                settings = QSettings('garysfm', 'garysfm')
                                settings.setValue('strong_mode', True)
                                settings.setValue('subdued_mode', False)
                                settings.setValue('color_theme', theme_name)
                            except Exception:
                                pass
                            self.set_color_theme(theme_name)
                            self.apply_theme()
                            self.refresh_all_themes()
                        except Exception:
                            pass
                    return _set_strong_theme
                    
                a.triggered.connect(make_strong_callback(name))
                strong_menu.addAction(a)
                self._theme_actions[f"strong_{name}"] = a
        
        # Ensure currently selected theme is checked
        try:
            current_theme = getattr(self, 'color_theme', None)
            if current_theme:
                # Check appropriate action based on current mode
                if getattr(self, 'subdued_mode', False):
                    key = f"subdued_{current_theme}"
                elif getattr(self, 'strong_mode', False):
                    key = f"strong_{current_theme}"
                else:
                    key = current_theme
                    
                if key in self._theme_actions:
                    self._theme_actions[key].setChecked(True)
        except Exception:
            pass
            
    def set_color_theme(self, name):
        """Set a named color theme, persist it, and reapply UI styling."""
        try:
            # Check if theme exists in any of the theme dictionaries
            theme_exists = False
            if hasattr(self, 'COLOR_THEMES') and name in self.COLOR_THEMES:
                theme_exists = True
            elif hasattr(self, 'STRONG_COLOR_THEMES') and name in self.STRONG_COLOR_THEMES:
                theme_exists = True
            elif hasattr(self, 'SUBDUED_COLOR_THEMES') and name in self.SUBDUED_COLOR_THEMES:
                theme_exists = True
            elif hasattr(self, 'DARK_COLOR_THEMES') and name in self.DARK_COLOR_THEMES:
                theme_exists = True
                
            if not theme_exists:
                print(f"Warning: Theme '{name}' not found in any theme dictionary")
                return
                
            self.color_theme = name
            
            # Persist selection
            try:
                settings = QSettings('garysfm', 'garysfm')
                settings.setValue('color_theme', str(name))
            except Exception:
                pass
                
            # Save all theme settings immediately
            self.save_theme_settings()
            
            # Update theme menu checkmarks if present
            try:
                for n, act in getattr(self, '_theme_actions', {}).items():
                    try:
                        # Handle prefixed action names for strong/subdued themes
                        if n.startswith('strong_') or n.startswith('subdued_'):
                            theme_part = n.split('_', 1)[1]
                            act.setChecked(theme_part == name)
                        else:
                            act.setChecked(n == name)
                    except Exception:
                        pass
            except Exception:
                pass

            # Reapply theme and refresh UI
            try:
                self.apply_theme()
                self.refresh_all_themes()
            except Exception:
                pass
        except Exception as e:
            print(f"Error in set_color_theme: {e}")

    def refresh_all_themes(self):
        """Update all UI components with current theme"""
        # Update preview pane background
        if hasattr(self, 'preview_pane') and self.preview_pane:
            self.update_preview_pane_theme()
            
        # Update icon container background
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            icon_container = getattr(current_tab, 'icon_container', None) if hasattr(current_tab, 'get_icon_container_safely') else None
            if not icon_container and hasattr(current_tab, 'get_icon_container_safely'):
                icon_container = current_tab.get_icon_container_safely()
            
            if icon_container:
                self.update_icon_container_theme(icon_container)
            
        # Update tab manager theme
        if hasattr(self, 'tab_manager') and self.tab_manager:
            self.update_tab_manager_theme()
            
        # Update tree view theme
        if hasattr(self, 'tree_view') and self.tree_view:
            self.update_tree_view_theme()
            
    # Update breadcrumb theme (handled by breadcrumb widget itself)
        
    def update_tree_view_theme(self):
        """Update tree view colors for current theme"""
        if self.dark_mode:
            style = """
                QTreeView {
                    background-color: #3c3c3c;
                    color: #ffffff;
                    selection-background-color: #0078d4;
                    selection-color: #ffffff;
                    border: 1px solid #555;
                }
                QTreeView::item {
                    padding: 2px;
                }
                QTreeView::item:hover {
                    background-color: #4a4a4a;
                }
                QTreeView::item:selected {
                    background-color: #0078d4;
                }
                QHeaderView::section {
                    background-color: #404040;
                    color: #ffffff;
                    border: 1px solid #555;
                    padding: 4px;
                }
            """
        else:
            style = ""
        self.tree_view.setStyleSheet(style)
        
    def update_breadcrumb_theme(self):
        """Update breadcrumb colors for current theme"""
        if self.dark_mode:
            style = """
                QWidget {
                    background-color: #404040;
                    color: #ffffff;
                }
                QPushButton {
                    background-color: transparent;
                    color: #ffffff;
                    border: none;
                    padding: 4px 8px;
                    text-decoration: underline;
                }
                QPushButton:hover {
                    background-color: #4a4a4a;
                }
                QPushButton:pressed {
                    background-color: #0078d4;
                }
                QLabel {
                    color: #cccccc;
                }
            """
        else:
            style = ""
        self.breadcrumb.setStyleSheet(style)
        
    # Sorting Methods
    def set_sort_by(self, sort_by):
        """Set sort criteria for current tab"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            current_tab.sort_by = sort_by
            self.update_sort_menu_checkmarks()
            self.save_tab_sort_settings(current_tab)
            current_tab.refresh_current_view()

    def set_sort_order(self, sort_order):
        """Set sort order for current tab"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            current_tab.sort_order = sort_order
            self.update_sort_menu_checkmarks()
            self.save_tab_sort_settings(current_tab)
            current_tab.refresh_current_view()

    def toggle_directories_first(self):
        """Toggle directories first sorting for current tab"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            current_tab.directories_first = not current_tab.directories_first
            self.update_sort_menu_checkmarks()
            self.save_tab_sort_settings(current_tab)
            current_tab.refresh_current_view()

    def toggle_case_sensitive(self):
        """Toggle case sensitive sorting for current tab"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            current_tab.case_sensitive = not current_tab.case_sensitive
            self.update_sort_menu_checkmarks()
            self.save_tab_sort_settings(current_tab)
            current_tab.refresh_current_view()

    def toggle_group_by_type(self):
        """Toggle group by type sorting for current tab"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            current_tab.group_by_type = not current_tab.group_by_type
            self.update_sort_menu_checkmarks()
            self.save_tab_sort_settings(current_tab)
            current_tab.refresh_current_view()

    def toggle_natural_sort(self):
        """Toggle natural sort for current tab"""
        current_tab = self.tab_manager.get_current_tab()
        if current_tab:
            current_tab.natural_sort = not current_tab.natural_sort
            self.update_sort_menu_checkmarks()
            self.save_tab_sort_settings(current_tab)
            current_tab.refresh_current_view()

    def update_sort_menu_checkmarks(self):
        """Update sort menu checkmarks based on current tab settings"""
        current_tab = self.tab_manager.get_current_tab()
        if not current_tab:
            return
            
        # Sort by checkmarks
        self.sort_by_name_action.setChecked(current_tab.sort_by == "name")
        self.sort_by_size_action.setChecked(current_tab.sort_by == "size")
        self.sort_by_date_action.setChecked(current_tab.sort_by == "date")
        self.sort_by_type_action.setChecked(current_tab.sort_by == "type")
        self.sort_by_extension_action.setChecked(current_tab.sort_by == "extension")
        
        # Sort order checkmarks
        self.sort_ascending_action.setChecked(current_tab.sort_order == "ascending")
        self.sort_descending_action.setChecked(current_tab.sort_order == "descending")
        
        # Sort options checkmarks
        self.directories_first_action.setChecked(current_tab.directories_first)
        self.case_sensitive_action.setChecked(current_tab.case_sensitive)
        self.group_by_type_action.setChecked(current_tab.group_by_type)
        self.natural_sort_action.setChecked(current_tab.natural_sort)

    def save_all_tab_sort_settings(self):
        """Save sorting settings for all open tabs"""
        if hasattr(self, 'tab_manager') and self.tab_manager:
            for tab in self.tab_manager.tabs:
                if tab:
                    self.save_tab_sort_settings(tab)

    def migrate_tab_sort_settings(self):
        """Migrate old hash-based keys to new deterministic MD5 keys"""
        try:
            if not os.path.exists(self.SETTINGS_FILE):
                return
                
            with open(self.SETTINGS_FILE, "r") as f:
                settings = json.load(f)
                
            if "tab_sort_settings" not in settings:
                return
                
            old_settings = settings["tab_sort_settings"]
            migrated_count = 0
            
            # Create new settings with deterministic keys
            # Iterate over a static list to avoid mutating the dict during iteration
            for old_key, sort_data in list(old_settings.items()):
                if old_key.startswith("tab_sort_") and "path" in sort_data:
                    path = sort_data["path"]
                    new_key = self.get_tab_key(path)
                    
                    # If the new key doesn't exist, migrate the old one
                    if new_key not in settings.get("tab_sort_settings", {}):
                        settings["tab_sort_settings"][new_key] = sort_data.copy()
                        migrated_count += 1
            
            if migrated_count > 0:
                # Save the updated settings
                with open(self.SETTINGS_FILE, "w") as f:
                    json.dump(settings, f, indent=2)
                
        except Exception as e:
            print(f"Error migrating tab sort settings: {e}")

    def get_tab_key(self, folder_path):
        """Generate a deterministic key for tab sort settings"""
        # Normalize the path to be consistent across platforms and runs
        import hashlib
        normalized_path = os.path.normpath(folder_path).replace('\\', '/')
        # Use MD5 hash for deterministic results across Python runs  
        path_hash = hashlib.md5(normalized_path.encode('utf-8')).hexdigest()
        return f"tab_sort_{path_hash}"

    def save_tab_sort_settings(self, tab):
        """Save sorting settings for a specific tab"""
        if not tab:
            return
            
        if not hasattr(tab, 'current_folder') or not tab.current_folder:
            return
            
        # Create tab-specific settings key based on path
        tab_key = self.get_tab_key(tab.current_folder)
        
        # Get current settings
        settings = {}
        try:
            if os.path.exists(self.SETTINGS_FILE):
                with open(self.SETTINGS_FILE, "r") as f:
                    settings = json.load(f)
        except Exception as e:
            settings = {}
            
        # Add/update tab sort settings
        if "tab_sort_settings" not in settings:
            settings["tab_sort_settings"] = {}
            
        settings["tab_sort_settings"][tab_key] = {
            "sort_by": tab.sort_by,
            "sort_order": tab.sort_order,
            "directories_first": tab.directories_first,
            "case_sensitive": tab.case_sensitive,
            "group_by_type": tab.group_by_type,
            "natural_sort": tab.natural_sort,
            "path": tab.current_folder
        }
        
        # Save settings
        try:
            with open(self.SETTINGS_FILE, "w") as f:
                json.dump(settings, f, indent=2)
        except Exception as e:
            print(f"Error saving tab sort settings: {e}")

    def load_tab_sort_settings(self, tab):
        """Load sorting settings for a specific tab"""
        if not tab:
            return
            
        tab_key = self.get_tab_key(tab.current_folder)
        settings_loaded = False
        
        try:
            if os.path.exists(self.SETTINGS_FILE):
                with open(self.SETTINGS_FILE, "r") as f:
                    settings = json.load(f)
                    
                if "tab_sort_settings" in settings and tab_key in settings["tab_sort_settings"]:
                    sort_settings = settings["tab_sort_settings"][tab_key]
                    
                    tab.sort_by = sort_settings.get("sort_by", "name")
                    tab.sort_order = sort_settings.get("sort_order", "ascending")
                    tab.directories_first = sort_settings.get("directories_first", True)
                    tab.case_sensitive = sort_settings.get("case_sensitive", False)
                    tab.group_by_type = sort_settings.get("group_by_type", False)
                    tab.natural_sort = sort_settings.get("natural_sort", True)
                    
                    settings_loaded = True
                    
                    # Update menu checkmarks
                    self.update_sort_menu_checkmarks()
        except Exception as e:
            print(f"Error loading tab sort settings: {e}")
            
        # Refresh the view to apply the loaded settings
        if settings_loaded:
            # Only refresh if the view_stack exists (UI is set up)
            if hasattr(tab, 'view_stack'):
                tab.refresh_current_view()
        
    def update_preview_pane_theme(self):
        """Update preview pane colors for current theme"""
        if self.dark_mode:
            style = """
                QWidget {
                    background-color: #2b2b2b;
                    color: #ffffff;
                }
                QScrollArea {
                    background-color: #2b2b2b;
                    border: 1px solid #555;
                }
                QLabel {
                    background-color: transparent;
                    color: #ffffff;
                }
                QPlainTextEdit {
                    background-color: #3c3c3c;
                    color: #ffffff;
                    border: 1px solid #555;
                }
            """
        else:
            style = ""
        self.preview_pane.setStyleSheet(style)
        
    def update_tab_manager_theme(self):
        """Update tab manager theme for current mode"""
        if hasattr(self, 'tab_manager') and self.tab_manager:
            if self.dark_mode:
                tab_style = """
                    QTabWidget::pane {
                        background-color: #3c3c3c;
                        color: #ffffff;
                        border: 1px solid #555;
                    }
                    QTabBar {
                        background-color: #2b2b2b;
                    }
                    QTabBar::tab {
                        background-color: #404040;
                        color: #ffffff;
                        padding: 8px 16px;
                        margin-right: 2px;
                        margin-bottom: 2px;
                        border: 1px solid #555;
                        border-top-left-radius: 4px;
                        border-top-right-radius: 4px;
                        min-width: 80px;
                    }
                    QTabBar::tab:hover {
                        background-color: #4a4a4a;
                        color: #ffffff;
                    }
                    QTabBar::tab:selected {
                        background-color: #0078d4;
                        color: #ffffff;
                        border-bottom: none;
                        font-weight: bold;
                    }
                    QTabBar::close-button {
                        background-color: transparent;
                        border: none;
                        margin: 2px;
                    }
                    QTabBar::close-button:hover {
                        background-color: #ff4444;
                        border-radius: 2px;
                    }
                    QPushButton {
                        background-color: #404040;
                        color: #ffffff;
                        border: 1px solid #555;
                        border-radius: 3px;
                        padding: 4px 8px;
                    }
                    QPushButton:hover {
                        background-color: #4a4a4a;
                    }
                    QPushButton:pressed {
                        background-color: #0078d4;
                    }
                """
            else:
                # Light mode - use default styling
                tab_style = """
                    QTabBar::tab {
                        padding: 8px 16px;
                        margin-right: 2px;
                        min-width: 80px;
                    }
                """
            
            self.tab_manager.setStyleSheet(tab_style)
    
    def update_icon_container_theme(self, icon_container=None):
        """Update icon container background for current theme"""
        if not icon_container:
            # Fallback to getting current tab's icon container
            current_tab = self.tab_manager.get_current_tab()
            if current_tab:
                icon_container = getattr(current_tab, 'icon_container', None) if hasattr(current_tab, 'get_icon_container_safely') else None
                if not icon_container and hasattr(current_tab, 'get_icon_container_safely'):
                    icon_container = current_tab.get_icon_container_safely()
        
        if not icon_container:
            return  # No icon container to update
            
        if self.dark_mode:
            style = """
                QWidget {
                    background-color: #2b2b2b;
                }
                QScrollArea {
                    background-color: #2b2b2b;
                }
            """
        else:
            style = ""
        
        icon_container.setStyleSheet(style)
        # Also update the scroll area if we can access it through the current tab
        current_tab = self.tab_manager.get_current_tab()
        if current_tab and hasattr(current_tab, 'scroll_area'):
            current_tab.scroll_area.setStyleSheet(style)

    def toggle_fullscreen(self):
        """Toggle fullscreen mode"""
        if self.isFullScreen():
            self.showNormal()
        else:
            self.showFullScreen()

    def apply_theme(self):
        """Apply the current theme (dark or light mode)"""
        # Strong mode takes highest precedence when enabled
        try:
            if getattr(self, 'strong_mode', False):
                # Resolve an appropriate strong palette. Prefer a direct
                # mapping from the selected named theme; otherwise fall back
                # to the mapped value or the first available strong palette.
                theme_name = getattr(self, 'color_theme', None)
                theme_key = None
                if theme_name:
                    # Directly mapped strong theme
                    theme_key = self.STRONG_THEME_MAP.get(theme_name)
                    # If the user mistakenly selected a strong key as color_theme,
                    # allow that too.
                    if not theme_key and theme_name in self.STRONG_COLOR_THEMES:
                        theme_key = theme_name

                if not theme_key:
                    # Choose the first strong theme as a safe fallback
                    try:
                        theme_key = next(iter(self.STRONG_COLOR_THEMES.keys()))
                    except Exception:
                        theme_key = None

                theme = self.STRONG_COLOR_THEMES.get(theme_key) if theme_key else None
                if theme:
                    # Apply the strong theme colors
                    win = theme.get('window_bg', '#111111')
                    panel = theme.get('panel_bg', '#222222')
                    text = theme.get('text', '#ffffff')
                    accent = theme.get('accent', '#ff6600')

                    # If dark mode is enabled, darken the colors further
                    if getattr(self, 'dark_mode', False):
                        # Make backgrounds darker for dark mode
                        from PyQt5.QtGui import QColor
                        win_color = QColor(win)
                        panel_color = QColor(panel)
                        # Darken the background colors by 30%
                        win = win_color.darker(130).name()
                        panel = panel_color.darker(130).name()

                    strong_style = f"""
QWidget, QDialog {{
    background-color: {win};
    color: {text};
}}
QFrame, QGroupBox {{
    background-color: {panel};
    color: {text};
}}
QLabel {{ color: {text}; background-color: transparent; }}
QTextEdit, QPlainTextEdit {{
    background-color: {panel};
    color: {text};
    border: 1px solid {accent};
}}
QLineEdit {{
    background-color: {panel};
    color: {text};
    border: 2px solid {accent};
    padding: 4px;
    border-radius: 3px;
}}
QPushButton {{
    background-color: {accent};
    color: {text};
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-weight: bold;
}}
QPushButton:hover {{
    background-color: {accent};
}}
QMenuBar {{
    background-color: {panel};
    color: {text};
    border-bottom: 2px solid {accent};
}}
QMenuBar::item:selected {{
    background-color: {accent};
    color: {text};
}}
QMenu {{
    background-color: {panel};
    color: {text};
    border: 2px solid {accent};
}}
QMenu::item:selected {{
    background-color: {accent};
    color: {text};
}}
QTabWidget::pane {{
    background-color: {panel};
    color: {text};
    border: 2px solid {accent};
}}
QTabBar::tab {{
    background-color: {win};
    color: {text};
    padding: 8px 16px;
    margin-right: 2px;
    border: 1px solid {accent};
}}
QTabBar::tab:selected {{
    background-color: {accent};
    color: {text};
    font-weight: bold;
}}
QTableWidget, QTreeWidget, QListWidget {{
    background-color: {panel};
    color: {text};
    border: 1px solid {accent};
    alternate-background-color: {win};
}}
QHeaderView::section {{
    background-color: {accent};
    color: {text};
    padding: 4px;
    border: none;
    font-weight: bold;
}}
QScrollBar:vertical {{
    background-color: {panel};
    width: 12px;
    border: 1px solid {accent};
}}
QScrollBar::handle:vertical {{
    background-color: {accent};
    border-radius: 6px;
}}
QScrollBar:horizontal {{
    background-color: {panel};
    height: 12px;
    border: 1px solid {accent};
}}
QScrollBar::handle:horizontal {{
    background-color: {accent};
    border-radius: 6px;
}}
"""
                    self.setStyleSheet(strong_style)
                    return
        except Exception:
            pass

        # Subdued mode takes precedence when enabled (after strong mode)
        try:
            if getattr(self, 'subdued_mode', False):
                # Resolve an appropriate subdued palette. Prefer a direct
                # mapping from the selected named theme; otherwise fall back
                # to the mapped value or the first available subdued palette.
                theme_name = getattr(self, 'color_theme', None)
                theme_key = None
                if theme_name:
                    # Directly mapped subdued theme
                    theme_key = self.SUBDUED_THEME_MAP.get(theme_name)
                    # If the user mistakenly selected a subdued key as color_theme,
                    # allow that too.
                    if not theme_key and theme_name in self.SUBDUED_COLOR_THEMES:
                        theme_key = theme_name

                if not theme_key:
                    # Choose the first subdued theme as a safe fallback
                    try:
                        theme_key = next(iter(self.SUBDUED_COLOR_THEMES.keys()))
                    except Exception:
                        theme_key = None

                theme = self.SUBDUED_COLOR_THEMES.get(theme_key) if theme_key else None
                if theme:
                    wbg = theme.get('window_bg', '#111111')
                    pbg = theme.get('panel_bg', '#1a1a1a')
                    txt = theme.get('text', '#ffffff')
                    acc = theme.get('accent', '#ff4d00')

                    # If dark mode is enabled, darken the colors further
                    if getattr(self, 'dark_mode', False):
                        # Make backgrounds darker for dark mode
                        from PyQt5.QtGui import QColor
                        wbg_color = QColor(wbg)
                        pbg_color = QColor(pbg)
                        # Darken the background colors by 30%
                        wbg = wbg_color.darker(130).name()
                        pbg = pbg_color.darker(130).name()

                    subdued_style = f"""
                    QWidget, QDialog {{
                        background-color: {wbg};
                        color: {txt};
                    }}
                    QFrame, QGroupBox {{
                        background-color: {pbg};
                        color: {txt};
                    }}
                    QPushButton {{
                        background-color: {pbg};
                        color: {txt};
                        border: 1px solid rgba(0,0,0,0.12);
                        border-radius: 3px;
                        padding: 5px 12px;
                    }}
                    QMenu, QMenuBar {{ background-color: {pbg}; color: {txt}; }}
                    QWidget:selected, QTableWidget::item:selected {{ background-color: {acc}; color: #ffffff; }}
                    """
                    self.setStyleSheet(subdued_style)
                    return
        except Exception:
            # If something goes wrong while trying to apply subdued styles,
            # fall through to existing dark/light handling.
            pass
        if self.dark_mode:
            # Prefer a theme-specific dark palette if available so the selected
            # theme feels consistent in dark mode.
            theme_key = getattr(self, 'color_theme', 'Default Light')
            dark_theme = None
            try:
                dark_theme = self.DARK_COLOR_THEMES.get(theme_key)
            except Exception:
                dark_theme = None

            if dark_theme:
                # Build a dark stylesheet using the dark_theme palette
                wbg = dark_theme.get('window_bg', '#2b2b2b')
                pbg = dark_theme.get('panel_bg', '#363636')
                txt = dark_theme.get('recommended_text', dark_theme.get('text', '#ffffff'))
                acc = dark_theme.get('accent', '#3daee9')
                dark_style = f"""
                QMainWindow {{
                    background-color: {wbg};
                    color: {txt};
                }}
                QWidget {{
                    background-color: {pbg};
                    color: {txt};
                }}
                QTreeView, QListView, QTableView {{
                    background-color: {pbg};
                    color: {txt};
                    selection-background-color: {acc};
                    selection-color: {txt};
                }}
                QMenuBar {{
                    background-color: {pbg};
                    color: {txt};
                }}
                QToolBar {{
                    background-color: {pbg};
                    color: {txt};
                }}
                QPushButton {{
                    background-color: {pbg};
                    color: {txt};
                    border: 1px solid rgba(255,255,255,0.06);
                    padding: 5px;
                    border-radius: 3px;
                }}
                QPushButton:hover {{
                    background-color: {wbg};
                }}
                QStatusBar {{
                    background-color: {pbg};
                    color: {txt};
                }}
                QMenu {{
                    background-color: {pbg};
                    color: {txt};
                }}
                QScrollArea {{
                    background-color: {wbg};
                    border: none;
                }}
                """
                self.setStyleSheet(dark_style)
            else:
                # Fallback to the generic dark stylesheet
                dark_style = """
                QMainWindow {
                    background-color: #2b2b2b;
                    color: #ffffff;
                }
                QTreeView {
                    background-color: #363636;
                    color: #ffffff;
                    border: 1px solid #555555;
                    selection-background-color: #0078d7;
                }
                QListView {
                    background-color: #363636;
                    color: #ffffff;
                    border: 1px solid #555555;
                    selection-background-color: #0078d7;
                    selection-color: #ffffff;
                    alternate-background-color: #404040;
                }
                QListView::item {
                    padding: 4px;
                    border: none;
                }
                QListView::item:hover {
                    background-color: #4a4a4a;
                }
                QListView::item:selected {
                    background-color: #0078d7;
                    color: #ffffff;
                }
                QScrollArea {
                    background-color: #2b2b2b;
                    border: none;
                }
                QWidget {
                    background-color: #2b2b2b;
                    color: #ffffff;
                }
                QPushButton {
                    background-color: #404040;
                    color: #ffffff;
                    border: 1px solid #555555;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #505050;
                }
                QPushButton:pressed {
                    background-color: #0078d7;
                }
                QMenuBar {
                    background-color: #363636;
                    color: #ffffff;
                    border-bottom: 1px solid #555555;
                }
                QMenuBar::item {
                    background-color: transparent;
                    padding: 4px 8px;
                }
                QMenuBar::item:selected {
                    background-color: #0078d7;
                }
                QMenu {
                    background-color: #363636;
                except Exception:
                    pass
                def _set_theme(checked, name=name):
                    try:
                        if checked:
                            # Selecting a regular named theme switches out of subdued
                            self.subdued_mode = False
                            try:
                                settings = QSettings('garysfm', 'garysfm')
                                settings.setValue('subdued_mode', False)
                            except Exception:
                                pass
                            self.set_color_theme(name)
                    except Exception:
                        pass
                a.toggled.connect(_set_theme)
                theme_menu.addAction(a)
                self._theme_actions[name] = a

            # Remove deprecated separate colorful themes submenu since we've integrated them into main menu
                    color: #ffffff;
                    border: none;
                    spacing: 3px;
                }
                QToolBar QToolButton {
                    background-color: #404040;
                    color: #ffffff;
                    border: none;
                    padding: 5px;
                    margin: 1px;
                }
                QToolBar QToolButton:hover {
                    background-color: #505050;
                }
                QStatusBar {
                    background-color: #363636;
                    color: #ffffff;
                    border-top: 1px solid #555555;
                }
                """
                self.setStyleSheet(dark_style)

            # Apply dark theme flag to custom widgets
            for widget in self.findChildren(IconWidget):
                widget.update_style_for_theme(True)
        else:
            # Light mode (use selected color theme)
            try:
                theme = self.COLOR_THEMES.get(getattr(self, 'color_theme', 'Default Light'), self.COLOR_THEMES['Default Light'])
                window_bg = theme.get('window_bg', '#ffffff')
                panel_bg = theme.get('panel_bg', '#f5f5f5')
                text_col = theme.get('recommended_text', theme.get('text', '#000000'))
                accent = theme.get('accent', '#0078d7')

                # If dark mode is enabled, apply dark mode transformations to regular themes
                if getattr(self, 'dark_mode', False):
                    # Convert light colors to dark equivalents
                    from PyQt5.QtGui import QColor
                    
                    # Transform background colors
                    if window_bg == '#ffffff':
                        window_bg = '#2b2b2b'
                    else:
                        win_color = QColor(window_bg)
                        window_bg = win_color.darker(200).name()
                    
                    if panel_bg == '#f5f5f5':
                        panel_bg = '#363636'
                    else:
                        panel_color = QColor(panel_bg)
                        panel_bg = panel_color.darker(200).name()
                    
                    # Transform text color
                    if text_col == '#000000':
                        text_col = '#ffffff'
                    else:
                        text_color = QColor(text_col)
                        # If the text color is dark, make it light
                        r, g, b, _ = text_color.getRgb()
                        brightness = (r + g + b) / 3
                        if brightness < 128:  # Dark text
                            text_col = '#ffffff'
                    
                    # Keep accent color but may need to adjust for contrast
                    accent_color = QColor(accent)
                    # Make accent brighter for dark mode if it's too dark
                    r, g, b, _ = accent_color.getRgb()
                    brightness = (r + g + b) / 3
                    if brightness < 100:
                        accent = accent_color.lighter(150).name()

                light_style = f"""
                QMainWindow {{
                    background-color: {window_bg};
                    color: {text_col};
                }}
                QWidget {{
                    background-color: {panel_bg};
                    color: {text_col};
                }}
                QTreeView, QListView, QTableView {{
                    background-color: {panel_bg};
                    color: {text_col};
                    selection-background-color: {accent};
                    selection-color: {text_col};
                }}
                QMenuBar {{
                    background-color: {panel_bg};
                    color: {text_col};
                }}
                QToolBar {{
                    background-color: {panel_bg};
                    color: {text_col};
                }}
                QPushButton {{
                    background-color: {panel_bg};
                    color: {text_col};
                    border: 1px solid rgba(0,0,0,0.08);
                    padding: 5px;
                    border-radius: 3px;
                }}
                QPushButton:hover {{
                    background-color: {window_bg};
                }}
                QStatusBar {{
                    background-color: {panel_bg};
                    color: {text_col};
                }}
                QMenu {{
                    background-color: {panel_bg};
                    color: {text_col};
                }}
                """
                self.setStyleSheet(light_style)
            except Exception:
                self.setStyleSheet("")

            # Apply light theme flag to custom widgets
            for widget in self.findChildren(IconWidget):
                widget.update_style_for_theme(False)
        
        # Update breadcrumb styling
        breadcrumb_style = """
            QWidget {
                background-color: rgba(0, 120, 215, 0.1);
                border: 1px solid rgba(0, 120, 215, 0.3);
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 11px;
            }
            QWidget:hover {
                background-color: rgba(0, 120, 215, 0.2);
            }
            QLabel {
                background: transparent;
                border: none;
                padding: 2px;
            }
            QLabel:hover {
                color: #0078d7;
                text-decoration: underline;
            }
            """ if not self.dark_mode else """
            QWidget {
                background-color: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 11px;
                color: #ffffff;
            }
            QWidget:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }
            QLabel {
                background: transparent;
                border: none;
                padding: 2px;
                color: #ffffff;
            }
            QLabel:hover {
                color: #ffffff;
                text-decoration: underline;
            }
            """
        
        # Apply missing methods placeholder
        breadcrumb_style += """
            /* Additional breadcrumb styling */
            QLabel[class="breadcrumb-separator"] {
                color: gray;
            }
        """
        
        if hasattr(self, 'breadcrumb'):
            self.breadcrumb.setStyleSheet(breadcrumb_style)
        
        # Automatically apply Windows 98 QSS if applicable
        try:
            current_theme_name = getattr(self, 'color_theme', None)
            if current_theme_name:
                self.apply_windows98_qss_if_applicable(current_theme_name)
        except Exception as e:
            print(f"[DEBUG] Error applying Windows 98 QSS: {e}")

    def get_current_theme_settings(self):
        """Get current theme settings for persistence."""
        try:
            settings = {
                'dark_mode': getattr(self, 'dark_mode', False),
                'color_theme': getattr(self, 'color_theme', None),
                'strong_mode': getattr(self, 'strong_mode', False),
                'subdued_mode': getattr(self, 'subdued_mode', False)
            }
            
            # Add advanced styling properties if they exist
            current_theme_name = getattr(self, 'color_theme', None)
            if current_theme_name:
                # Try to get advanced properties from current active theme
                theme_dict = None
                if getattr(self, 'strong_mode', False) and hasattr(self, 'STRONG_COLOR_THEMES'):
                    theme_dict = self.STRONG_COLOR_THEMES.get(current_theme_name)
                elif getattr(self, 'subdued_mode', False) and hasattr(self, 'SUBDUED_COLOR_THEMES'):
                    theme_dict = self.SUBDUED_COLOR_THEMES.get(current_theme_name)
                else:
                    theme_dict = self.COLOR_THEMES.get(current_theme_name, {})
                
                if theme_dict:
                    # Save advanced styling properties
                    advanced_props = [
                        'border_width', 'border_radius', 'border_style',
                        'padding', 'margin', 'font_size', 'font_weight', 
                        'font_family', 'opacity', 'shadow_enabled', 
                        'shadow_blur', 'shadow_offset'
                    ]
                    
                    for prop in advanced_props:
                        if prop in theme_dict:
                            settings[prop] = theme_dict[prop]
            
            return settings
        except Exception as e:
            print(f"Error getting theme settings: {e}")
            return {}

    def restore_theme_settings(self, theme_settings):
        """Restore theme settings from saved data."""
        try:
            if not theme_settings:
                return
            
            # Restore basic theme properties
            self.dark_mode = theme_settings.get('dark_mode', False)
            self.color_theme = theme_settings.get('color_theme', None)
            self.strong_mode = theme_settings.get('strong_mode', False)
            self.subdued_mode = theme_settings.get('subdued_mode', False)
            
            # If we have a theme name with advanced properties, restore them
            current_theme_name = self.color_theme
            if current_theme_name:
                # Determine which theme dictionary to update
                target_dict = None
                if self.strong_mode and hasattr(self, 'STRONG_COLOR_THEMES'):
                    target_dict = self.STRONG_COLOR_THEMES
                elif self.subdued_mode and hasattr(self, 'SUBDUED_COLOR_THEMES'):
                    target_dict = self.SUBDUED_COLOR_THEMES
                else:
                    target_dict = self.COLOR_THEMES
                
                if target_dict and current_theme_name in target_dict:
                    # Update theme with saved advanced properties
                    theme_dict = target_dict[current_theme_name]
                    
                    advanced_props = [
                        'border_width', 'border_radius', 'border_style',
                        'padding', 'margin', 'font_size', 'font_weight', 
                        'font_family', 'opacity', 'shadow_enabled', 
                        'shadow_blur', 'shadow_offset'
                    ]
                    
                    for prop in advanced_props:
                        if prop in theme_settings:
                            theme_dict[prop] = theme_settings[prop]
            
            print(f"Restored theme settings: {current_theme_name}, dark_mode: {self.dark_mode}")
            
        except Exception as e:
            print(f"Error restoring theme settings: {e}")

    def save_theme_settings(self):
        """Save current theme settings immediately."""
        try:
            current_tab = self.tab_manager.get_current_tab()
            if current_tab and hasattr(current_tab, 'current_folder'):
                self.save_last_dir(current_tab.current_folder)
            else:
                # Fallback to current directory
                self.save_last_dir(os.getcwd())
        except Exception as e:
            print(f"Error saving theme settings: {e}")

    def show_about_dialog(self):
        """Show a scrollable about dialog with release notes."""
        # Build about text
        about_lines = [
            "Gary's File Manager",
            "Version 1.3.0 - Dynamic dialog theming, improved color extraction, transfer manager control",
            "Release: October 2025",
            "",
            "What's New in 1.3.0:",
            "• Dialogs now inherit the current QSS theme dynamically for consistent appearance",
            "• Dialog text color uses the primary foreground color for improved readability",
            "• Transfer Manager remains hidden unless explicitly enabled via the menu",
            "• Improved theme color extraction logic for better contrast and accessibility",
            "• Enhanced reliability and polish for dialog and theme handling",
            "• Updated About dialog and versioning for this release",
            "",
            "What's New in 1.2.9:",
            "• Streamlined navigation toolbar with optimized button layout and spacing",
            "• Relocated clipboard functionality to Edit menu for better organization",
            "• Moved search functionality to Tools > Search for improved menu structure",
            "• Added My Computer button for quick access to system drives and special folders",
            "• Centered bookmark dropdown menu positioning for better visual alignment",
            "• Removed view mode buttons from toolbar - now accessible via View menu",
            "• Eliminated QSS applied notification popups for cleaner theme switching",
            "• Fixed bookmark manager theme application error for improved stability",
            "• Enhanced toolbar cleanup removing refresh button for simplified interface",
            "• Improved bookmark bar positioning for consistent navigation flow",
            "",
            "What's New in 1.2.8:",
            "• Enhanced My Computer button functionality for better tab navigation",
            "• Improved right panel (Preview, Cloud Sync, Tags, Collections) can now be toggled via View menu",
            "• Streamlined UI by removing redundant preview pane toggle - now controlled by right panel toggle",
            "• Enhanced right panel visibility state persists between application launches",
            "• Improved cleaner bookmark toolbar layout with better My Computer integration",
            "• Fixed My Computer button error handling and navigation reliability",
            "• Removed duplicate My Computer button from tab area for cleaner interface",
            "",
            "What's New in 1.2.7:",
            "• Fixed macOS thumbnail caching to disk with directory-based file detection",
            "• Fixed video thumbnail caching on macOS - generated thumbnails now persist correctly",
            "• Fixed macOS path normalization issues with cache key generation using realpath/abspath/normcase",
            "• Enhanced ThumbnailCache class with macOS-specific optimizations for file system compatibility",
            "• Improved cache staleness detection for video files on macOS to prevent unnecessary regeneration",
            "• Fixed audio waveform thumbnail caching on macOS using directory listing instead of os.path.exists()",
            "",
            "What's New in 1.2.6:",
            "• New KDE Breeze theme collection with 4 professional variants (Classic, Dark, Light, Twilight)",
            "• Authentic KDE design language with signature blue accents (#3daee9) and 4px border radius",
            "• My Computer button repositioned next to tabs for improved navigation workflow",
            "• Optimized UI layout spacing for more compact and efficient interface design",
            "• Reduced gaps between navigation buttons and tabs throughout the application",
            "• Removed duplicate My Computer buttons for cleaner, more organized interface",
            "• Enhanced tab area layout with minimal spacing and professional appearance",
            "",
            "Previous Updates (1.2.5):",
            "• Revolutionary QSS stylesheet system with comprehensive OS theme collection",
            "• Professional QSS themes: Windows 11 (Light/Dark), macOS Sequoia (Light/Dark), Ubuntu (Light/Dark)",
            "• Additional QSS themes: Linux Mint variants, Kali Linux hacker aesthetic",
            "• External QSS file loading system works perfectly in compiled executables",
            "• QSS persistence system automatically saves and restores stylesheet choices",
            "• Enhanced tab navigation with full directory name visibility (no more truncation)",
            "• Intelligent tab width calculation with padding prevents letter cut-off",
            "• Tab scroll buttons appear automatically when tabs overflow",
            "• Breadcrumb styling optimized for all QSS theme compatibility",
            "• QSS files load from external 'qss' folder like gsfmt themes for easy distribution",
            "",
            "Previous Updates (1.2.3):",
            "• Revolutionary theme cleanup system: automatically removes orphaned themes on startup",
            "• Multi-mode theme architecture with regular, strong, subdued, and dark variants",
            "• Professional OS-themed color schemes: Windows 11 Dark, Linux Mint Modern, Ubuntu Default, Debian Classic",
            "• Beautiful color swatch icons in theme menus with authentic OS colors and anti-aliasing",
            "• Silent theme maintenance with automatic QSettings cleanup for better performance",
            "• Enhanced theme validation system with comprehensive multi-mode detection",
            "• Fixed critical theme loading bug that prevented external themes from appearing in menus",
            "• Improved theme menu organization with proper categorization and visual feedback",
            "• Complete external theme system overhaul for better reliability and modularity",
            "",
            "Previous Updates (1.2.2):",
            "• Enhanced theme organization: themes now stored in dedicated 'gsfmt' folder",
            "• Automatic migration of existing theme files to new gsfmt folder location",
            "• Improved theme customization dialog shows save location to users",
            "• Complete theme system overhaul with advanced styling properties",
            "• Mode-aware theme persistence with proper categorization on restart",
            "• Enhanced theme validation for extended properties support",
            "• Clickable .gsfmt theme files in file manager for instant theme loading",
            "• Fixed theme mode switching to preserve selected theme across mode changes",
            "",
            "Previous Updates (1.2.1):",
            "• Enhanced universal dark mode support across all theme types",
            "• Reorganized theme system to use external .gsfmt files for better modularity",
            "• Improved theme swatch previews with distinctive shapes for each category",
            "",
            "Previous Updates (1.2.0):",
            "• Added external theme system with .gsfmt files for better modularity",
            "• Theme menu now shows a small rounded color swatch preview for each theme",
            "• Computed accessible recommended text colors per theme for better contrast",
            "• Persisted event-filter verbosity toggle and added a View → Verbose Event Filter Messages checkbox",
            "• Reduced noisy thumbnail and icon-container debug output (toggleable)",
            "• Right-click context menus now use non-blocking popups so clicks outside the app are received",
            "• Fixed various bugs including a context-menu NameError on startup",
            "• Misc UI polish and accessibility improvements",
            "",
            "🚀 FEATURES:",
            "• APK thumbnail extraction and adaptive icon composition (extracts launcher icons from .apk)",
            "• Cache generated APK thumbnails for faster reloads",
            "• Improved ISO thumbnails – extract EXE icons and composite them over disc artwork",
            "• Improved heuristics and fallbacks for APK/ISO layouts",
            "• Video thumbnailing for major formats (mp4, mkv, avi, mov, etc.)",
            "• ffmpeg-based thumbnail extraction (cross-platform)",
            "• Persistent thumbnail cache for images and videos",
            "• Improved error handling and stability",
            "• 'Open with...' option in right-click menu for files",
            "• Custom PyQt dialog for choosing applications",
            "• Platform-specific handling for launching files",
            "• Multiple view modes (Thumbnail, List, Detail)",
            "• Advanced file operations with progress tracking",
            "• Multi-tab browsing with session persistence",
            "• Per-folder sort settings (remembers preferences)",
            "• Tree view navigation sidebar",
            "• ZIP, TAR, TAR.GZ, TGZ, TAR.BZ2, RAR support",
            "• Create, extract, and browse archives",
            "• Built-in directory selection dialogs",
            "• Archive preview with file listing",
            "• Advanced search engine with filters",
            "• File content preview pane",
            "• Image preview with scaling",
            "• Text file syntax highlighting",
            "• Dark/Light theme toggle",
            "• Customizable thumbnail sizes",
            "• Word wrapping for long filenames",
            "• Resizable panels and toolbars",
            "• Professional context menus",
            "• Background file operations",
            "• Smart memory management",
            "• Thumbnail caching system",
            "• Responsive UI with progress indicators",
            "• Cross-platform compatibility with Windows optimizations",
            "",
            "FEATURES ADDED IN 1.1.3 (moved):",
            "• Tools → Recursive Precache Thumbnails... for multi-size, fast thumbnail generation",
            "• Always shows a progress dialog during thumbnail caching",
            "• Thread-safe thumbnail generation",
            "• No extra popups during recursive precache; only the progress dialog is shown",
            "",
            "📦 COMPILED EXECUTABLE SETUP:",
            "• When using the compiled .exe version, create a 'gsfmt' folder next to the .exe file",
            "• Copy .gsfmt theme files into this folder for custom themes to load properly",
            "• Create a 'qss' folder next to the .exe file for QSS stylesheet support",
            "• Copy .qss files into the qss folder for custom QSS themes to load properly",
            "• Use Info → Debug Theme Paths to troubleshoot theme loading issues",
            "• The application will automatically create both gsfmt and qss folders if they don't exist",
            "",
        ]

        about_text = "\n".join(about_lines)

        # Show dialog
        try:
            from PyQt5.QtWidgets import QDialog, QVBoxLayout, QScrollArea, QLabel, QDialogButtonBox
            from PyQt5.QtCore import Qt

            dlg = QDialog(self)
            dlg.setWindowTitle("About Gary's File Manager")
            dlg.resize(560, 420)

            layout = QVBoxLayout(dlg)

            content = QLabel()
            content.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
            content.setWordWrap(True)
            html = '<br>'.join([f"{line}" for line in about_text.split('\n')])
            content.setText(html)

            scroll = QScrollArea()
            scroll.setWidgetResizable(True)
            scroll.setWidget(content)

            layout.addWidget(scroll)

            btn_box = QDialogButtonBox(QDialogButtonBox.Ok)
            btn_box.accepted.connect(dlg.accept)
            layout.addWidget(btn_box)

            dlg.exec_()
        except Exception:
            # Fallback to QMessageBox if widgets unavailable
            try:
                from PyQt5.QtWidgets import QMessageBox
                QMessageBox.about(self, "About Gary's File Manager", about_text)
            except Exception:
                print(about_text)

    def show_sourceforge_upload_dialog(self, prefill_path=None, auto_start=False):
        """Show SourceForge upload dialog using a QThread worker.

        Arguments:
            prefill_path (str|None): if provided, pre-fill the File field with this path.
            auto_start (bool): if True and prefill_path is provided, start upload automatically.
        """
        try:
            from PyQt5.QtWidgets import QDialog, QFormLayout, QLineEdit, QPushButton, QLabel, QFileDialog, QVBoxLayout, QMessageBox, QProgressDialog
            from PyQt5.QtCore import Qt, QTimer, QThread, pyqtSignal, QObject
        except Exception:
            try:
                QMessageBox.information(self, "Upload", "Qt not available for upload dialog")
            except Exception:
                print("Qt not available for upload dialog")
            return

        class MultiUploadWorker(QObject):
            file_finished = pyqtSignal(str, dict)  # path, result
            all_finished = pyqtSignal()

            def __init__(self, paths, project, username, password):
                super().__init__()
                self.paths = list(paths)
                self.project = project
                self.username = username
                self.password = password
                self._stopped = False

            def stop(self):
                self._stopped = True

            def run(self):
                for p in self.paths:
                    if self._stopped:
                        break
                    try:
                        res = upload_to_sourceforge(p, self.project, self.username, self.password)
                        if not isinstance(res, dict):
                            res = {'status': 'ok', 'result': res}
                    except Exception as e:
                        res = {'status': 'error', 'message': str(e)}
                    self.file_finished.emit(p, res)
                self.all_finished.emit()

        dlg = QDialog(self)
        dlg.setWindowTitle("Upload to SourceForge")
        layout = QVBoxLayout(dlg)
        form = QFormLayout()

        # Multi-file list
        from PyQt5.QtWidgets import QListWidget, QHBoxLayout

        file_list = QListWidget()
        add_btn = QPushButton("Add Files...")
        remove_btn = QPushButton("Remove Selected")

        def on_add():
            paths, _ = QFileDialog.getOpenFileNames(self, "Select files to upload")
            for p in paths:
                file_list.addItem(p)

        def on_remove():
            for it in file_list.selectedItems():
                file_list.takeItem(file_list.row(it))

        add_btn.clicked.connect(on_add)
        remove_btn.clicked.connect(on_remove)

        form.addRow(QLabel("Files:"), file_list)
        form.addRow("Project:", QLineEdit())
        project_edit = form.itemAt(form.rowCount()-1, QFormLayout.FieldRole).widget()
        form.addRow("Username:", QLineEdit())
        username_edit = form.itemAt(form.rowCount()-1, QFormLayout.FieldRole).widget()
        form.addRow("Password:", QLineEdit())
        password_edit = form.itemAt(form.rowCount()-1, QFormLayout.FieldRole).widget()
        password_edit.setEchoMode(QLineEdit.Password)

        layout.addLayout(form)
        btns_h = QHBoxLayout()
        btns_h.addWidget(add_btn)
        btns_h.addWidget(remove_btn)
        btns_h.addStretch()
        layout.addLayout(btns_h)

        btn_upload = QPushButton("Start Upload")
        btn_cancel = QPushButton("Cancel")
        layout.addWidget(btn_upload)
        layout.addWidget(btn_cancel)

        progress = QProgressDialog("Uploading...", "Cancel", 0, 0, self)
        progress.setWindowModality(Qt.ApplicationModal)
        progress.setMinimumDuration(200)

        worker_thread = None
        worker_obj = None

        def start_upload():
            nonlocal worker_thread, worker_obj
            paths = [file_list.item(i).text() for i in range(file_list.count())]
            project = project_edit.text().strip()
            username = username_edit.text().strip()
            password = password_edit.text()
            if not paths or not project:
                QMessageBox.warning(dlg, "Upload", "Please add one or more files and enter project name")
                return

            progress.show()

            worker_obj = MultiUploadWorker(paths, project, username, password)
            worker_thread = QThread()
            worker_obj.moveToThread(worker_thread)
            worker_thread.started.connect(worker_obj.run)

            def on_file_finished(path, result):
                # Show a non-blocking notification for each file
                if result.get('status') == 'ok':
                    self.status_bar.showMessage(f"Uploaded {os.path.basename(path)}", 4000)
                else:
                    self.status_bar.showMessage(f"Error uploading {os.path.basename(path)}: {result.get('message')}", 6000)

            def on_all_finished():
                progress.close()
                QMessageBox.information(self, "Upload", "All queued uploads finished")
                worker_thread.quit()
                worker_thread.wait()
                dlg.accept()

            worker_obj.file_finished.connect(on_file_finished)
            worker_obj.all_finished.connect(on_all_finished)
            worker_thread.start()

        btn_upload.clicked.connect(start_upload)

        def on_cancel():
            try:
                if worker_obj:
                    worker_obj.stop()
            except Exception:
                pass
            dlg.reject()

        btn_cancel.clicked.connect(on_cancel)

        # Pre-fill list if provided
        if prefill_path:
            # accept either a single path or a list
            if isinstance(prefill_path, (list, tuple)):
                for p in prefill_path:
                    file_list.addItem(p)
            else:
                file_list.addItem(prefill_path)
            if auto_start:
                QTimer.singleShot(150, start_upload)

        dlg.exec_()

    def show_github_upload_dialog(self):
        """Show GitHub release upload dialog with simple progress indicator."""
        try:
            from PyQt5.QtWidgets import QDialog, QFormLayout, QLineEdit, QPushButton, QLabel, QFileDialog, QVBoxLayout, QMessageBox, QProgressDialog
            from PyQt5.QtCore import Qt, QTimer
        except Exception:
            try:
                QMessageBox.information(self, "Upload", "Qt not available for upload dialog")
            except Exception:
                print("Qt not available for upload dialog")
            return

        dlg = QDialog(self)
        dlg.setWindowTitle("Upload to GitHub Release")
        layout = QVBoxLayout(dlg)
        form = QFormLayout()

        file_edit = QLineEdit()
        browse_btn = QPushButton("Browse...")
        def on_browse():
            path, _ = QFileDialog.getOpenFileName(self, "Select file to upload")
            if path:
                file_edit.setText(path)
        browse_btn.clicked.connect(on_browse)

        form.addRow(QLabel("File:"), file_edit)
        form.addRow("Repo (owner/repo):", QLineEdit())
        repo_edit = form.itemAt(form.rowCount()-1, QFormLayout.FieldRole).widget()
        form.addRow("Tag (e.g. v1.0.0):", QLineEdit())
        tag_edit = form.itemAt(form.rowCount()-1, QFormLayout.FieldRole).widget()
        form.addRow("Access Token:", QLineEdit())
        token_edit = form.itemAt(form.rowCount()-1, QFormLayout.FieldRole).widget()
        token_edit.setEchoMode(QLineEdit.Password)

        layout.addLayout(form)
        layout.addWidget(browse_btn)
        btn_upload = QPushButton("Upload")
        btn_cancel = QPushButton("Cancel")
        layout.addWidget(btn_upload)
        layout.addWidget(btn_cancel)

        def do_upload():
            path = file_edit.text().strip()
            repo = repo_edit.text().strip()
            tag = tag_edit.text().strip()
            token = token_edit.text().strip()
            if not path or not repo or not tag or not token:
                QMessageBox.warning(dlg, "Upload", "Please fill all fields")
                return

            progress = QProgressDialog("Uploading to GitHub...", "Cancel", 0, 0, self)
            progress.setWindowModality(Qt.ApplicationModal)
            progress.setMinimumDuration(200)
            progress.show()

            done_event = {'done': False, 'result': None}

            def worker():
                try:
                    res = upload_to_github_release(path, repo, tag, token)
                    done_event['result'] = res
                except Exception as e:
                    done_event['result'] = {'status': 'error', 'message': str(e)}
                finally:
                    done_event['done'] = True

            import threading
            t = threading.Thread(target=worker, daemon=True)
            t.start()

            def poll():
                if done_event['done']:
                    progress.close()
                    r = done_event['result']
                    if isinstance(r, dict) or hasattr(r, 'get'):
                        if r.get('status') == 'ok' or r.get('state') or r.get('id'):
                            QMessageBox.information(self, "Upload", f"Upload finished: {r}")
                        else:
                            QMessageBox.information(self, "Upload", str(r))
                    else:
                        QMessageBox.information(self, "Upload", str(r))
                    dlg.accept()
                else:
                    QTimer.singleShot(200, poll)

            QTimer.singleShot(200, poll)

        btn_upload.clicked.connect(do_upload)
        btn_cancel.clicked.connect(dlg.reject)
        dlg.exec_()

    def show_contact_dialog(self):
        """Show the contact dialog with clickable email"""
        # Create a custom dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Contact Me")
        dialog.setFixedSize(300, 150)
        
        layout = QVBoxLayout()
        
        # Contact message
        contact_label = QLabel("For questions or feedback, please contact:")
        contact_label.setWordWrap(True)
        layout.addWidget(contact_label)
        
        # Clickable email button
        email_button = QPushButton("gary@gmail.com")
        email_button.setStyleSheet("QPushButton { text-align: left; border: none; color: blue; }")
        email_button.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("mailto:gary@gmail.com")))
        layout.addWidget(email_button)
        
        # Close button
        close_button = QPushButton("Close")
        close_button.clicked.connect(dialog.close)
        layout.addWidget(close_button)
        
        dialog.setLayout(layout)
        dialog.exec_()
    
    def show_preferences(self):
        """Show preferences dialog allowing user to control caching dialog behavior"""
        try:
            class PreferencesDialog(QDialog):
                def __init__(self, parent=None):
                    super().__init__(parent)
                    self.setWindowTitle("Preferences")
                    self.setMinimumWidth(360)
                    layout = QVBoxLayout(self)

                    label = QLabel("Thumbnail caching dialog behavior:")
                    layout.addWidget(label)

                    from PyQt5.QtWidgets import QRadioButton, QButtonGroup
                    self.group = QButtonGroup(self)
                    self.rb_ask = QRadioButton("Ask (show when work needed)")
                    self.rb_always = QRadioButton("Always show caching dialog")
                    self.rb_never = QRadioButton("Always hide caching dialog")
                    self.group.addButton(self.rb_ask)
                    self.group.addButton(self.rb_always)
                    self.group.addButton(self.rb_never)

                    layout.addWidget(self.rb_ask)
                    layout.addWidget(self.rb_always)
                    layout.addWidget(self.rb_never)

                    btn_layout = QHBoxLayout()
                    ok = QPushButton("OK")
                    cancel = QPushButton("Cancel")
                    btn_layout.addWidget(ok)
                    btn_layout.addWidget(cancel)
                    layout.addLayout(btn_layout)

                    ok.clicked.connect(self.accept)
                    cancel.clicked.connect(self.reject)

                    # Load current setting
                    try:
                        settings = QSettings("garysfm", "garysfm")
                        val = settings.value('cache_dialog_pref', 'ask')
                    except Exception:
                        val = 'ask'
                    if val == 'always_show':
                        self.rb_always.setChecked(True)
                    elif val == 'always_hide':
                        self.rb_never.setChecked(True)
                    else:
                        self.rb_ask.setChecked(True)

                def selected_value(self):
                    if self.rb_always.isChecked():
                        return 'always_show'
                    if self.rb_never.isChecked():
                        return 'always_hide'
                    return 'ask'

            dlg = PreferencesDialog(self)
            if dlg.exec_() == QDialog.Accepted:
                val = dlg.selected_value()
                try:
                    settings = QSettings("garysfm", "garysfm")
                    settings.setValue('cache_dialog_pref', val)
                except Exception:
                    pass
                QMessageBox.information(self, "Preferences", "Preferences saved.")
        except Exception as e:
            QMessageBox.information(self, "Preferences", f"Preferences dialog failed: {e}")
    
    def toggle_show_hidden_files(self):
        """Toggle showing hidden files (placeholder for future implementation)"""
        # For now, show a simple message
        QMessageBox.information(self, "Hidden Files", "Show/hide hidden files coming soon!")
    
    def open_new_tab(self):
        """Open new tab (placeholder for future implementation)"""
        # For now, show a simple message
        QMessageBox.information(self, "New Tab", "Tabbed interface coming soon!")
    
    def move_to_trash(self):
        """Move selected items to trash (cross-platform).

        Tries send2trash, then platform helpers, and finally prompts to permanently
        delete items that could not be moved to trash.
        """
        selected_items = self.get_selected_items()
        if not selected_items:
            return

        failures = []

        # Try send2trash first
        try:
            import send2trash
            for item in selected_items:
                try:
                    send2trash.send2trash(item)
                except Exception:
                    failures.append(item)
            if not failures:
                self.refresh_current_view()
                QMessageBox.information(self, "Success", f"Moved {len(selected_items)} item(s) to trash.")
                return
        except Exception:
            failures = list(selected_items)

        # Try platform-specific fallbacks for remaining failures
        remaining = []
        for item_path in failures:
            try:
                if PlatformUtils.is_windows():
                    cmd = f'powershell.exe -Command "Add-Type -AssemblyName Microsoft.VisualBasic; [Microsoft.VisualBasic.FileIO.FileSystem]::DeleteFile(\'{item_path}\', \'OnlyErrorDialogs\', \'SendToRecycleBin\')"'
                    subprocess.run(cmd, shell=True, check=True)
                elif PlatformUtils.is_macos():
                    script = f'tell application "Finder" to delete POSIX file "{item_path}"'
                    subprocess.run(["osascript", "-e", script], check=True)
                else:
                    subprocess.run(["gio", "trash", item_path], check=True)
            except Exception:
                remaining.append(item_path)

        # If any items still remain, ask the user whether to permanently delete them
        if remaining:
            reply = QMessageBox.question(
                self,
                "Move to Trash",
                f"Some items could not be moved to the trash. Permanently delete {len(remaining)} item(s)?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No,
            )
            if reply == QMessageBox.Yes:
                for p in remaining:
                    try:
                        if os.path.isdir(p):
                            import shutil
                            shutil.rmtree(p)
                        else:
                            os.remove(p)
                    except Exception:
                        # ignore failures on delete
                        pass

        try:
            self.refresh_current_view()
        except Exception:
            pass

    def sync_tree_view_selection(self, folder_path):
        """Synchronize tree view selection with the given folder path"""
        try:
            index = self.model.index(folder_path)
            if index.isValid():
                self.tree_view.setCurrentIndex(index)
                self.tree_view.expand(index)
        except Exception as e:
            # If sync fails, just continue - it's not critical
            pass


class ClipboardHistoryDialog(QDialog):
    """Dialog for showing clipboard history"""
    def __init__(self, clipboard_manager, parent=None):
        super().__init__(parent)
        self.clipboard_manager = clipboard_manager
        self.selected_entry = None
        self.setup_ui()
        self.load_history()
    
    def setup_ui(self):
        self.setWindowTitle("Clipboard History")
        self.setModal(True)
        self.resize(500, 400)
        
        layout = QVBoxLayout()
        
        # History list
        self.history_list = QTableView()
        self.history_model = QStandardItemModel()
        self.history_model.setHorizontalHeaderLabels(['Operation', 'Files', 'Time'])
        self.history_list.setModel(self.history_model)
        self.history_list.setSelectionBehavior(QTableView.SelectRows)
        layout.addWidget(self.history_list)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        self.use_button = QPushButton("Use Selected")
        self.use_button.clicked.connect(self.use_selected)
        button_layout.addWidget(self.use_button)
        
        self.clear_button = QPushButton("Clear History")
        self.clear_button.clicked.connect(self.clear_history)
        button_layout.addWidget(self.clear_button)
        
        button_layout.addStretch()
        
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(self.cancel_button)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
    
    def load_history(self):
        """Load clipboard history into the table"""
        history = self.clipboard_manager.get_history()
        
        for entry in history:
            operation_item = QStandardItem(entry['operation'].capitalize())
            
            files_text = f"{len(entry['paths'])} files"
            if len(entry['paths']) == 1:
                files_text = os.path.basename(entry['paths'][0])
            files_item = QStandardItem(files_text)
            
            time_item = QStandardItem(entry['timestamp'].strftime('%Y-%m-%d %H:%M'))
            
            self.history_model.appendRow([operation_item, files_item, time_item])
        
        self.history_list.resizeColumnsToContents()
    
    def use_selected(self):
        """Use the selected history entry and update clipboard and UI"""
        selection = self.history_list.selectionModel().selectedRows()
        if selection:
            row = selection[0].row()
            history = self.clipboard_manager.get_history()
            if row < len(history):
                self.selected_entry = history[row]
                # Restore clipboard state
                self.clipboard_manager.set_current_operation(
                    self.selected_entry['operation'],
                    self.selected_entry['paths']
                )
                # Optionally refresh UI if parent is main window
                if self.parent() and hasattr(self.parent(), 'refresh_current_view'):
                    self.parent().refresh_current_view()
                self.accept()
    
    def clear_history(self):
        """Clear the clipboard history"""
        self.clipboard_manager.history.clear()
        self.history_model.clear()
        self.history_model.setHorizontalHeaderLabels(['Operation', 'Files', 'Time'])
    
    def get_selected_entry(self):
        """Get the selected history entry"""
        return self.selected_entry

class AdvancedOperationsDialog(QDialog):
    """Dialog for advanced file operations"""
    def __init__(self, selected_items, current_folder, parent=None):
        super().__init__(parent)
        self.selected_items = selected_items
        self.current_folder = current_folder
        self.parent_window = parent  # Store reference to parent
        self.setup_ui()
    
    def __del__(self):
        """Destructor to ensure proper cleanup"""
        try:
            pass  # No special cleanup needed
        except:
            pass
    
    def setup_ui(self):
        self.setWindowTitle("Advanced Operations")
        self.setModal(True)
        self.resize(400, 300)
        
        layout = QVBoxLayout()
        
        layout.addWidget(QLabel(f"Selected {len(self.selected_items)} item(s):"))
        
        # List selected items
        items_list = QTextEdit()
        items_list.setMaximumHeight(100)
        items_list.setReadOnly(True)
        items_text = "\n".join([os.path.basename(item) for item in self.selected_items])
        items_list.setPlainText(items_text)
        layout.addWidget(items_list)
        
        # Operations
        layout.addWidget(QLabel("Operations:"))
        
        self.compress_btn = QPushButton("Create Archive (.zip)")
        self.compress_btn.clicked.connect(self.create_archive)
        layout.addWidget(self.compress_btn)
        
        self.calculate_size_btn = QPushButton("Calculate Total Size")
        self.calculate_size_btn.clicked.connect(self.calculate_size)
        layout.addWidget(self.calculate_size_btn)
        
        self.duplicate_btn = QPushButton("Duplicate Items")
        self.duplicate_btn.clicked.connect(self.duplicate_items)
        layout.addWidget(self.duplicate_btn)
        
        # Results area
        self.results_text = QTextEdit()
        self.results_text.setMaximumHeight(100)
        self.results_text.setReadOnly(True)
        layout.addWidget(self.results_text)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        
        self.setLayout(layout)
    
    def create_archive(self):
        """Create a zip archive of selected items"""
        try:
            import zipfile
            archive_name = f"archive_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
            archive_path = os.path.join(self.current_folder, archive_name)
            
            with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for item_path in self.selected_items:
                    try:
                        if os.path.isfile(item_path):
                            zipf.write(item_path, os.path.basename(item_path))
                        elif os.path.isdir(item_path):
                            for root, dirs, files in os.walk(item_path):
                                for file in files:
                                    try:
                                        file_path = os.path.join(root, file)
                                        arc_path = os.path.relpath(file_path, os.path.dirname(item_path))
                                        zipf.write(file_path, arc_path)
                                    except Exception as file_error:
                                        self.results_text.append(f"Skipped file {file}: {str(file_error)}")
                                        continue
                    except Exception as item_error:
                        self.results_text.append(f"Error processing {os.path.basename(item_path)}: {str(item_error)}")
                        continue
            
            self.results_text.append(f"Archive created: {archive_name}")
        except Exception as e:
            self.results_text.append(f"Archive creation failed: {str(e)}")
            print(f"Archive creation error: {e}")
            import traceback
            traceback.print_exc()
    
    def calculate_size(self):
        """Calculate total size of selected items"""
        try:
            total_size = 0
            file_count = 0
            folder_count = 0
            
            for item_path in self.selected_items:
                try:
                    if os.path.isfile(item_path):
                        total_size += os.path.getsize(item_path)
                        file_count += 1
                    elif os.path.isdir(item_path):
                        folder_count += 1
                        for root, dirs, files in os.walk(item_path):
                            for file in files:
                                try:
                                    total_size += os.path.getsize(os.path.join(root, file))
                                    file_count += 1
                                except (OSError, IOError):
                                    continue  # Skip inaccessible files
                except Exception as item_error:
                    self.results_text.append(f"Error accessing {os.path.basename(item_path)}: {str(item_error)}")
                    continue
            
            # Format size
            def format_size(size):
                for unit in ['B', 'KB', 'MB', 'GB']:
                    if size < 1024:
                        return f"{size:.1f} {unit}"
                    size /= 1024
                return f"{size:.1f} TB"
            
            result = f"Total size: {format_size(total_size)}\n"
            result += f"Files: {file_count}, Folders: {folder_count}"
            self.results_text.append(result)
        except Exception as e:
            self.results_text.append(f"Size calculation failed: {str(e)}")
            print(f"Size calculation error: {e}")
            import traceback
            traceback.print_exc()
    
    def duplicate_items(self):
        """Create duplicates of selected items"""
        try:
            success_count = 0
            for item_path in self.selected_items:
                try:
                    base_name = os.path.basename(item_path)
                    name, ext = os.path.splitext(base_name)
                    duplicate_name = f"{name}_copy{ext}"
                    duplicate_path = os.path.join(os.path.dirname(item_path), duplicate_name)
                    
                    # Find unique name if duplicate already exists
                    counter = 1
                    while os.path.exists(duplicate_path):
                        duplicate_name = f"{name}_copy_{counter}{ext}"
                        duplicate_path = os.path.join(os.path.dirname(item_path), duplicate_name)
                        counter += 1
                    
                    if os.path.isfile(item_path):
                        shutil.copy2(item_path, duplicate_path)
                    elif os.path.isdir(item_path):
                        shutil.copytree(item_path, duplicate_path)
                    
                    success_count += 1
                except Exception as e:
                    base_name = os.path.basename(item_path) if item_path else "unknown"
                    self.results_text.append(f"Failed to duplicate {base_name}: {str(e)}")
                    continue
            
            self.results_text.append(f"Successfully duplicated {success_count} item(s)")
        except Exception as e:
            self.results_text.append(f"Duplication operation failed: {str(e)}")
            print(f"Duplication error: {e}")
            import traceback
            traceback.print_exc()

    def closeEvent(self, event):
        """Handle dialog close event safely"""
        try:
            # Clean up any resources if needed
            event.accept()
        except Exception as e:
            print(f"Error closing advanced operations dialog: {e}")
            event.accept()  # Accept anyway to prevent hanging


# Main application entry point
def main():
    """Start the file manager application"""
    try:
        # Enable high DPI scaling BEFORE creating QApplication
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)

        app = QApplication(sys.argv)

        # Enable QSS stylesheet support and advanced features
        app.setAttribute(Qt.AA_UseStyleSheetPropagationInWidgetStyles, True)
        
        # Set application metadata
        app.setApplicationName("Gary's File Manager")
        app.setApplicationVersion("1.2.9")
        app.setOrganizationName("Gary's Software")

        # All widget creation must be after QApplication
        manager = SimpleFileManager()
        manager.show()

        # Run application and capture exit code
        exit_code = app.exec_()

        # Platform-specific cleanup
        if sys.platform.startswith('win'):
            print("Windows cleanup - forcing exit...")
            import os
            os._exit(exit_code)
        else:
            print("Standard exit...")
            sys.exit(exit_code)

    except Exception as e:
        print(f"Application startup failed: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()

# ==================== PERFORMANCE PROFILING UTILITIES ====================

def print_performance_summary() -> None:
    """Print a summary of performance metrics"""
    summary = performance_profiler.get_summary()
    if not summary:
        print("No performance metrics recorded.")
        return
    
    print("\n" + "="*80)
    print("PERFORMANCE SUMMARY")
    print("="*80)
    
    for op_name, stats in summary.items():
        print(f"\nOperation: {op_name}")
        print(f"  Count: {stats['count']}")
        print(f"  Total Duration: {stats['total_duration']:.3f}s")
        print(f"  Average Duration: {stats['avg_duration']:.3f}s")
        print(f"  Max Duration: {stats['max_duration']:.3f}s")
        print(f"  Min Duration: {stats['min_duration']:.3f}s")
        print(f"  Average Memory Delta: {stats['avg_memory_delta']:.2f}MB")

def clear_performance_metrics() -> None:
    """Clear all performance metrics"""
    performance_profiler.clear_metrics()
    print("Performance metrics cleared.")

def enable_performance_profiling() -> None:
    """Enable performance profiling"""
    performance_profiler.enable()
    print("Performance profiling enabled.")

def disable_performance_profiling() -> None:
    """Disable performance profiling"""
    performance_profiler.disable()
    print("Performance profiling disabled.")

# ==================== DEMONSTRATION FUNCTIONS ====================

@profile_performance('demo_file_operation')
def demo_file_operation() -> None:
    """Demonstration of profiled file operation"""
    import time
    # Simulate file operation
    time.sleep(0.1)
    # Simulate memory allocation
    data = [i for i in range(10000)]
    time.sleep(0.05)
    del data

def demo_performance_context() -> None:
    """Demonstration of performance context manager"""
    with performance_context('demo_context_operation'):
        # Simulate some work
        import time
        time.sleep(0.2)
        data = list(range(50000))
        time.sleep(0.1)

# ==================== ERROR HANDLING DEMONSTRATIONS ====================

def demo_error_handling() -> None:
    """Demonstrate improved error handling"""
    try:
        # This will raise a ThumbnailError
        get_waveform_thumbnail('/nonexistent/file.wav')
    except ThumbnailError as e:
        print(f"Caught ThumbnailError: {e}")
    
    try:
        # This will raise a ConfigurationError
        smb_tab = SmbBrowserTab()
        smb_tab.apply_theme_dict({})  # Missing required theme keys
    except ConfigurationError as e:
        print(f"Caught ConfigurationError: {e}")

# ==================== LOGGING DEMONSTRATION ====================

def demo_logging() -> None:
    """Demonstrate improved logging system"""
    logger = setup_logger('demo')
    
    logger.info("This is an info message")
    logger.warning("This is a warning message")
    logger.error("This is an error message")
    
    # Demonstrate thumbnail logging
    thumbnail_debug("This is a thumbnail debug message")
    thumbnail_info("This is a thumbnail info message")
    thumbnail_error("This is a thumbnail error message")

# ==================== USAGE EXAMPLES ====================

def run_performance_demo() -> None:
    """Run a complete performance profiling demonstration"""
    print("Running performance profiling demonstration...")
    
    # Enable profiling
    enable_performance_profiling()
    
    # Run some operations
    for i in range(3):
        demo_file_operation()
        demo_performance_context()
    
    # Show results
    print_performance_summary()
    
    # Clean up
    clear_performance_metrics()

def run_error_handling_demo() -> None:
    """Run error handling demonstration"""
    print("\nRunning error handling demonstration...")
    demo_error_handling()

def run_logging_demo() -> None:
    """Run logging demonstration"""
    print("\nRunning logging demonstration...")
    demo_logging()

# Run demonstrations if this script is executed directly with --demo flag
if __name__ == '__main__' and len(sys.argv) > 1 and '--demo' in sys.argv:
    print("Gary's File Manager - Improvements Demonstration")
    print("=" * 50)
    
    run_performance_demo()
    run_error_handling_demo()
    run_logging_demo()
    
    print("\nDemonstration complete!")
    print("To use these features in the main application:")
    print("1. Use @profile_performance('operation_name') decorator on methods")
    print("2. Use 'with performance_context('operation'):' for code blocks") 
    print("3. Call print_performance_summary() to see metrics")
    print("4. Use custom exceptions (ThumbnailError, NetworkError, etc.)")
    print("5. Use setup_logger() for proper logging in new modules")


# -------------------- Upload helpers (GitHub + SourceForge) --------------------
def upload_to_github_release(file_path, repo, tag, token, release_name=None):
    """Upload a file to a GitHub release. If release for tag doesn't exist, create it.

    Args:
        file_path: local path to upload
        repo: 'owner/repo'
        tag: git tag name for the release
        token: GitHub personal access token with repo permissions
        release_name: optional release name
    Returns: dict response JSON on success
    """
    import os
    import requests

    api = 'https://api.github.com'
    headers = {'Authorization': f'token {token}', 'Accept': 'application/vnd.github.v3+json'}

    # Find release for tag
    r = requests.get(f'{api}/repos/{repo}/releases', headers=headers)
    r.raise_for_status()
    releases = r.json()
    release = next((rel for rel in releases if rel.get('tag_name') == tag), None)

    if release is None:
        # Create release
        payload = {'tag_name': tag, 'name': release_name or tag, 'prerelease': False}
        r = requests.post(f'{api}/repos/{repo}/releases', json=payload, headers=headers)
        r.raise_for_status()
        release = r.json()

    upload_url = release.get('upload_url', '').split('{')[0]
    if not upload_url:
        raise RuntimeError('Release upload URL not found')

    filename = os.path.basename(file_path)
    params = {'name': filename}
    with open(file_path, 'rb') as fh:
        headers['Content-Type'] = 'application/octet-stream'
        upload_resp = requests.post(upload_url, params=params, data=fh, headers=headers)
        upload_resp.raise_for_status()
        return upload_resp.json()


def upload_to_sourceforge(file_path, project, username, password, sftp_path='/incoming'):
    """Upload a file to SourceForge.

    Strategy:
    1. Attempt a simple HTTP POST to an illustrative FRS endpoint (may fail).
    2. If HTTP POST fails, fall back to SFTP upload to the project's incoming directory
       using paramiko. This is often the recommended programmatic approach.

    Returns: dict {status: 'ok'|'error', message: str, details: opt}
    """
    import os
    import requests

    basename = os.path.basename(file_path)

    # First attempt: HTTP POST (illustrative)
    try:
        upload_url = f'https://frs.sourceforge.net/api/1.0/projects/{project}/upload/'
        with open(file_path, 'rb') as fh:
            files = {'file': (basename, fh)}
            data = {'user': username, 'pass': password}
            r = requests.post(upload_url, files=files, data=data, timeout=60)
        if r.status_code in (200, 201):
            try:
                payload = r.json() if r.headers.get('Content-Type', '').startswith('application/json') else {'status': 'ok'}
            except Exception:
                payload = {'status': 'ok', 'text': r.text}
            return {'status': 'ok', 'method': 'http', 'details': payload}
    except Exception as e:
        http_err = e
    else:
        http_err = None

    # Fallback: SFTP via paramiko
    try:
        import paramiko
    except Exception as e:
        return {'status': 'error', 'message': 'HTTP upload failed and paramiko (SFTP) is not available', 'details': str(http_err or e)}

    try:
        transport = paramiko.Transport(("frs.sourceforge.net", 22))
        transport.connect(username=username, password=password)
        sftp = paramiko.SFTPClient.from_transport(transport)
        remote_dir = sftp_path or '/incoming'
        try:
            sftp.chdir(remote_dir)
        except IOError:
            # try to create remote dir
            try:
                sftp.mkdir(remote_dir)
                sftp.chdir(remote_dir)
            except Exception:
                pass

        remote_path = os.path.join(remote_dir, basename)
        sftp.put(file_path, remote_path)
        sftp.close()
        transport.close()
        return {'status': 'ok', 'method': 'sftp', 'path': remote_path}
    except Exception as e:
        return {'status': 'error', 'message': 'Both HTTP and SFTP upload attempts failed', 'details': str(e)}


def cli_upload():
    """Simple CLI helper to upload a file to GitHub or SourceForge.

    Prompts the user on stdin for required values.
    """
    import getpass
    import requests
    print('Upload helper')
    choice = input('Upload to (g)ithub or (s)ourceforge? [g/s]: ').strip().lower()
    path = input('Path to file: ').strip()
    if choice == 'g':
        repo = input('GitHub repo (owner/repo): ').strip()
        tag = input('Release tag (e.g. v1.0): ').strip()
        token = getpass.getpass('GitHub token: ')
        print('Uploading...')
        print(upload_to_github_release(path, repo, tag, token))
    else:
        project = input('SourceForge project short name: ').strip()
        username = input('SF username: ').strip()
        password = getpass.getpass('SF password: ')
        print('Uploading...')
        print(upload_to_sourceforge(path, project, username, password))
